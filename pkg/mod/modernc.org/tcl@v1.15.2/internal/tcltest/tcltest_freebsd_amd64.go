// Code generated by 'ccgo -export-defines "" -lmodernc.org/tcl/lib -nocapi -o internal/tcltest/tcltest_freebsd_amd64.go -trace-translation-units --load-config "" -save-config "" /tmp/go-generate-1496507531/cdb.json tclAppInit.o#1 tclTest.o tclTestObj.o tclTestProcBodyObj.o tclThreadTest.o tclUnixTest.o', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/tcl/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BUFSIZ                                = 1024
	CRTIMPORT                             = 0
	DLLIMPORT                             = 0
	EOF                                   = -1
	FILENAME_MAX                          = 1024
	FOPEN_MAX                             = 20
	HAVE_BLKCNT_T                         = 1
	HAVE_CAST_TO_UNION                    = 1
	HAVE_CHFLAGS                          = 1
	HAVE_FREEADDRINFO                     = 1
	HAVE_FTS                              = 1
	HAVE_GAI_STRERROR                     = 1
	HAVE_GETADDRINFO                      = 1
	HAVE_GETCWD                           = 1
	HAVE_GETNAMEINFO                      = 1
	HAVE_GMTIME_R                         = 1
	HAVE_HIDDEN                           = 1
	HAVE_INTPTR_T                         = 1
	HAVE_INTTYPES_H                       = 1
	HAVE_LANGINFO                         = 1
	HAVE_LOCALTIME_R                      = 1
	HAVE_MEMORY_H                         = 1
	HAVE_MKSTEMP                          = 1
	HAVE_MKSTEMPS                         = 1
	HAVE_MKTIME                           = 1
	HAVE_OPENDIR                          = 1
	HAVE_SIGNED_CHAR                      = 1
	HAVE_STDINT_H                         = 1
	HAVE_STDLIB_H                         = 1
	HAVE_STRINGS_H                        = 1
	HAVE_STRING_H                         = 1
	HAVE_STRTOL                           = 1
	HAVE_STRUCT_ADDRINFO                  = 1
	HAVE_STRUCT_IN6_ADDR                  = 1
	HAVE_STRUCT_SOCKADDR_IN6              = 1
	HAVE_STRUCT_SOCKADDR_STORAGE          = 1
	HAVE_STRUCT_STAT_ST_BLKSIZE           = 1
	HAVE_STRUCT_STAT_ST_BLOCKS            = 1
	HAVE_SYS_FILIO_H                      = 1
	HAVE_SYS_IOCTL_H                      = 1
	HAVE_SYS_PARAM_H                      = 1
	HAVE_SYS_STAT_H                       = 1
	HAVE_SYS_TIME_H                       = 1
	HAVE_SYS_TYPES_H                      = 1
	HAVE_TERMIOS_H                        = 1
	HAVE_TM_GMTOFF                        = 1
	HAVE_UINTPTR_T                        = 1
	HAVE_UNISTD_H                         = 1
	HAVE_WAITPID                          = 1
	HAVE_ZLIB                             = 1
	INLINE                                = 0
	L_ctermid                             = 1024
	L_cuserid                             = 17
	L_tmpnam                              = 1024
	MP_DIGIT_DECLARED                     = 0
	MP_FIXED_CUTOFFS                      = 1
	MP_INT_DECLARED                       = 0
	MP_NO_STDINT                          = 1
	MP_PREC                               = 4
	NDEBUG                                = 1
	NO_ISNAN                              = 1
	NO_UNION_WAIT                         = 1
	NO_VALUES_H                           = 1
	NUM_STATIC_TOKENS                     = 20
	PACKAGE_BUGREPORT                     = ""
	PACKAGE_NAME                          = "tcl"
	PACKAGE_STRING                        = "tcl 8.6"
	PACKAGE_TARNAME                       = "tcl"
	PACKAGE_VERSION                       = "8.6"
	P_tmpdir                              = "/tmp/"
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	STDC_HEADERS                          = 1
	TCL_ALLOW_INLINE_COMPILATION          = 0x20000
	TCL_ALL_EVENTS                        = -3
	TCL_ALPHA_RELEASE                     = 0
	TCL_APPEND_VALUE                      = 4
	TCL_ARGV_CONSTANT                     = 15
	TCL_ARGV_END                          = 23
	TCL_ARGV_FLOAT                        = 19
	TCL_ARGV_FUNC                         = 20
	TCL_ARGV_GENFUNC                      = 21
	TCL_ARGV_HELP                         = 22
	TCL_ARGV_INT                          = 16
	TCL_ARGV_REST                         = 18
	TCL_ARGV_STRING                       = 17
	TCL_BETA_RELEASE                      = 1
	TCL_BREAK                             = 3
	TCL_BUILDTIME_LIBRARY                 = "/tmp/go-generate-1496507531/tcl8.6.12/library"
	TCL_CANCEL_UNWIND                     = 0x100000
	TCL_CFGVAL_ENCODING                   = "iso8859-1"
	TCL_CFG_OPTIMIZED                     = 1
	TCL_CHANNEL_THREAD_INSERT             = 0
	TCL_CHANNEL_THREAD_REMOVE             = 1
	TCL_CLOSE_READ                        = 2
	TCL_CLOSE_WRITE                       = 4
	TCL_CONTINUE                          = 4
	TCL_CONVERT_MULTIBYTE                 = -1
	TCL_CONVERT_NOSPACE                   = -4
	TCL_CONVERT_SYNTAX                    = -2
	TCL_CONVERT_UNKNOWN                   = -3
	TCL_CREATE_HARD_LINK                  = 0x02
	TCL_CREATE_SYMBOLIC_LINK              = 0x01
	TCL_CUSTOM_PTR_KEYS                   = -1
	TCL_CUSTOM_TYPE_KEYS                  = -2
	TCL_DONT_QUOTE_HASH                   = 8
	TCL_DONT_USE_BRACES                   = 1
	TCL_DONT_WAIT                         = 2
	TCL_DOUBLE_SPACE                      = 27
	TCL_DSTRING_STATIC_SIZE               = 200
	TCL_ENCODING_CHAR_LIMIT               = 0x10
	TCL_ENCODING_END                      = 0x02
	TCL_ENCODING_NO_TERMINATE             = 0x08
	TCL_ENCODING_START                    = 0x01
	TCL_ENCODING_STOPONERROR              = 0x04
	TCL_ENFORCE_MODE                      = 16
	TCL_ENSEMBLE_PREFIX                   = 0x02
	TCL_ERROR                             = 1
	TCL_EVAL_DIRECT                       = 0x040000
	TCL_EVAL_GLOBAL                       = 0x020000
	TCL_EVAL_INVOKE                       = 0x080000
	TCL_EVAL_NOERR                        = 0x200000
	TCL_EXACT                             = 1
	TCL_EXCEPTION                         = 8
	TCL_FILE_EVENTS                       = 8
	TCL_FINAL_RELEASE                     = 2
	TCL_GLOBAL_ONLY                       = 1
	TCL_GLOB_PERM_HIDDEN                  = 2
	TCL_GLOB_PERM_R                       = 4
	TCL_GLOB_PERM_RONLY                   = 1
	TCL_GLOB_PERM_W                       = 8
	TCL_GLOB_PERM_X                       = 16
	TCL_GLOB_TYPE_BLOCK                   = 1
	TCL_GLOB_TYPE_CHAR                    = 2
	TCL_GLOB_TYPE_DIR                     = 4
	TCL_GLOB_TYPE_FILE                    = 16
	TCL_GLOB_TYPE_LINK                    = 32
	TCL_GLOB_TYPE_MOUNT                   = 128
	TCL_GLOB_TYPE_PIPE                    = 8
	TCL_GLOB_TYPE_SOCK                    = 64
	TCL_HASH_KEY_RANDOMIZE_HASH           = 0x1
	TCL_HASH_KEY_STORE_HASH               = 1
	TCL_HASH_KEY_SYSTEM_HASH              = 0x2
	TCL_HASH_KEY_TYPE_VERSION             = 1
	TCL_IDLE_EVENTS                       = 32
	TCL_INTEGER_SPACE                     = 24
	TCL_INTERP_DESTROYED                  = 0x100
	TCL_LEAVE_ERR_MSG                     = 0x200
	TCL_LIMIT_COMMANDS                    = 0x01
	TCL_LIMIT_TIME                        = 0x02
	TCL_LINK_BOOLEAN                      = 3
	TCL_LINK_CHAR                         = 6
	TCL_LINK_DOUBLE                       = 2
	TCL_LINK_FLOAT                        = 13
	TCL_LINK_INT                          = 1
	TCL_LINK_LONG                         = 11
	TCL_LINK_READ_ONLY                    = 0x80
	TCL_LINK_SHORT                        = 8
	TCL_LINK_STRING                       = 4
	TCL_LINK_UCHAR                        = 7
	TCL_LINK_UINT                         = 10
	TCL_LINK_ULONG                        = 12
	TCL_LINK_USHORT                       = 9
	TCL_LINK_WIDE_INT                     = 5
	TCL_LINK_WIDE_UINT                    = 14
	TCL_LIST_ELEMENT                      = 8
	TCL_LL_MODIFIER                       = "l"
	TCL_LOAD_GLOBAL                       = 1
	TCL_LOAD_LAZY                         = 2
	TCL_MAJOR_VERSION                     = 8
	TCL_MATCH_NOCASE                      = 1
	TCL_MAX_PREC                          = 17
	TCL_MINOR_VERSION                     = 6
	TCL_MODE_BLOCKING                     = 0
	TCL_MODE_NONBLOCKING                  = 1
	TCL_NAMESPACE_ONLY                    = 2
	TCL_NORETURN1                         = 0
	TCL_NO_EVAL                           = 0x010000
	TCL_OK                                = 0
	TCL_ONE_WORD_KEYS                     = 1
	TCL_PARSE_BAD_NUMBER                  = 9
	TCL_PARSE_BRACE_EXTRA                 = 2
	TCL_PARSE_MISSING_BRACE               = 3
	TCL_PARSE_MISSING_BRACKET             = 4
	TCL_PARSE_MISSING_PAREN               = 5
	TCL_PARSE_MISSING_QUOTE               = 6
	TCL_PARSE_MISSING_VAR_BRACE           = 7
	TCL_PARSE_PART1                       = 0x400
	TCL_PARSE_QUOTE_EXTRA                 = 1
	TCL_PARSE_SUCCESS                     = 0
	TCL_PARSE_SYNTAX                      = 8
	TCL_PATCH_LEVEL                       = "8.6.12"
	TCL_READABLE                          = 2
	TCL_REG_ADVANCED                      = 000003
	TCL_REG_ADVF                          = 000002
	TCL_REG_BASIC                         = 000000
	TCL_REG_CANMATCH                      = 001000
	TCL_REG_EXPANDED                      = 000040
	TCL_REG_EXTENDED                      = 000001
	TCL_REG_NEWLINE                       = 000300
	TCL_REG_NLANCH                        = 000200
	TCL_REG_NLSTOP                        = 000100
	TCL_REG_NOCASE                        = 000010
	TCL_REG_NOSUB                         = 000020
	TCL_REG_NOTBOL                        = 0001
	TCL_REG_NOTEOL                        = 0002
	TCL_REG_QUOTE                         = 000004
	TCL_RELEASE_LEVEL                     = 2
	TCL_RELEASE_SERIAL                    = 12
	TCL_RESULT_SIZE                       = 200
	TCL_RETURN                            = 2
	TCL_SERVICE_ALL                       = 1
	TCL_SERVICE_NONE                      = 0
	TCL_SHLIB_EXT                         = ""
	TCL_SMALL_HASH_TABLE                  = 4
	TCL_STDERR                            = 8
	TCL_STDIN                             = 2
	TCL_STDOUT                            = 4
	TCL_STORAGE_CLASS                     = 0
	TCL_STRING_KEYS                       = 0
	TCL_SUBST_ALL                         = 007
	TCL_SUBST_BACKSLASHES                 = 004
	TCL_SUBST_COMMANDS                    = 001
	TCL_SUBST_VARIABLES                   = 002
	TCL_TEST                              = 1
	TCL_THREAD_CREATE_RETURN              = 0
	TCL_THREAD_JOINABLE                   = 1
	TCL_THREAD_NOFLAGS                    = 0
	TCL_THREAD_STACK_DEFAULT              = 0
	TCL_TIMER_EVENTS                      = 16
	TCL_TOKEN_BS                          = 8
	TCL_TOKEN_COMMAND                     = 16
	TCL_TOKEN_EXPAND_WORD                 = 256
	TCL_TOKEN_OPERATOR                    = 128
	TCL_TOKEN_SIMPLE_WORD                 = 2
	TCL_TOKEN_SUB_EXPR                    = 64
	TCL_TOKEN_TEXT                        = 4
	TCL_TOKEN_VARIABLE                    = 32
	TCL_TOKEN_WORD                        = 1
	TCL_TOMMATH                           = 1
	TCL_TRACE_ARRAY                       = 0x800
	TCL_TRACE_DELETE                      = 0x4000
	TCL_TRACE_DESTROYED                   = 0x80
	TCL_TRACE_OLD_STYLE                   = 0x1000
	TCL_TRACE_READS                       = 0x10
	TCL_TRACE_RENAME                      = 0x2000
	TCL_TRACE_RESULT_DYNAMIC              = 0x8000
	TCL_TRACE_RESULT_OBJECT               = 0x10000
	TCL_TRACE_UNSETS                      = 0x40
	TCL_TRACE_WRITES                      = 0x20
	TCL_UNLOAD_DETACH_FROM_INTERPRETER    = 1
	TCL_UNLOAD_DETACH_FROM_PROCESS        = 2
	TCL_UNLOAD_DLLS                       = 1
	TCL_UTF_MAX                           = 3
	TCL_VERSION                           = "8.6"
	TCL_WIDE_INT_IS_LONG                  = 1
	TCL_WINDOW_EVENTS                     = 4
	TCL_WRITABLE                          = 4
	TCL_ZLIB_COMPRESS_BEST                = 9
	TCL_ZLIB_COMPRESS_DEFAULT             = -1
	TCL_ZLIB_COMPRESS_FAST                = 1
	TCL_ZLIB_COMPRESS_NONE                = 0
	TCL_ZLIB_FINALIZE                     = 4
	TCL_ZLIB_FLUSH                        = 2
	TCL_ZLIB_FORMAT_AUTO                  = 8
	TCL_ZLIB_FORMAT_GZIP                  = 4
	TCL_ZLIB_FORMAT_RAW                   = 1
	TCL_ZLIB_FORMAT_ZLIB                  = 2
	TCL_ZLIB_FULLFLUSH                    = 3
	TCL_ZLIB_NO_FLUSH                     = 0
	TCL_ZLIB_STREAM_DEFLATE               = 16
	TCL_ZLIB_STREAM_INFLATE               = 32
	TIME_WITH_SYS_TIME                    = 1
	TMP_MAX                               = 308915776
	X_CLIENTDATA                          = 0
	X_FILE_OFFSET_BITS                    = 64
	X_FSTDIO                              = 0
	X_FTRUNCATE_DECLARED                  = 0
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_LP64                                = 1
	X_LSEEK_DECLARED                      = 0
	X_MACHINE_STDARG_H_                   = 0
	X_MACHINE__LIMITS_H_                  = 0
	X_MACHINE__TYPES_H_                   = 0
	X_MMAP_DECLARED                       = 0
	X_Nonnull                             = 0
	X_Null_unspecified                    = 0
	X_Nullable                            = 0
	X_OFF64_T_DECLARED                    = 0
	X_OFF_T_DECLARED                      = 0
	X_RSIZE_T_DEFINED                     = 0
	X_SIZE_T_DECLARED                     = 0
	X_SSIZE_T_DECLARED                    = 0
	X_STDFILE_DECLARED                    = 0
	X_STDIO_H_                            = 0
	X_STDSTREAM_DECLARED                  = 0
	X_SYS_CDEFS_H_                        = 0
	X_SYS__STDARG_H_                      = 0
	X_SYS__TYPES_H_                       = 0
	X_TCL                                 = 0
	X_TCLDECLS                            = 0
	X_TCLPLATDECLS                        = 0
	X_TRUNCATE_DECLARED                   = 0
	X_VA_LIST_DECLARED                    = 0
	Unix                                  = 1
	ACCESSPERMS                           = 511
	AF_APPLETALK                          = 16
	AF_ARP                                = 35
	AF_ATM                                = 30
	AF_BLUETOOTH                          = 36
	AF_CCITT                              = 10
	AF_CHAOS                              = 5
	AF_CNT                                = 21
	AF_COIP                               = 20
	AF_DATAKIT                            = 9
	AF_DECnet                             = 12
	AF_DLI                                = 13
	AF_E164                               = 26
	AF_ECMA                               = 8
	AF_HYLINK                             = 15
	AF_HYPERV                             = 43
	AF_IEEE80211                          = 37
	AF_IMPLINK                            = 3
	AF_INET                               = 2
	AF_INET6                              = 28
	AF_INET6_SDP                          = 42
	AF_INET_SDP                           = 40
	AF_IPX                                = 23
	AF_ISDN                               = 26
	AF_ISO                                = 7
	AF_LAT                                = 14
	AF_LINK                               = 18
	AF_LOCAL                              = 1
	AF_MAX                                = 43
	AF_NATM                               = 29
	AF_NETBIOS                            = 6
	AF_NETGRAPH                           = 32
	AF_OSI                                = 7
	AF_PUP                                = 4
	AF_ROUTE                              = 17
	AF_SCLUSTER                           = 34
	AF_SIP                                = 24
	AF_SLOW                               = 33
	AF_SNA                                = 11
	AF_UNIX                               = 1
	AF_UNSPEC                             = 0
	AF_VENDOR00                           = 39
	AF_VENDOR01                           = 41
	AF_VENDOR03                           = 45
	AF_VENDOR04                           = 47
	AF_VENDOR05                           = 49
	AF_VENDOR06                           = 51
	AF_VENDOR07                           = 53
	AF_VENDOR08                           = 55
	AF_VENDOR09                           = 57
	AF_VENDOR10                           = 59
	AF_VENDOR11                           = 61
	AF_VENDOR12                           = 63
	AF_VENDOR13                           = 65
	AF_VENDOR14                           = 67
	AF_VENDOR15                           = 69
	AF_VENDOR16                           = 71
	AF_VENDOR17                           = 73
	AF_VENDOR18                           = 75
	AF_VENDOR19                           = 77
	AF_VENDOR20                           = 79
	AF_VENDOR21                           = 81
	AF_VENDOR22                           = 83
	AF_VENDOR23                           = 85
	AF_VENDOR24                           = 87
	AF_VENDOR25                           = 89
	AF_VENDOR26                           = 91
	AF_VENDOR27                           = 93
	AF_VENDOR28                           = 95
	AF_VENDOR29                           = 97
	AF_VENDOR30                           = 99
	AF_VENDOR31                           = 101
	AF_VENDOR32                           = 103
	AF_VENDOR33                           = 105
	AF_VENDOR34                           = 107
	AF_VENDOR35                           = 109
	AF_VENDOR36                           = 111
	AF_VENDOR37                           = 113
	AF_VENDOR38                           = 115
	AF_VENDOR39                           = 117
	AF_VENDOR40                           = 119
	AF_VENDOR41                           = 121
	AF_VENDOR42                           = 123
	AF_VENDOR43                           = 125
	AF_VENDOR44                           = 127
	AF_VENDOR45                           = 129
	AF_VENDOR46                           = 131
	AF_VENDOR47                           = 133
	AI_ADDRCONFIG                         = 0x00000400
	AI_ALL                                = 0x00000100
	AI_CANONNAME                          = 0x00000002
	AI_DEFAULT                            = 1536
	AI_MASK                               = 3343
	AI_NUMERICHOST                        = 0x00000004
	AI_NUMERICSERV                        = 0x00000008
	AI_PASSIVE                            = 0x00000001
	AI_V4MAPPED                           = 0x00000800
	AI_V4MAPPED_CFG                       = 0x00000200
	ALLPERMS                              = 4095
	ARG_MAX                               = 524288
	AT_EACCESS                            = 0x0100
	AT_FDCWD                              = -100
	AT_REMOVEDIR                          = 0x0800
	AT_RESOLVE_BENEATH                    = 0x2000
	AT_SYMLINK_FOLLOW                     = 0x0400
	AT_SYMLINK_NOFOLLOW                   = 0x0200
	BC_BASE_MAX                           = 99
	BC_DIM_MAX                            = 2048
	BC_SCALE_MAX                          = 99
	BC_STRING_MAX                         = 1000
	BG_FLUSH_SCHEDULED                    = 128
	BIG_ENDIAN                            = 4321
	BKVAMASK                              = 16383
	BKVASIZE                              = 16384
	BLKDEV_IOSIZE                         = 4096
	BN_H_                                 = 0
	BSD                                   = 199506
	BSD4_3                                = 1
	BSD4_4                                = 1
	BUFFER_PADDING                        = 16
	BUILD_tcl                             = 1
	BUS_ADRALN                            = 1
	BUS_ADRERR                            = 2
	BUS_OBJERR                            = 3
	BUS_OOMERR                            = 100
	BYTE_ORDER                            = 1234
	CACHE_LINE_SHIFT                      = 6
	CACHE_LINE_SIZE                       = 64
	CANCELED                              = 0x1000
	CHANNELBUFFER_DEFAULT_SIZE            = 4096
	CHANNEL_BLOCKED                       = 2048
	CHANNEL_CLOSED                        = 256
	CHANNEL_CLOSEDWRITE                   = 2097152
	CHANNEL_DEAD                          = 8192
	CHANNEL_EOF                           = 512
	CHANNEL_INCLOSE                       = 524288
	CHANNEL_LINEBUFFERED                  = 16
	CHANNEL_NEED_MORE_DATA                = 16384
	CHANNEL_NONBLOCKING                   = 8
	CHANNEL_RAW_MODE                      = 65536
	CHANNEL_STICKY_EOF                    = 1024
	CHANNEL_UNBUFFERED                    = 32
	CHARCLASS_NAME_MAX                    = 14
	CHAR_BIT                              = 8
	CHAR_MAX                              = 127
	CHAR_MIN                              = -128
	CHILD_MAX                             = 40
	CLD_CONTINUED                         = 6
	CLD_DUMPED                            = 3
	CLD_EXITED                            = 1
	CLD_KILLED                            = 2
	CLD_STOPPED                           = 5
	CLD_TRAPPED                           = 4
	CLK_TCK                               = 128
	CLL_END                               = -1
	CLOCKS_PER_SEC                        = 128
	CLOCK_MONOTONIC                       = 4
	CLOCK_MONOTONIC_FAST                  = 12
	CLOCK_MONOTONIC_PRECISE               = 11
	CLOCK_PROCESS_CPUTIME_ID              = 15
	CLOCK_PROF                            = 2
	CLOCK_REALTIME                        = 0
	CLOCK_REALTIME_FAST                   = 10
	CLOCK_REALTIME_PRECISE                = 9
	CLOCK_SECOND                          = 13
	CLOCK_THREAD_CPUTIME_ID               = 14
	CLOCK_UPTIME                          = 5
	CLOCK_UPTIME_FAST                     = 8
	CLOCK_UPTIME_PRECISE                  = 7
	CLOCK_VIRTUAL                         = 1
	CMASK                                 = 022
	CMD_COMPILES_EXPANDED                 = 0x08
	CMD_DEAD                              = 0x40
	CMD_HAS_EXEC_TRACES                   = 0x04
	CMD_IS_DELETED                        = 0x01
	CMD_REDEF_IN_PROGRESS                 = 0x10
	CMD_TRACE_ACTIVE                      = 0x02
	CMD_VIA_RESOLVER                      = 0x20
	CMGROUP_MAX                           = 16
	COLL_WEIGHTS_MAX                      = 10
	CPUCLOCK_WHICH_PID                    = 0
	CPUCLOCK_WHICH_TID                    = 1
	DBL_DECIMAL_DIG                       = 17
	DBL_DIG                               = 15
	DBL_EPSILON                           = 2.2204460492503131e-16
	DBL_HAS_SUBNORM                       = 1
	DBL_MANT_DIG                          = 53
	DBL_MAX                               = 1.7976931348623157e+308
	DBL_MAX_10_EXP                        = 308
	DBL_MAX_EXP                           = 1024
	DBL_MIN                               = 2.2250738585072014e-308
	DBL_MIN_10_EXP                        = -307
	DBL_MIN_EXP                           = -1021
	DBL_TRUE_MIN                          = 4.9406564584124654e-324
	DECIMAL_DIG                           = 21
	DEFFILEMODE                           = 438
	DELETED                               = 1
	DEV_BSHIFT                            = 9
	DEV_BSIZE                             = 512
	DFLTPHYS                              = 65536
	DICT_PATH_CREATE                      = 5
	DICT_PATH_EXISTS                      = 2
	DICT_PATH_READ                        = 0
	DICT_PATH_UPDATE                      = 1
	DIGIT_BIT                             = 28
	DIRBLKSIZ                             = 1024
	DONT_COMPILE_CMDS_INLINE              = 0x20
	DST_AUST                              = 2
	DST_CAN                               = 6
	DST_EET                               = 5
	DST_MET                               = 4
	DST_NONE                              = 0
	DST_USA                               = 1
	DST_WET                               = 3
	DTF_HIDEW                             = 0x0001
	DTF_NODUP                             = 0x0002
	DTF_REWIND                            = 0x0004
	DTYPE_CRYPTO                          = 6
	DTYPE_DEV                             = 11
	DTYPE_EVENTFD                         = 13
	DTYPE_FIFO                            = 4
	DTYPE_KQUEUE                          = 5
	DTYPE_LINUXTFD                        = 14
	DTYPE_MQUEUE                          = 7
	DTYPE_NONE                            = 0
	DTYPE_PIPE                            = 3
	DTYPE_PROCDESC                        = 12
	DTYPE_PTS                             = 10
	DTYPE_SEM                             = 9
	DTYPE_SHM                             = 8
	DTYPE_SOCKET                          = 2
	DTYPE_VNODE                           = 1
	DT_BLK                                = 6
	DT_CHR                                = 2
	DT_DIR                                = 4
	DT_FIFO                               = 1
	DT_LNK                                = 10
	DT_REG                                = 8
	DT_SOCK                               = 12
	DT_UNKNOWN                            = 0
	DT_WHT                                = 14
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 48
	EADDRNOTAVAIL                         = 49
	EAFNOSUPPORT                          = 47
	EAGAIN                                = 35
	EAI_AGAIN                             = 2
	EAI_BADFLAGS                          = 3
	EAI_BADHINTS                          = 12
	EAI_FAIL                              = 4
	EAI_FAMILY                            = 5
	EAI_MAX                               = 15
	EAI_MEMORY                            = 6
	EAI_NONAME                            = 8
	EAI_OVERFLOW                          = 14
	EAI_PROTOCOL                          = 13
	EAI_SERVICE                           = 9
	EAI_SOCKTYPE                          = 10
	EAI_SYSTEM                            = 11
	EALREADY                              = 37
	EAUTH                                 = 80
	EBADF                                 = 9
	EBADMSG                               = 89
	EBADRPC                               = 72
	EBUSY                                 = 16
	ECANCELED                             = 85
	ECAPMODE                              = 94
	ECHILD                                = 10
	ECONNABORTED                          = 53
	ECONNREFUSED                          = 61
	ECONNRESET                            = 54
	EDEADLK                               = 11
	EDESTADDRREQ                          = 39
	EDOM                                  = 33
	EDOOFUS                               = 88
	EDQUOT                                = 69
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EFTYPE                                = 79
	EHOSTDOWN                             = 64
	EHOSTUNREACH                          = 65
	EIDRM                                 = 82
	EILSEQ                                = 86
	EINPROGRESS                           = 36
	EINTEGRITY                            = 97
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EISCONN                               = 56
	EISDIR                                = 21
	ELAST                                 = 97
	ELOOP                                 = 62
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 40
	EMULTIHOP                             = 90
	ENAMETOOLONG                          = 63
	ENEEDAUTH                             = 81
	ENETDOWN                              = 50
	ENETRESET                             = 52
	ENETUNREACH                           = 51
	ENFILE                                = 23
	ENOATTR                               = 87
	ENOBUFS                               = 55
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOLCK                                = 77
	ENOLINK                               = 91
	ENOMEM                                = 12
	ENOMSG                                = 83
	ENOPROTOOPT                           = 42
	ENOSPC                                = 28
	ENOSYS                                = 78
	ENOTBLK                               = 15
	ENOTCAPABLE                           = 93
	ENOTCONN                              = 57
	ENOTDIR                               = 20
	ENOTEMPTY                             = 66
	ENOTRECOVERABLE                       = 95
	ENOTSOCK                              = 38
	ENOTSUP                               = 45
	ENOTTY                                = 25
	ENSEMBLE_COMPILE                      = 0x4
	ENSEMBLE_DEAD                         = 0x1
	ENXIO                                 = 6
	EOPNOTSUPP                            = 45
	EOVERFLOW                             = 84
	EOWNERDEAD                            = 96
	EPERM                                 = 1
	EPFNOSUPPORT                          = 46
	EPIPE                                 = 32
	EPROCLIM                              = 67
	EPROCUNAVAIL                          = 76
	EPROGMISMATCH                         = 75
	EPROGUNAVAIL                          = 74
	EPROTO                                = 92
	EPROTONOSUPPORT                       = 43
	EPROTOTYPE                            = 41
	ERANGE                                = 34
	EREMOTE                               = 71
	EROFS                                 = 30
	ERPCMISMATCH                          = 73
	ERR_ALREADY_LOGGED                    = 4
	ERR_LEGACY_COPY                       = 0x800
	ESHUTDOWN                             = 58
	ESOCKTNOSUPPORT                       = 44
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESTALE                                = 70
	ETIMEDOUT                             = 60
	ETOOMANYREFS                          = 59
	ETXTBSY                               = 26
	EUSERS                                = 68
	EWOULDBLOCK                           = 35
	EXDEV                                 = 18
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	EXPR_NEST_MAX                         = 32
	FAPPEND                               = 8
	FASYNC                                = 64
	FDSYNC                                = 16777216
	FD_CLOEXEC                            = 1
	FD_NONE                               = -200
	FD_SETSIZE                            = 1024
	FFSYNC                                = 128
	FLT_DECIMAL_DIG                       = 9
	FLT_DIG                               = 6
	FLT_EPSILON                           = 1.19209290e-07
	FLT_EVAL_METHOD                       = 0
	FLT_HAS_SUBNORM                       = 1
	FLT_MANT_DIG                          = 24
	FLT_MAX                               = 3.40282347e+38
	FLT_MAX_10_EXP                        = 38
	FLT_MAX_EXP                           = 128
	FLT_MIN                               = 1.17549435e-38
	FLT_MIN_10_EXP                        = -37
	FLT_MIN_EXP                           = -125
	FLT_RADIX                             = 2
	FLT_TRUE_MIN                          = 1.40129846e-45
	FNDELAY                               = 4
	FNONBLOCK                             = 4
	FPE_FLTDIV                            = 3
	FPE_FLTINV                            = 7
	FPE_FLTOVF                            = 4
	FPE_FLTRES                            = 6
	FPE_FLTSUB                            = 8
	FPE_FLTUND                            = 5
	FPE_INTDIV                            = 2
	FPE_INTOVF                            = 1
	FP_FAST_FMAF                          = 1
	FP_ILOGB0                             = -2147483647
	FP_ILOGBNAN                           = 2147483647
	FP_INFINITE                           = 0x01
	FP_NAN                                = 0x02
	FP_NORMAL                             = 0x04
	FP_SUBNORMAL                          = 0x08
	FP_ZERO                               = 0x10
	FRAME_IS_LAMBDA                       = 0x2
	FRAME_IS_METHOD                       = 0x4
	FRAME_IS_OO_DEFINE                    = 0x8
	FRAME_IS_PROC                         = 0x1
	FRDAHEAD                              = 512
	FREAD                                 = 0x0001
	FSCALE                                = 2048
	FSHIFT                                = 11
	FWRITE                                = 0x0002
	F_ADD_SEALS                           = 19
	F_CANCEL                              = 5
	F_DUP2FD                              = 10
	F_DUP2FD_CLOEXEC                      = 18
	F_DUPFD                               = 0
	F_DUPFD_CLOEXEC                       = 17
	F_GETFD                               = 1
	F_GETFL                               = 3
	F_GETLK                               = 11
	F_GETOWN                              = 5
	F_GET_SEALS                           = 20
	F_ISUNIONSTACK                        = 21
	F_LOCK                                = 1
	F_OGETLK                              = 7
	F_OK                                  = 0
	F_OSETLK                              = 8
	F_OSETLKW                             = 9
	F_RDAHEAD                             = 16
	F_RDLCK                               = 1
	F_READAHEAD                           = 15
	F_SEAL_GROW                           = 0x0004
	F_SEAL_SEAL                           = 0x0001
	F_SEAL_SHRINK                         = 0x0002
	F_SEAL_WRITE                          = 0x0008
	F_SETFD                               = 2
	F_SETFL                               = 4
	F_SETLK                               = 12
	F_SETLKW                              = 13
	F_SETLK_REMOTE                        = 14
	F_SETOWN                              = 6
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	F_UNLCK                               = 2
	F_UNLCKSYS                            = 4
	F_WRLCK                               = 3
	GID_MAX                               = 4294967295
	HOST_NOT_FOUND                        = 1
	ICMP6_FILTER                          = 18
	ICMPV6CTL_ND6_ONLINKNSRFC4861         = 47
	ILL_BADSTK                            = 8
	ILL_COPROC                            = 7
	ILL_ILLADR                            = 3
	ILL_ILLOPC                            = 1
	ILL_ILLOPN                            = 2
	ILL_ILLTRP                            = 4
	ILL_PRVOPC                            = 5
	ILL_PRVREG                            = 6
	INET6_ADDRSTRLEN                      = 46
	INET_ADDRSTRLEN                       = 16
	INPUT_SAW_CR                          = 4096
	INT16_MAX                             = 0x7fff
	INT16_MIN                             = -32768
	INT32_MAX                             = 0x7fffffff
	INT32_MIN                             = -2147483648
	INT64_MAX                             = 0x7fffffffffffffff
	INT64_MIN                             = -9223372036854775808
	INT8_MAX                              = 0x7f
	INT8_MIN                              = -128
	INTERP_ALTERNATE_WRONG_ARGS           = 0x400
	INTERP_DEBUG_FRAME                    = 0x10
	INTERP_TRACE_IN_PROGRESS              = 0x200
	INTMAX_MAX                            = 9223372036854775807
	INTMAX_MIN                            = -9223372036854775808
	INTPTR_MAX                            = 9223372036854775807
	INTPTR_MIN                            = -9223372036854775808
	INT_FAST16_MAX                        = 2147483647
	INT_FAST16_MIN                        = -2147483648
	INT_FAST32_MAX                        = 2147483647
	INT_FAST32_MIN                        = -2147483648
	INT_FAST64_MAX                        = 9223372036854775807
	INT_FAST64_MIN                        = -9223372036854775808
	INT_FAST8_MAX                         = 2147483647
	INT_FAST8_MIN                         = -2147483648
	INT_LEAST16_MAX                       = 32767
	INT_LEAST16_MIN                       = -32768
	INT_LEAST32_MAX                       = 2147483647
	INT_LEAST32_MIN                       = -2147483648
	INT_LEAST64_MAX                       = 9223372036854775807
	INT_LEAST64_MIN                       = -9223372036854775808
	INT_LEAST8_MAX                        = 127
	INT_LEAST8_MIN                        = -128
	INT_MAX                               = 2147483647
	INT_MIN                               = -2147483648
	IN_CLASSA_HOST                        = 0x00ffffff
	IN_CLASSA_MAX                         = 128
	IN_CLASSA_NET                         = 0xff000000
	IN_CLASSA_NSHIFT                      = 24
	IN_CLASSB_HOST                        = 0x0000ffff
	IN_CLASSB_MAX                         = 65536
	IN_CLASSB_NET                         = 0xffff0000
	IN_CLASSB_NSHIFT                      = 16
	IN_CLASSC_HOST                        = 0x000000ff
	IN_CLASSC_NET                         = 0xffffff00
	IN_CLASSC_NSHIFT                      = 8
	IN_CLASSD_HOST                        = 0x0fffffff
	IN_CLASSD_NET                         = 0xf0000000
	IN_CLASSD_NSHIFT                      = 28
	IN_LOOPBACKNET                        = 127
	IOPAGES                               = 2
	IOPERM_BITMAP_SIZE                    = 8193
	IOV_MAX                               = 1024
	IPCTL_ACCEPTSOURCEROUTE               = 13
	IPCTL_DEFTTL                          = 3
	IPCTL_DIRECTEDBROADCAST               = 9
	IPCTL_FASTFORWARDING                  = 14
	IPCTL_FORWARDING                      = 1
	IPCTL_GIF_TTL                         = 16
	IPCTL_INTRDQDROPS                     = 18
	IPCTL_INTRDQMAXLEN                    = 17
	IPCTL_INTRQDROPS                      = 11
	IPCTL_INTRQMAXLEN                     = 10
	IPCTL_SENDREDIRECTS                   = 2
	IPCTL_SOURCEROUTE                     = 8
	IPCTL_STATS                           = 12
	IPPORT_EPHEMERALFIRST                 = 10000
	IPPORT_EPHEMERALLAST                  = 65535
	IPPORT_HIFIRSTAUTO                    = 49152
	IPPORT_HILASTAUTO                     = 65535
	IPPORT_MAX                            = 65535
	IPPORT_RESERVED                       = 1024
	IPPORT_RESERVEDSTART                  = 600
	IPPROTO_3PC                           = 34
	IPPROTO_ADFS                          = 68
	IPPROTO_AH                            = 51
	IPPROTO_AHIP                          = 61
	IPPROTO_APES                          = 99
	IPPROTO_ARGUS                         = 13
	IPPROTO_AX25                          = 93
	IPPROTO_BHA                           = 49
	IPPROTO_BLT                           = 30
	IPPROTO_BRSATMON                      = 76
	IPPROTO_CARP                          = 112
	IPPROTO_CFTP                          = 62
	IPPROTO_CHAOS                         = 16
	IPPROTO_CMTP                          = 38
	IPPROTO_CPHB                          = 73
	IPPROTO_CPNX                          = 72
	IPPROTO_DCCP                          = 33
	IPPROTO_DDP                           = 37
	IPPROTO_DGP                           = 86
	IPPROTO_DIVERT                        = 258
	IPPROTO_DONE                          = 257
	IPPROTO_DSTOPTS                       = 60
	IPPROTO_EGP                           = 8
	IPPROTO_EMCON                         = 14
	IPPROTO_ENCAP                         = 98
	IPPROTO_EON                           = 80
	IPPROTO_ESP                           = 50
	IPPROTO_ETHERIP                       = 97
	IPPROTO_FRAGMENT                      = 44
	IPPROTO_GGP                           = 3
	IPPROTO_GMTP                          = 100
	IPPROTO_GRE                           = 47
	IPPROTO_HELLO                         = 63
	IPPROTO_HIP                           = 139
	IPPROTO_HMP                           = 20
	IPPROTO_HOPOPTS                       = 0
	IPPROTO_ICMP                          = 1
	IPPROTO_ICMPV6                        = 58
	IPPROTO_IDP                           = 22
	IPPROTO_IDPR                          = 35
	IPPROTO_IDRP                          = 45
	IPPROTO_IGMP                          = 2
	IPPROTO_IGP                           = 85
	IPPROTO_IGRP                          = 88
	IPPROTO_IL                            = 40
	IPPROTO_INLSP                         = 52
	IPPROTO_INP                           = 32
	IPPROTO_IP                            = 0
	IPPROTO_IPCOMP                        = 108
	IPPROTO_IPCV                          = 71
	IPPROTO_IPEIP                         = 94
	IPPROTO_IPIP                          = 4
	IPPROTO_IPPC                          = 67
	IPPROTO_IPV4                          = 4
	IPPROTO_IPV6                          = 41
	IPPROTO_IRTP                          = 28
	IPPROTO_KRYPTOLAN                     = 65
	IPPROTO_LARP                          = 91
	IPPROTO_LEAF1                         = 25
	IPPROTO_LEAF2                         = 26
	IPPROTO_MAX                           = 256
	IPPROTO_MEAS                          = 19
	IPPROTO_MH                            = 135
	IPPROTO_MHRP                          = 48
	IPPROTO_MICP                          = 95
	IPPROTO_MOBILE                        = 55
	IPPROTO_MPLS                          = 137
	IPPROTO_MTP                           = 92
	IPPROTO_MUX                           = 18
	IPPROTO_ND                            = 77
	IPPROTO_NHRP                          = 54
	IPPROTO_NONE                          = 59
	IPPROTO_NSP                           = 31
	IPPROTO_NVPII                         = 11
	IPPROTO_OLD_DIVERT                    = 254
	IPPROTO_OSPFIGP                       = 89
	IPPROTO_PFSYNC                        = 240
	IPPROTO_PGM                           = 113
	IPPROTO_PIGP                          = 9
	IPPROTO_PIM                           = 103
	IPPROTO_PRM                           = 21
	IPPROTO_PUP                           = 12
	IPPROTO_PVP                           = 75
	IPPROTO_RAW                           = 255
	IPPROTO_RCCMON                        = 10
	IPPROTO_RDP                           = 27
	IPPROTO_RESERVED_253                  = 253
	IPPROTO_RESERVED_254                  = 254
	IPPROTO_ROUTING                       = 43
	IPPROTO_RSVP                          = 46
	IPPROTO_RVD                           = 66
	IPPROTO_SATEXPAK                      = 64
	IPPROTO_SATMON                        = 69
	IPPROTO_SCCSP                         = 96
	IPPROTO_SCTP                          = 132
	IPPROTO_SDRP                          = 42
	IPPROTO_SEND                          = 259
	IPPROTO_SHIM6                         = 140
	IPPROTO_SKIP                          = 57
	IPPROTO_SPACER                        = 32767
	IPPROTO_SRPC                          = 90
	IPPROTO_ST                            = 7
	IPPROTO_SVMTP                         = 82
	IPPROTO_SWIPE                         = 53
	IPPROTO_TCF                           = 87
	IPPROTO_TCP                           = 6
	IPPROTO_TLSP                          = 56
	IPPROTO_TP                            = 29
	IPPROTO_TPXX                          = 39
	IPPROTO_TRUNK1                        = 23
	IPPROTO_TRUNK2                        = 24
	IPPROTO_TTP                           = 84
	IPPROTO_UDP                           = 17
	IPPROTO_UDPLITE                       = 136
	IPPROTO_VINES                         = 83
	IPPROTO_VISA                          = 70
	IPPROTO_VMTP                          = 81
	IPPROTO_WBEXPAK                       = 79
	IPPROTO_WBMON                         = 78
	IPPROTO_WSN                           = 74
	IPPROTO_XNET                          = 15
	IPPROTO_XTP                           = 36
	IPV6CTL_ACCEPT_RTADV                  = 12
	IPV6CTL_ADDRCTLPOLICY                 = 38
	IPV6CTL_AUTO_FLOWLABEL                = 17
	IPV6CTL_AUTO_LINKLOCAL                = 35
	IPV6CTL_DAD_COUNT                     = 16
	IPV6CTL_DEFHLIM                       = 3
	IPV6CTL_DEFMCASTHLIM                  = 18
	IPV6CTL_FORWARDING                    = 1
	IPV6CTL_FORWSRCRT                     = 5
	IPV6CTL_GIF_HLIM                      = 19
	IPV6CTL_HDRNESTLIMIT                  = 15
	IPV6CTL_INTRDQMAXLEN                  = 52
	IPV6CTL_INTRQMAXLEN                   = 51
	IPV6CTL_KAME_VERSION                  = 20
	IPV6CTL_LOG_INTERVAL                  = 14
	IPV6CTL_MAXFRAGBUCKETSIZE             = 54
	IPV6CTL_MAXFRAGPACKETS                = 9
	IPV6CTL_MAXFRAGS                      = 41
	IPV6CTL_MAXFRAGSPERPACKET             = 53
	IPV6CTL_MAXID                         = 55
	IPV6CTL_MCAST_PMTU                    = 44
	IPV6CTL_MRTPROTO                      = 8
	IPV6CTL_MRTSTATS                      = 7
	IPV6CTL_NORBIT_RAIF                   = 49
	IPV6CTL_NO_RADR                       = 48
	IPV6CTL_PREFER_TEMPADDR               = 37
	IPV6CTL_RFC6204W3                     = 50
	IPV6CTL_RIP6STATS                     = 36
	IPV6CTL_RR_PRUNE                      = 22
	IPV6CTL_SENDREDIRECTS                 = 2
	IPV6CTL_SOURCECHECK                   = 10
	IPV6CTL_SOURCECHECK_LOGINT            = 11
	IPV6CTL_STATS                         = 6
	IPV6CTL_STEALTH                       = 45
	IPV6CTL_TEMPPLTIME                    = 33
	IPV6CTL_TEMPVLTIME                    = 34
	IPV6CTL_USETEMPADDR                   = 32
	IPV6CTL_USE_DEFAULTZONE               = 39
	IPV6CTL_USE_DEPRECATED                = 21
	IPV6CTL_V6ONLY                        = 24
	IPV6PORT_ANONMAX                      = 65535
	IPV6PORT_ANONMIN                      = 49152
	IPV6PORT_RESERVED                     = 1024
	IPV6PORT_RESERVEDMAX                  = 1023
	IPV6PORT_RESERVEDMIN                  = 600
	IPV6PROTO_MAXID                       = 104
	IPV6_AUTOFLOWLABEL                    = 59
	IPV6_BINDANY                          = 64
	IPV6_BINDMULTI                        = 65
	IPV6_BINDV6ONLY                       = 27
	IPV6_CHECKSUM                         = 26
	IPV6_DEFAULT_MULTICAST_HOPS           = 1
	IPV6_DEFAULT_MULTICAST_LOOP           = 1
	IPV6_DONTFRAG                         = 62
	IPV6_DSTOPTS                          = 50
	IPV6_FLOWID                           = 67
	IPV6_FLOWTYPE                         = 68
	IPV6_FW_ADD                           = 30
	IPV6_FW_DEL                           = 31
	IPV6_FW_FLUSH                         = 32
	IPV6_FW_GET                           = 34
	IPV6_FW_ZERO                          = 33
	IPV6_HOPLIMIT                         = 47
	IPV6_HOPOPTS                          = 49
	IPV6_IPSEC_POLICY                     = 28
	IPV6_JOIN_GROUP                       = 12
	IPV6_LEAVE_GROUP                      = 13
	IPV6_MAX_GROUP_SRC_FILTER             = 512
	IPV6_MAX_MEMBERSHIPS                  = 4095
	IPV6_MAX_SOCK_SRC_FILTER              = 128
	IPV6_MSFILTER                         = 74
	IPV6_MULTICAST_HOPS                   = 10
	IPV6_MULTICAST_IF                     = 9
	IPV6_MULTICAST_LOOP                   = 11
	IPV6_NEXTHOP                          = 48
	IPV6_ORIGDSTADDR                      = 72
	IPV6_PATHMTU                          = 44
	IPV6_PKTINFO                          = 46
	IPV6_PORTRANGE                        = 14
	IPV6_PORTRANGE_DEFAULT                = 0
	IPV6_PORTRANGE_HIGH                   = 1
	IPV6_PORTRANGE_LOW                    = 2
	IPV6_PREFER_TEMPADDR                  = 63
	IPV6_RECVDSTOPTS                      = 40
	IPV6_RECVFLOWID                       = 70
	IPV6_RECVHOPLIMIT                     = 37
	IPV6_RECVHOPOPTS                      = 39
	IPV6_RECVORIGDSTADDR                  = 72
	IPV6_RECVPATHMTU                      = 43
	IPV6_RECVPKTINFO                      = 36
	IPV6_RECVRSSBUCKETID                  = 71
	IPV6_RECVRTHDR                        = 38
	IPV6_RECVTCLASS                       = 57
	IPV6_RSSBUCKETID                      = 69
	IPV6_RSS_LISTEN_BUCKET                = 66
	IPV6_RTHDR                            = 51
	IPV6_RTHDRDSTOPTS                     = 35
	IPV6_RTHDR_LOOSE                      = 0
	IPV6_RTHDR_STRICT                     = 1
	IPV6_RTHDR_TYPE_0                     = 0
	IPV6_SOCKOPT_RESERVED1                = 3
	IPV6_TCLASS                           = 61
	IPV6_UNICAST_HOPS                     = 4
	IPV6_USE_MIN_MTU                      = 42
	IPV6_V6ONLY                           = 27
	IPV6_VLAN_PCP                         = 75
	IP_ADD_MEMBERSHIP                     = 12
	IP_ADD_SOURCE_MEMBERSHIP              = 70
	IP_BINDANY                            = 24
	IP_BINDMULTI                          = 25
	IP_BLOCK_SOURCE                       = 72
	IP_DEFAULT_MULTICAST_LOOP             = 1
	IP_DEFAULT_MULTICAST_TTL              = 1
	IP_DONTFRAG                           = 67
	IP_DROP_MEMBERSHIP                    = 13
	IP_DROP_SOURCE_MEMBERSHIP             = 71
	IP_DUMMYNET3                          = 49
	IP_DUMMYNET_CONFIGURE                 = 60
	IP_DUMMYNET_DEL                       = 61
	IP_DUMMYNET_FLUSH                     = 62
	IP_DUMMYNET_GET                       = 64
	IP_FLOWID                             = 90
	IP_FLOWTYPE                           = 91
	IP_FW3                                = 48
	IP_FW_ADD                             = 50
	IP_FW_DEL                             = 51
	IP_FW_FLUSH                           = 52
	IP_FW_GET                             = 54
	IP_FW_NAT_CFG                         = 56
	IP_FW_NAT_DEL                         = 57
	IP_FW_NAT_GET_CONFIG                  = 58
	IP_FW_NAT_GET_LOG                     = 59
	IP_FW_RESETLOG                        = 55
	IP_FW_TABLE_ADD                       = 40
	IP_FW_TABLE_DEL                       = 41
	IP_FW_TABLE_FLUSH                     = 42
	IP_FW_TABLE_GETSIZE                   = 43
	IP_FW_TABLE_LIST                      = 44
	IP_FW_ZERO                            = 53
	IP_HDRINCL                            = 2
	IP_IPSEC_POLICY                       = 21
	IP_MAX_GROUP_SRC_FILTER               = 512
	IP_MAX_MEMBERSHIPS                    = 4095
	IP_MAX_SOCK_MUTE_FILTER               = 128
	IP_MAX_SOCK_SRC_FILTER                = 128
	IP_MINTTL                             = 66
	IP_MSFILTER                           = 74
	IP_MULTICAST_IF                       = 9
	IP_MULTICAST_LOOP                     = 11
	IP_MULTICAST_TTL                      = 10
	IP_MULTICAST_VIF                      = 14
	IP_ONESBCAST                          = 23
	IP_OPTIONS                            = 1
	IP_ORIGDSTADDR                        = 27
	IP_PORTRANGE                          = 19
	IP_PORTRANGE_DEFAULT                  = 0
	IP_PORTRANGE_HIGH                     = 1
	IP_PORTRANGE_LOW                      = 2
	IP_RECVDSTADDR                        = 7
	IP_RECVFLOWID                         = 93
	IP_RECVIF                             = 20
	IP_RECVOPTS                           = 5
	IP_RECVORIGDSTADDR                    = 27
	IP_RECVRETOPTS                        = 6
	IP_RECVRSSBUCKETID                    = 94
	IP_RECVTOS                            = 68
	IP_RECVTTL                            = 65
	IP_RETOPTS                            = 8
	IP_RSSBUCKETID                        = 92
	IP_RSS_LISTEN_BUCKET                  = 26
	IP_RSVP_OFF                           = 16
	IP_RSVP_ON                            = 15
	IP_RSVP_VIF_OFF                       = 18
	IP_RSVP_VIF_ON                        = 17
	IP_SENDSRCADDR                        = 7
	IP_TOS                                = 3
	IP_TTL                                = 4
	IP_UNBLOCK_SOURCE                     = 73
	IP_VLAN_PCP                           = 75
	ITIMER_PROF                           = 2
	ITIMER_REAL                           = 0
	ITIMER_VIRTUAL                        = 1
	KSTACK_GUARD_PAGES                    = 1
	KSTACK_PAGES                          = 4
	LC_ALL                                = 0
	LC_ALL_MASK                           = 63
	LC_COLLATE                            = 1
	LC_COLLATE_MASK                       = 1
	LC_CTYPE                              = 2
	LC_CTYPE_MASK                         = 2
	LC_MESSAGES                           = 6
	LC_MESSAGES_MASK                      = 32
	LC_MONETARY                           = 3
	LC_MONETARY_MASK                      = 4
	LC_NUMERIC                            = 4
	LC_NUMERIC_MASK                       = 8
	LC_TIME                               = 5
	LC_TIME_MASK                          = 16
	LC_VERSION_MASK                       = 64
	LDBL_DECIMAL_DIG                      = 21
	LDBL_DIG                              = 18
	LDBL_EPSILON                          = 1.0842021724855044340e-19
	LDBL_HAS_SUBNORM                      = 1
	LDBL_MANT_DIG                         = 64
	LDBL_MAX                              = 0
	LDBL_MAX_10_EXP                       = 4932
	LDBL_MAX_EXP                          = 16384
	LDBL_MIN                              = 3.3621031431120935063e-4932
	LDBL_MIN_10_EXP                       = -4931
	LDBL_MIN_EXP                          = -16381
	LDBL_TRUE_MIN                         = 3.6451995318824746025e-4951
	LINE_MAX                              = 2048
	LITTLE_ENDIAN                         = 1234
	LLONG_MAX                             = 9223372036854775807
	LLONG_MIN                             = -9223372036854775808
	LOCK_EX                               = 0x02
	LOCK_NB                               = 0x04
	LOCK_SH                               = 0x01
	LOCK_UN                               = 0x08
	LONG_BIT                              = 64
	LONG_MAX                              = 9223372036854775807
	LONG_MIN                              = -9223372036854775808
	LTM_PRIME_2MSB_ON                     = 8
	LTM_PRIME_BBS                         = 1
	LTM_PRIME_SAFE                        = 2
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	MACHINE                               = "amd64"
	MACHINE_ARCH                          = "amd64"
	MACHINE_ARCH32                        = "i386"
	MATH_ERREXCEPT                        = 2
	MATH_ERRNO                            = 1
	MAXBCACHEBUF                          = 65536
	MAXBSIZE                              = 65536
	MAXCOMLEN                             = 19
	MAXCPU                                = 1
	MAXDUMPPGS                            = 16
	MAXHOSTNAMELEN                        = 256
	MAXINTERP                             = 1024
	MAXLOGNAME                            = 33
	MAXMEMDOM                             = 8
	MAXNAMLEN                             = 255
	MAXPAGESIZES                          = 3
	MAXPATHLEN                            = 1024
	MAXPHYS                               = 1048576
	MAXSYMLINKS                           = 32
	MAXUPRC                               = 40
	MAX_CANON                             = 255
	MAX_INPUT                             = 255
	MAX_NESTING_DEPTH                     = 1000
	MB_LEN_MAX                            = 6
	MCAST_BLOCK_SOURCE                    = 84
	MCAST_EXCLUDE                         = 2
	MCAST_INCLUDE                         = 1
	MCAST_JOIN_GROUP                      = 80
	MCAST_JOIN_SOURCE_GROUP               = 82
	MCAST_LEAVE_GROUP                     = 81
	MCAST_LEAVE_SOURCE_GROUP              = 83
	MCAST_UNBLOCK_SOURCE                  = 85
	MCAST_UNDEFINED                       = 0
	MCLBYTES                              = 2048
	MCLSHIFT                              = 11
	MINSIGSTKSZ                           = 2048
	MJUM16BYTES                           = 16384
	MJUM9BYTES                            = 9216
	MJUMPAGESIZE                          = 4096
	MP_28BIT                              = 0
	MP_BIG_ENDIAN                         = 1
	MP_BUF                                = -5
	MP_DIGIT_BIT                          = 28
	MP_EQ                                 = 0
	MP_ERR                                = -1
	MP_GT                                 = 1
	MP_ITER                               = -4
	MP_LITTLE_ENDIAN                      = -1
	MP_LSB_FIRST                          = -1
	MP_LT                                 = -1
	MP_MEM                                = -2
	MP_MSB_FIRST                          = 1
	MP_NATIVE_ENDIAN                      = 0
	MP_NEG                                = 1
	MP_NO                                 = 0
	MP_OKAY                               = 0
	MP_PRIME_2MSB_ON                      = 0x0008
	MP_PRIME_BBS                          = 0x0001
	MP_PRIME_SAFE                         = 0x0002
	MP_RANGE                              = -3
	MP_VAL                                = -3
	MP_WORD_DECLARED                      = 0
	MP_YES                                = 1
	MP_ZPOS                               = 0
	MQ_PRIO_MAX                           = 64
	MSG_CMSG_CLOEXEC                      = 0x00040000
	MSG_COMPAT                            = 0x00008000
	MSG_CTRUNC                            = 0x00000020
	MSG_DONTROUTE                         = 0x00000004
	MSG_DONTWAIT                          = 0x00000080
	MSG_EOF                               = 0x00000100
	MSG_EOR                               = 0x00000008
	MSG_NBIO                              = 0x00004000
	MSG_NOSIGNAL                          = 0x00020000
	MSG_NOTIFICATION                      = 0x00002000
	MSG_OOB                               = 0x00000001
	MSG_PEEK                              = 0x00000002
	MSG_TRUNC                             = 0x00000010
	MSG_WAITALL                           = 0x00000040
	MSG_WAITFORONE                        = 0x00080000
	MSIZE                                 = 256
	M_1_PI                                = 0.31830988618379067154
	M_2_PI                                = 0.63661977236758134308
	M_2_SQRTPI                            = 1.12837916709551257390
	M_E                                   = 2.7182818284590452354
	M_LN10                                = 2.30258509299404568402
	M_LN2                                 = 0.69314718055994530942
	M_LOG10E                              = 0.43429448190325182765
	M_LOG2E                               = 1.4426950408889634074
	M_PI                                  = 3.14159265358979323846
	M_PI_2                                = 1.57079632679489661923
	M_PI_4                                = 0.78539816339744830962
	M_SQRT1_2                             = 0.70710678118654752440
	M_SQRT2                               = 1.41421356237309504880
	NAME_MAX                              = 255
	NBBY                                  = 8
	NBPDP                                 = 1073741824
	NBPDR                                 = 2097152
	NBPML4                                = 549755813888
	NBPML5                                = 281474976710656
	NCARGS                                = 524288
	NETDB_INTERNAL                        = -1
	NETDB_SUCCESS                         = 0
	NET_RT_DUMP                           = 1
	NET_RT_FLAGS                          = 2
	NET_RT_IFLIST                         = 3
	NET_RT_IFLISTL                        = 5
	NET_RT_IFMALIST                       = 4
	NET_RT_NHGRP                          = 7
	NET_RT_NHOP                           = 6
	NGROUPS                               = 1024
	NGROUPS_MAX                           = 1023
	NI_DGRAM                              = 0x00000010
	NI_MAXHOST                            = 1025
	NI_MAXSERV                            = 32
	NI_NAMEREQD                           = 0x00000004
	NI_NOFQDN                             = 0x00000001
	NI_NUMERICHOST                        = 0x00000002
	NI_NUMERICSCOPE                       = 0x00000020
	NI_NUMERICSERV                        = 0x00000008
	NL_ARGMAX                             = 4096
	NL_LANGMAX                            = 31
	NL_MSGMAX                             = 32767
	NL_NMAX                               = 1
	NL_SETMAX                             = 255
	NL_TEXTMAX                            = 2048
	NOFILE                                = 64
	NOGROUP                               = 65535
	NO_ADDRESS                            = 4
	NO_DATA                               = 4
	NO_RECOVERY                           = 3
	NPDEPGSHIFT                           = 9
	NPDPEPGSHIFT                          = 9
	NPML4EPGSHIFT                         = 9
	NPML5EPGSHIFT                         = 9
	NPTEPGSHIFT                           = 9
	NRE_ENABLE_ASSERTS                    = 0
	NRE_USE_SMALL_ALLOC                   = 1
	NSIG                                  = 32
	NS_DEAD                               = 0x02
	NS_DYING                              = 0x01
	NS_KILLED                             = 0x04
	NS_SUPPRESS_COMPILATION               = 0x08
	NZERO                                 = 0
	OFF_MAX                               = 9223372036854775807
	OFF_MIN                               = -9223372036854775808
	OPEN_MAX                              = 64
	O_ACCMODE                             = 0x0003
	O_APPEND                              = 0x0008
	O_ASYNC                               = 0x0040
	O_CLOEXEC                             = 0x00100000
	O_CREAT                               = 0x0200
	O_DIRECT                              = 0x00010000
	O_DIRECTORY                           = 0x00020000
	O_DSYNC                               = 0x01000000
	O_EXCL                                = 0x0800
	O_EXEC                                = 0x00040000
	O_EXLOCK                              = 0x0020
	O_FSYNC                               = 0x0080
	O_NDELAY                              = 4
	O_NOCTTY                              = 0x8000
	O_NOFOLLOW                            = 0x0100
	O_NONBLOCK                            = 0x0004
	O_RDONLY                              = 0x0000
	O_RDWR                                = 0x0002
	O_RESOLVE_BENEATH                     = 0x00800000
	O_SEARCH                              = 262144
	O_SHLOCK                              = 0x0010
	O_SYNC                                = 0x0080
	O_TRUNC                               = 0x0400
	O_TTY_INIT                            = 0x00080000
	O_VERIFY                              = 0x00200000
	O_WRONLY                              = 0x0001
	PAGE_MASK                             = 4095
	PAGE_SHIFT                            = 12
	PAGE_SIZE                             = 4096
	PASS_MAX                              = 128
	PATH_MAX                              = 1024
	PCATCH                                = 0x100
	PDPMASK                               = 1073741823
	PDPSHIFT                              = 30
	PDP_ENDIAN                            = 3412
	PDRMASK                               = 2097151
	PDROP                                 = 0x200
	PDRSHIFT                              = 21
	PF_APPLETALK                          = 16
	PF_ARP                                = 35
	PF_ATM                                = 30
	PF_BLUETOOTH                          = 36
	PF_CCITT                              = 10
	PF_CHAOS                              = 5
	PF_CNT                                = 21
	PF_COIP                               = 20
	PF_DATAKIT                            = 9
	PF_DECnet                             = 12
	PF_DLI                                = 13
	PF_ECMA                               = 8
	PF_HYLINK                             = 15
	PF_IEEE80211                          = 37
	PF_IMPLINK                            = 3
	PF_INET                               = 2
	PF_INET6                              = 28
	PF_INET6_SDP                          = 42
	PF_INET_SDP                           = 40
	PF_IPX                                = 23
	PF_ISDN                               = 26
	PF_ISO                                = 7
	PF_KEY                                = 27
	PF_LAT                                = 14
	PF_LINK                               = 18
	PF_LOCAL                              = 1
	PF_MAX                                = 43
	PF_NATM                               = 29
	PF_NETBIOS                            = 6
	PF_NETGRAPH                           = 32
	PF_OSI                                = 7
	PF_PIP                                = 25
	PF_PUP                                = 4
	PF_ROUTE                              = 17
	PF_RTIP                               = 22
	PF_SCLUSTER                           = 34
	PF_SIP                                = 24
	PF_SLOW                               = 33
	PF_SNA                                = 11
	PF_UNIX                               = 1
	PF_UNSPEC                             = 0
	PF_XTP                                = 19
	PIPE_BUF                              = 512
	PML4MASK                              = 549755813887
	PML4SHIFT                             = 39
	PML5MASK                              = 281474976710655
	PML5SHIFT                             = 48
	POLL_ERR                              = 4
	POLL_HUP                              = 6
	POLL_IN                               = 1
	POLL_MSG                              = 3
	POLL_OUT                              = 2
	POLL_PRI                              = 5
	POSIX_FADV_DONTNEED                   = 4
	POSIX_FADV_NOREUSE                    = 5
	POSIX_FADV_NORMAL                     = 0
	POSIX_FADV_RANDOM                     = 1
	POSIX_FADV_SEQUENTIAL                 = 2
	POSIX_FADV_WILLNEED                   = 3
	PRIMASK                               = 0x0ff
	PRIME_SIZE                            = 256
	PRIVATE_MP_PRIME_TAB_SIZE             = 256
	PRIX16                                = "X"
	PRIX32                                = "X"
	PRIX8                                 = "X"
	PRIXFAST16                            = "X"
	PRIXFAST32                            = "X"
	PRIXFAST8                             = "X"
	PRIXLEAST16                           = "X"
	PRIXLEAST32                           = "X"
	PRIXLEAST8                            = "X"
	PRIXMAX                               = "jX"
	PRId16                                = "d"
	PRId32                                = "d"
	PRId8                                 = "d"
	PRIdFAST16                            = "d"
	PRIdFAST32                            = "d"
	PRIdFAST8                             = "d"
	PRIdLEAST16                           = "d"
	PRIdLEAST32                           = "d"
	PRIdLEAST8                            = "d"
	PRIdMAX                               = "jd"
	PRIi16                                = "i"
	PRIi32                                = "i"
	PRIi8                                 = "i"
	PRIiFAST16                            = "i"
	PRIiFAST32                            = "i"
	PRIiFAST8                             = "i"
	PRIiLEAST16                           = "i"
	PRIiLEAST32                           = "i"
	PRIiLEAST8                            = "i"
	PRIiMAX                               = "ji"
	PRIo16                                = "o"
	PRIo32                                = "o"
	PRIo8                                 = "o"
	PRIoFAST16                            = "o"
	PRIoFAST32                            = "o"
	PRIoFAST8                             = "o"
	PRIoLEAST16                           = "o"
	PRIoLEAST32                           = "o"
	PRIoLEAST8                            = "o"
	PRIoMAX                               = "jo"
	PRIu16                                = "u"
	PRIu32                                = "u"
	PRIu8                                 = "u"
	PRIuFAST16                            = "u"
	PRIuFAST32                            = "u"
	PRIuFAST8                             = "u"
	PRIuLEAST16                           = "u"
	PRIuLEAST32                           = "u"
	PRIuLEAST8                            = "u"
	PRIuMAX                               = "ju"
	PRIx16                                = "x"
	PRIx32                                = "x"
	PRIx8                                 = "x"
	PRIxFAST16                            = "x"
	PRIxFAST32                            = "x"
	PRIxFAST8                             = "x"
	PRIxLEAST16                           = "x"
	PRIxLEAST32                           = "x"
	PRIxLEAST8                            = "x"
	PRIxMAX                               = "jx"
	PRU_FLUSH_RD                          = 0
	PRU_FLUSH_RDWR                        = 2
	PRU_FLUSH_WR                          = 1
	PTRDIFF_MAX                           = 9223372036854775807
	PTRDIFF_MIN                           = -9223372036854775808
	QUAD_MAX                              = 9223372036854775807
	QUAD_MIN                              = -9223372036854775808
	RAND_MAX                              = 0x7fffffff
	RAND_SEED_INITIALIZED                 = 0x40
	REG_ADVANCED                          = 000003
	REG_ADVF                              = 000002
	REG_ASSERT                            = 15
	REG_ATOI                              = 101
	REG_BADBR                             = 10
	REG_BADOPT                            = 18
	REG_BADPAT                            = 2
	REG_BADRPT                            = 13
	REG_BASIC                             = 000000
	REG_BOSONLY                           = 002000
	REG_DUMP                              = 004000
	REG_EBRACE                            = 9
	REG_EBRACK                            = 7
	REG_ECOLLATE                          = 3
	REG_ECOLORS                           = 20
	REG_ECTYPE                            = 4
	REG_EESCAPE                           = 5
	REG_EPAREN                            = 8
	REG_ERANGE                            = 11
	REG_ESPACE                            = 12
	REG_ESUBREG                           = 6
	REG_ETOOBIG                           = 19
	REG_EXPANDED                          = 000040
	REG_EXPECT                            = 001000
	REG_EXTENDED                          = 000001
	REG_FAKE                              = 010000
	REG_FTRACE                            = 0010
	REG_ICASE                             = 000010
	REG_INVARG                            = 16
	REG_ITOA                              = 102
	REG_MIXED                             = 17
	REG_MTRACE                            = 0020
	REG_NEWLINE                           = 000300
	REG_NLANCH                            = 000200
	REG_NLSTOP                            = 000100
	REG_NOMATCH                           = 1
	REG_NOSPEC                            = 4
	REG_NOSUB                             = 000020
	REG_NOTBOL                            = 0001
	REG_NOTEOL                            = 0002
	REG_OKAY                              = 0
	REG_PEND                              = 000400
	REG_PROGRESS                          = 020000
	REG_QUOTE                             = 000004
	REG_SMALL                             = 0040
	REG_STARTEND                          = 0004
	REG_UBACKREF                          = 000001
	REG_UBBS                              = 000100
	REG_UBOUNDS                           = 000004
	REG_UBRACES                           = 000010
	REG_UBSALNUM                          = 000020
	REG_UEMPTYMATCH                       = 004000
	REG_UIMPOSSIBLE                       = 010000
	REG_ULOCALE                           = 002000
	REG_ULOOKAHEAD                        = 000002
	REG_UNONPOSIX                         = 000200
	REG_UPBOTCH                           = 000040
	REG_USHORTEST                         = 020000
	REG_UUNPORT                           = 001000
	REG_UUNSPEC                           = 000400
	RESOLVER_KEY                          = "testInterpResolver"
	RE_DUP_MAX                            = 255
	RFCENVG                               = 2048
	RFCFDG                                = 4096
	RFCNAMEG                              = 1024
	RFENVG                                = 2
	RFFDG                                 = 4
	RFFLAGS                               = 2416930932
	RFHIGHPID                             = 262144
	RFKERNELONLY                          = 268828672
	RFLINUXTHPN                           = 65536
	RFMEM                                 = 32
	RFNAMEG                               = 1
	RFNOTEG                               = 8
	RFNOWAIT                              = 64
	RFPPWAIT                              = 2147483648
	RFPROC                                = 16
	RFPROCDESC                            = 268435456
	RFSIGSHARE                            = 16384
	RFSPAWN                               = 2147483648
	RFSTOPPED                             = 131072
	RFTHREAD                              = 8192
	RFTSIGMASK                            = 0xFF
	RFTSIGSHIFT                           = 20
	RFTSIGZMB                             = 524288
	RSIZE_MAX                             = 9223372036854775807
	R_OK                                  = 0x04
	SAFE_INTERP                           = 0x80
	SA_NOCLDSTOP                          = 0x0008
	SA_NOCLDWAIT                          = 0x0020
	SA_NODEFER                            = 0x0010
	SA_ONSTACK                            = 0x0001
	SA_RESETHAND                          = 0x0004
	SA_RESTART                            = 0x0002
	SA_SIGINFO                            = 0x0040
	SBT_MAX                               = 0x7fffffffffffffff
	SCHAR_MAX                             = 127
	SCHAR_MIN                             = -128
	SCM_BINTIME                           = 0x04
	SCM_CREDS                             = 0x03
	SCM_CREDS2                            = 0x08
	SCM_MONOTONIC                         = 0x06
	SCM_REALTIME                          = 0x05
	SCM_RIGHTS                            = 0x01
	SCM_TIMESTAMP                         = 0x02
	SCM_TIME_INFO                         = 0x07
	SCNd16                                = "hd"
	SCNd32                                = "d"
	SCNd8                                 = "hhd"
	SCNdFAST16                            = "d"
	SCNdFAST32                            = "d"
	SCNdFAST8                             = "d"
	SCNdLEAST16                           = "hd"
	SCNdLEAST32                           = "d"
	SCNdLEAST8                            = "hhd"
	SCNdMAX                               = "jd"
	SCNi16                                = "hi"
	SCNi32                                = "i"
	SCNi8                                 = "hhi"
	SCNiFAST16                            = "i"
	SCNiFAST32                            = "i"
	SCNiFAST8                             = "i"
	SCNiLEAST16                           = "hi"
	SCNiLEAST32                           = "i"
	SCNiLEAST8                            = "hhi"
	SCNiMAX                               = "ji"
	SCNo16                                = "ho"
	SCNo32                                = "o"
	SCNo8                                 = "hho"
	SCNoFAST16                            = "o"
	SCNoFAST32                            = "o"
	SCNoFAST8                             = "o"
	SCNoLEAST16                           = "ho"
	SCNoLEAST32                           = "o"
	SCNoLEAST8                            = "hho"
	SCNoMAX                               = "jo"
	SCNu16                                = "hu"
	SCNu32                                = "u"
	SCNu8                                 = "hhu"
	SCNuFAST16                            = "u"
	SCNuFAST32                            = "u"
	SCNuFAST8                             = "u"
	SCNuLEAST16                           = "hu"
	SCNuLEAST32                           = "u"
	SCNuLEAST8                            = "hhu"
	SCNuMAX                               = "ju"
	SCNx16                                = "hx"
	SCNx32                                = "x"
	SCNx8                                 = "hhx"
	SCNxFAST16                            = "x"
	SCNxFAST32                            = "x"
	SCNxFAST8                             = "x"
	SCNxLEAST16                           = "hx"
	SCNxLEAST32                           = "x"
	SCNxLEAST8                            = "hhx"
	SCNxMAX                               = "jx"
	SCOPE_DELIMITER                       = 37
	SEEK_DATA                             = 3
	SEEK_HOLE                             = 4
	SEGV_ACCERR                           = 2
	SEGV_MAPERR                           = 1
	SEGV_PKUERR                           = 100
	SF_APPEND                             = 0x00040000
	SF_ARCHIVED                           = 0x00010000
	SF_IMMUTABLE                          = 0x00020000
	SF_MNOWAIT                            = 0x00000002
	SF_NOCACHE                            = 0x00000010
	SF_NODISKIO                           = 0x00000001
	SF_NOUNLINK                           = 0x00100000
	SF_SETTABLE                           = 0xffff0000
	SF_SNAPSHOT                           = 0x00200000
	SF_SYNC                               = 0x00000004
	SF_USER_READAHEAD                     = 0x00000008
	SHRT_MAX                              = 32767
	SHRT_MIN                              = -32768
	SHUT_RD                               = 0
	SHUT_RDWR                             = 2
	SHUT_WR                               = 1
	SIGABRT                               = 6
	SIGALRM                               = 14
	SIGBUS                                = 10
	SIGCHLD                               = 20
	SIGCONT                               = 19
	SIGEMT                                = 7
	SIGEV_KEVENT                          = 3
	SIGEV_NONE                            = 0
	SIGEV_SIGNAL                          = 1
	SIGEV_THREAD                          = 2
	SIGEV_THREAD_ID                       = 4
	SIGFPE                                = 8
	SIGHUP                                = 1
	SIGILL                                = 4
	SIGINFO                               = 29
	SIGINT                                = 2
	SIGIO                                 = 23
	SIGIOT                                = 6
	SIGKILL                               = 9
	SIGLIBRT                              = 33
	SIGLWP                                = 32
	SIGPIPE                               = 13
	SIGPROF                               = 27
	SIGQUIT                               = 3
	SIGRTMAX                              = 126
	SIGRTMIN                              = 65
	SIGSEGV                               = 11
	SIGSTKSZ                              = 34816
	SIGSTOP                               = 17
	SIGSYS                                = 12
	SIGTERM                               = 15
	SIGTHR                                = 32
	SIGTRAP                               = 5
	SIGTSTP                               = 18
	SIGTTIN                               = 21
	SIGTTOU                               = 22
	SIGURG                                = 16
	SIGUSR1                               = 30
	SIGUSR2                               = 31
	SIGVTALRM                             = 26
	SIGWINCH                              = 28
	SIGXCPU                               = 24
	SIGXFSZ                               = 25
	SIG_ATOMIC_MAX                        = 9223372036854775807
	SIG_ATOMIC_MIN                        = -9223372036854775808
	SIG_BLOCK                             = 1
	SIG_SETMASK                           = 3
	SIG_UNBLOCK                           = 2
	SIN6_LEN                              = 0
	SIZE_MAX                              = 18446744073709551615
	SIZE_T_MAX                            = 18446744073709551615
	SI_ASYNCIO                            = 0x10004
	SI_KERNEL                             = 0x10006
	SI_LWP                                = 0x10007
	SI_MESGQ                              = 0x10005
	SI_NOINFO                             = 0
	SI_QUEUE                              = 0x10002
	SI_TIMER                              = 0x10003
	SI_UNDEFINED                          = 0
	SI_USER                               = 0x10001
	SOCK_CLOEXEC                          = 0x10000000
	SOCK_DGRAM                            = 2
	SOCK_MAXADDRLEN                       = 255
	SOCK_NONBLOCK                         = 0x20000000
	SOCK_RAW                              = 3
	SOCK_RDM                              = 4
	SOCK_SEQPACKET                        = 5
	SOCK_STREAM                           = 1
	SOL_SOCKET                            = 0xffff
	SOMAXCONN                             = 128
	SO_ACCEPTCONN                         = 0x00000002
	SO_ACCEPTFILTER                       = 0x00001000
	SO_BINTIME                            = 0x00002000
	SO_BROADCAST                          = 0x00000020
	SO_DEBUG                              = 0x00000001
	SO_DOMAIN                             = 0x1019
	SO_DONTROUTE                          = 0x00000010
	SO_ERROR                              = 0x1007
	SO_KEEPALIVE                          = 0x00000008
	SO_LABEL                              = 0x1009
	SO_LINGER                             = 0x00000080
	SO_LISTENINCQLEN                      = 0x1013
	SO_LISTENQLEN                         = 0x1012
	SO_LISTENQLIMIT                       = 0x1011
	SO_MAX_PACING_RATE                    = 0x1018
	SO_NOSIGPIPE                          = 0x00000800
	SO_NO_DDP                             = 0x00008000
	SO_NO_OFFLOAD                         = 0x00004000
	SO_OOBINLINE                          = 0x00000100
	SO_PEERLABEL                          = 0x1010
	SO_PROTOCOL                           = 0x1016
	SO_PROTOTYPE                          = 4118
	SO_RCVBUF                             = 0x1002
	SO_RCVLOWAT                           = 0x1004
	SO_RCVTIMEO                           = 0x1006
	SO_REUSEADDR                          = 0x00000004
	SO_REUSEPORT                          = 0x00000200
	SO_REUSEPORT_LB                       = 0x00010000
	SO_SETFIB                             = 0x1014
	SO_SNDBUF                             = 0x1001
	SO_SNDLOWAT                           = 0x1003
	SO_SNDTIMEO                           = 0x1005
	SO_TIMESTAMP                          = 0x00000400
	SO_TS_BINTIME                         = 1
	SO_TS_CLOCK                           = 0x1017
	SO_TS_CLOCK_MAX                       = 3
	SO_TS_DEFAULT                         = 0
	SO_TS_MONOTONIC                       = 3
	SO_TS_REALTIME                        = 2
	SO_TS_REALTIME_MICRO                  = 0
	SO_TYPE                               = 0x1008
	SO_USELOOPBACK                        = 0x00000040
	SO_USER_COOKIE                        = 0x1015
	SO_VENDOR                             = 0x80000000
	SPECNAMELEN                           = 255
	SSIZE_MAX                             = 9223372036854775807
	SS_DISABLE                            = 0x0004
	SS_ONSTACK                            = 0x0001
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	ST_INFO_HW                            = 0x0001
	ST_INFO_HW_HPREC                      = 0x0002
	SV_INTERRUPT                          = 2
	SV_NOCLDSTOP                          = 8
	SV_NODEFER                            = 16
	SV_ONSTACK                            = 1
	SV_RESETHAND                          = 4
	SV_SIGINFO                            = 64
	SYNTHETIC_EVENT_TIME                  = 0
	SYS_NMLN                              = 256
	S_BLKSIZE                             = 512
	S_IEXEC                               = 64
	S_IFBLK                               = 0060000
	S_IFCHR                               = 0020000
	S_IFDIR                               = 0040000
	S_IFIFO                               = 0010000
	S_IFLNK                               = 0120000
	S_IFMT                                = 0170000
	S_IFREG                               = 0100000
	S_IFSOCK                              = 0140000
	S_IFWHT                               = 0160000
	S_IREAD                               = 256
	S_IRGRP                               = 0000040
	S_IROTH                               = 0000004
	S_IRUSR                               = 0000400
	S_IRWXG                               = 0000070
	S_IRWXO                               = 0000007
	S_IRWXU                               = 0000700
	S_ISGID                               = 0002000
	S_ISTXT                               = 0001000
	S_ISUID                               = 0004000
	S_ISVTX                               = 0001000
	S_IWGRP                               = 0000020
	S_IWOTH                               = 0000002
	S_IWRITE                              = 128
	S_IWUSR                               = 0000200
	S_IXGRP                               = 0000010
	S_IXOTH                               = 0000001
	S_IXUSR                               = 0000100
	TCLFLEXARRAY                          = 0
	TCLOO_H_INCLUDED                      = 0
	TCLOO_VERSION                         = "1.1.0"
	TCLTOMMATH_EPOCH                      = 0
	TCLTOMMATH_REVISION                   = 0
	TCL_ALLOW_EXCEPTIONS                  = 0x04
	TCL_AVOID_RESOLVERS                   = 0x40000
	TCL_CREATE_NS_IF_UNKNOWN              = 0x800
	TCL_DD_CONVERSION_TYPE_MASK           = 0x3
	TCL_DD_E_FORMAT                       = 0x2
	TCL_DD_F_FORMAT                       = 0x3
	TCL_DD_NO_QUICK                       = 0x8
	TCL_DD_SHORTEN_FLAG                   = 0x4
	TCL_DD_SHORTEST                       = 0x4
	TCL_DD_SHORTEST0                      = 0x0
	TCL_DD_STEELE                         = 0x5
	TCL_DD_STEELE0                        = 0x1
	TCL_EACH_COLLECT                      = 1
	TCL_EACH_KEEP_NONE                    = 0
	TCL_EVAL_DISCARD_RESULT               = 0x40
	TCL_EVAL_FILE                         = 0x02
	TCL_EVAL_NORESOLVE                    = 0x20
	TCL_EVAL_SOURCE_IN_FRAME              = 0x10
	TCL_FIND_ONLY_NS                      = 0x1000
	TCL_GLOBMODE_DIR                      = 4
	TCL_GLOBMODE_JOIN                     = 2
	TCL_GLOBMODE_NO_COMPLAIN              = 1
	TCL_GLOBMODE_TAILS                    = 8
	TCL_INDEX_AFTER                       = 2147483647
	TCL_INDEX_BEFORE                      = -1
	TCL_INDEX_END                         = -2
	TCL_INDEX_START                       = 0
	TCL_INVOKE_HIDDEN                     = 1
	TCL_INVOKE_NO_TRACEBACK               = 4
	TCL_INVOKE_NO_UNKNOWN                 = 2
	TCL_LOCATION_BC                       = 2
	TCL_LOCATION_EVAL                     = 0
	TCL_LOCATION_LAST                     = 6
	TCL_LOCATION_PREBC                    = 3
	TCL_LOCATION_PROC                     = 5
	TCL_LOCATION_SOURCE                   = 4
	TCL_MIN_GROWTH                        = 1024
	TCL_NUMBER_BIG                        = 3
	TCL_NUMBER_DOUBLE                     = 4
	TCL_NUMBER_LONG                       = 1
	TCL_NUMBER_NAN                        = 5
	TCL_NUMBER_WIDE                       = 2
	TCL_OO_METADATA_VERSION_CURRENT       = 1
	TCL_OO_METHOD_VERSION_CURRENT         = 1
	TCL_OUT_LINE_COMPILE                  = 1
	TCL_PARSE_BINARY_ONLY                 = 64
	TCL_PARSE_DECIMAL_ONLY                = 1
	TCL_PARSE_HEXADECIMAL_ONLY            = 4
	TCL_PARSE_INTEGER_ONLY                = 8
	TCL_PARSE_NO_WHITESPACE               = 32
	TCL_PARSE_OCTAL_ONLY                  = 2
	TCL_PARSE_SCAN_PREFIXES               = 16
	TCL_REG_BOSONLY                       = 002000
	TCL_TRACE_ENTER_EXEC                  = 1
	TCL_TRACE_LEAVE_EXEC                  = 2
	TIMER_ABSTIME                         = 0x1
	TIMER_RELTIME                         = 0x0
	TIME_UTC                              = 1
	TRAP_BRKPT                            = 1
	TRAP_CAP                              = 4
	TRAP_DTRACE                           = 3
	TRAP_TRACE                            = 2
	TRY_AGAIN                             = 2
	UCHAR_MAX                             = 255
	UF_APPEND                             = 0x00000004
	UF_ARCHIVE                            = 0x00000800
	UF_HIDDEN                             = 0x00008000
	UF_IMMUTABLE                          = 0x00000002
	UF_NODUMP                             = 0x00000001
	UF_NOUNLINK                           = 0x00000010
	UF_OFFLINE                            = 0x00000200
	UF_OPAQUE                             = 0x00000008
	UF_READONLY                           = 0x00001000
	UF_REPARSE                            = 0x00000400
	UF_SETTABLE                           = 0x0000ffff
	UF_SPARSE                             = 0x00000100
	UF_SYSTEM                             = 0x00000080
	UID_MAX                               = 4294967295
	UINT16_MAX                            = 0xffff
	UINT32_MAX                            = 0xffffffff
	UINT64_MAX                            = 0xffffffffffffffff
	UINT8_MAX                             = 0xff
	UINTMAX_MAX                           = 18446744073709551615
	UINTPTR_MAX                           = 18446744073709551615
	UINT_FAST16_MAX                       = 4294967295
	UINT_FAST32_MAX                       = 4294967295
	UINT_FAST64_MAX                       = 18446744073709551615
	UINT_FAST8_MAX                        = 4294967295
	UINT_LEAST16_MAX                      = 65535
	UINT_LEAST32_MAX                      = 4294967295
	UINT_LEAST64_MAX                      = 18446744073709551615
	UINT_LEAST8_MAX                       = 255
	UINT_MAX                              = 4294967295
	ULLONG_MAX                            = 18446744073709551615
	ULONG_MAX                             = 18446744073709551615
	UQUAD_MAX                             = 18446744073709551615
	USE_TCLALLOC                          = 0
	USE_TCLOO_STUBS                       = 0
	USE_TCL_STUBS                         = 0
	USHRT_MAX                             = 65535
	UTIME_NOW                             = -1
	UTIME_OMIT                            = -2
	VAR_ALL_HASH                          = 4236
	VAR_ALL_TRACES                        = 2160
	VAR_ARGUMENT                          = 0x100
	VAR_ARRAY                             = 0x1
	VAR_ARRAY_ELEMENT                     = 0x1000
	VAR_DEAD_HASH                         = 0x8
	VAR_IN_HASHTABLE                      = 0x4
	VAR_IS_ARGS                           = 0x400
	VAR_LINK                              = 0x2
	VAR_NAMESPACE_VAR                     = 0x80
	VAR_RESOLVED                          = 0x8000
	VAR_SEARCH_ACTIVE                     = 0x4000
	VAR_TEMPORARY                         = 0x200
	VAR_TRACED_ARRAY                      = 0x800
	VAR_TRACED_READ                       = 0x10
	VAR_TRACED_UNSET                      = 0x40
	VAR_TRACED_WRITE                      = 0x20
	VAR_TRACE_ACTIVE                      = 0x2000
	WAIT_ANY                              = -1
	WAIT_MYPGRP                           = 0
	WCHAR_MAX                             = 2147483647
	WCHAR_MIN                             = -2147483648
	WCONTINUED                            = 4
	WCOREFLAG                             = 0200
	WEXITED                               = 16
	WINT_MAX                              = 2147483647
	WINT_MIN                              = -2147483648
	WLINUXCLONE                           = 0x80000000
	WNOHANG                               = 1
	WNOWAIT                               = 8
	WORD_BIT                              = 32
	WSTOPPED                              = 2
	WTRAPPED                              = 32
	WUNTRACED                             = 2
	W_OK                                  = 0x02
	X_OK                                  = 0x01
	X_ACCMODE_T_DECLARED                  = 0
	X_AMD64_INCLUDE_PARAM_H_              = 0
	X_ARPA_INET_H_                        = 0
	X_BIG_ENDIAN                          = 4321
	X_BLKCNT_T_DECLARED                   = 0
	X_BLKSIZE_T_DECLARED                  = 0
	X_BYTEORDER_FUNC_DEFINED              = 0
	X_BYTEORDER_PROTOTYPED                = 0
	X_BYTE_ORDER                          = 1234
	X_CACHED_RUNES                        = 256
	X_CAP_IOCTL_T_DECLARED                = 0
	X_CAP_RIGHTS_T_DECLARED               = 0
	X_CLOCKID_T_DECLARED                  = 0
	X_CLOCK_T_DECLARED                    = 0
	X_CRMASK                              = -256
	X_CS_PATH                             = 1
	X_CS_POSIX_V6_ILP32_OFF32_CFLAGS      = 2
	X_CS_POSIX_V6_ILP32_OFF32_LDFLAGS     = 3
	X_CS_POSIX_V6_ILP32_OFF32_LIBS        = 4
	X_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS     = 5
	X_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS    = 6
	X_CS_POSIX_V6_ILP32_OFFBIG_LIBS       = 7
	X_CS_POSIX_V6_LP64_OFF64_CFLAGS       = 8
	X_CS_POSIX_V6_LP64_OFF64_LDFLAGS      = 9
	X_CS_POSIX_V6_LP64_OFF64_LIBS         = 10
	X_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS     = 11
	X_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS    = 12
	X_CS_POSIX_V6_LPBIG_OFFBIG_LIBS       = 13
	X_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS   = 14
	X_CTYPE_A                             = 0x00000100
	X_CTYPE_B                             = 0x00020000
	X_CTYPE_C                             = 0x00000200
	X_CTYPE_D                             = 0x00000400
	X_CTYPE_G                             = 0x00000800
	X_CTYPE_H_                            = 0
	X_CTYPE_I                             = 0x00080000
	X_CTYPE_L                             = 0x00001000
	X_CTYPE_N                             = 0x00400000
	X_CTYPE_P                             = 0x00002000
	X_CTYPE_Q                             = 0x00200000
	X_CTYPE_R                             = 0x00040000
	X_CTYPE_S                             = 0x00004000
	X_CTYPE_SW0                           = 0x20000000
	X_CTYPE_SW1                           = 0x40000000
	X_CTYPE_SW2                           = 0x80000000
	X_CTYPE_SW3                           = 0xc0000000
	X_CTYPE_SWM                           = 0xe0000000
	X_CTYPE_SWS                           = 30
	X_CTYPE_T                             = 0x00100000
	X_CTYPE_U                             = 0x00008000
	X_CTYPE_X                             = 0x00010000
	X_DEV_T_DECLARED                      = 0
	X_DIRENT_H_                           = 0
	X_ERRNO_T_DEFINED                     = 0
	X_FFLAGS_T_DECLARED                   = 0
	X_FSBLKCNT_T_DECLARED                 = 0
	X_GCC_MAX_ALIGN_T                     = 0
	X_GETOPT_DECLARED                     = 0
	X_GID_T_DECLARED                      = 0
	X_GRP_H_                              = 0
	X_IDTYPE_T_DECLARED                   = 0
	X_ID_T_DECLARED                       = 0
	X_INO_T_DECLARED                      = 0
	X_INT16_T_DECLARED                    = 0
	X_INT32_T_DECLARED                    = 0
	X_INT64_T_DECLARED                    = 0
	X_INT8_T_DECLARED                     = 0
	X_INTMAX_T_DECLARED                   = 0
	X_INTPTR_T_DECLARED                   = 0
	X_INTTYPES_H_                         = 0
	X_IN_ADDR_T_DECLARED                  = 0
	X_IN_PORT_T_DECLARED                  = 0
	X_KEY_T_DECLARED                      = 0
	X_LC_LAST                             = 7
	X_LIMITS_H_                           = 0
	X_LITTLE_ENDIAN                       = 1234
	X_LOCALE_H_                           = 0
	X_LOCALE_T_DEFINED                    = 0
	X_LWPID_T_DECLARED                    = 0
	X_MACHINE_ENDIAN_H_                   = 0
	X_MACHINE_FLOAT_H_                    = 1
	X_MACHINE_INTTYPES_H_                 = 0
	X_MACHINE__STDINT_H_                  = 0
	X_MASTERPASSWD                        = "master.passwd"
	X_MATH_H_                             = 0
	X_MC_FLAG_MASK                        = 7
	X_MC_FPFMT_NODEV                      = 0x10000
	X_MC_FPFMT_XMM                        = 0x10002
	X_MC_FPOWNED_FPU                      = 0x20001
	X_MC_FPOWNED_NONE                     = 0x20000
	X_MC_FPOWNED_PCB                      = 0x20002
	X_MC_HASBASES                         = 0x2
	X_MC_HASFPXSTATE                      = 0x4
	X_MC_HASSEGS                          = 0x1
	X_MKDTEMP_DECLARED                    = 0
	X_MKNOD_DECLARED                      = 0
	X_MKSTEMP_DECLARED                    = 0
	X_MKTEMP_DECLARED                     = 0
	X_MODE_T_DECLARED                     = 0
	X_MP_DB                               = "pwd.db"
	X_MQD_T_DECLARED                      = 0
	X_NETDB_H_                            = 0
	X_NETINET6_IN6_H_                     = 0
	X_NETINET_IN_H_                       = 0
	X_NLINK_T_DECLARED                    = 0
	X_OPTRESET_DECLARED                   = 0
	X_PASSWD                              = "passwd"
	X_PASSWORD_EFMT1                      = 95
	X_PASSWORD_LEN                        = 128
	X_PATH_GROUP                          = "/etc/group"
	X_PATH_HEQUIV                         = "/etc/hosts.equiv"
	X_PATH_HOSTS                          = "/etc/hosts"
	X_PATH_MASTERPASSWD                   = "/etc/master.passwd"
	X_PATH_MP_DB                          = "/etc/pwd.db"
	X_PATH_NETWORKS                       = "/etc/networks"
	X_PATH_PASSWD                         = "/etc/passwd"
	X_PATH_PROTOCOLS                      = "/etc/protocols"
	X_PATH_PWD                            = "/etc"
	X_PATH_PWD_MKDB                       = "/usr/sbin/pwd_mkdb"
	X_PATH_SERVICES                       = "/etc/services"
	X_PATH_SERVICES_DB                    = "/var/db/services.db"
	X_PATH_SMP_DB                         = "/etc/spwd.db"
	X_PC_ACL_EXTENDED                     = 59
	X_PC_ACL_NFS4                         = 64
	X_PC_ACL_PATH_MAX                     = 60
	X_PC_ALLOC_SIZE_MIN                   = 10
	X_PC_ASYNC_IO                         = 53
	X_PC_CAP_PRESENT                      = 61
	X_PC_CHOWN_RESTRICTED                 = 7
	X_PC_FILESIZEBITS                     = 12
	X_PC_INF_PRESENT                      = 62
	X_PC_LINK_MAX                         = 1
	X_PC_MAC_PRESENT                      = 63
	X_PC_MAX_CANON                        = 2
	X_PC_MAX_INPUT                        = 3
	X_PC_MIN_HOLE_SIZE                    = 21
	X_PC_NAME_MAX                         = 4
	X_PC_NO_TRUNC                         = 8
	X_PC_PATH_MAX                         = 5
	X_PC_PIPE_BUF                         = 6
	X_PC_PRIO_IO                          = 54
	X_PC_REC_INCR_XFER_SIZE               = 14
	X_PC_REC_MAX_XFER_SIZE                = 15
	X_PC_REC_MIN_XFER_SIZE                = 16
	X_PC_REC_XFER_ALIGN                   = 17
	X_PC_SYMLINK_MAX                      = 18
	X_PC_SYNC_IO                          = 55
	X_PC_VDISABLE                         = 9
	X_PDP_ENDIAN                          = 3412
	X_PID_T_DECLARED                      = 0
	X_POSIX2_BC_BASE_MAX                  = 99
	X_POSIX2_BC_DIM_MAX                   = 2048
	X_POSIX2_BC_SCALE_MAX                 = 99
	X_POSIX2_BC_STRING_MAX                = 1000
	X_POSIX2_CHARCLASS_NAME_MAX           = 14
	X_POSIX2_CHAR_TERM                    = 1
	X_POSIX2_COLL_WEIGHTS_MAX             = 2
	X_POSIX2_C_BIND                       = 200112
	X_POSIX2_C_DEV                        = -1
	X_POSIX2_EQUIV_CLASS_MAX              = 2
	X_POSIX2_EXPR_NEST_MAX                = 32
	X_POSIX2_FORT_DEV                     = -1
	X_POSIX2_FORT_RUN                     = 200112
	X_POSIX2_LINE_MAX                     = 2048
	X_POSIX2_LOCALEDEF                    = -1
	X_POSIX2_PBS                          = -1
	X_POSIX2_PBS_ACCOUNTING               = -1
	X_POSIX2_PBS_CHECKPOINT               = -1
	X_POSIX2_PBS_LOCATE                   = -1
	X_POSIX2_PBS_MESSAGE                  = -1
	X_POSIX2_PBS_TRACK                    = -1
	X_POSIX2_RE_DUP_MAX                   = 255
	X_POSIX2_SW_DEV                       = -1
	X_POSIX2_UPE                          = 200112
	X_POSIX2_VERSION                      = 199212
	X_POSIX_ADVISORY_INFO                 = 200112
	X_POSIX_AIO_LISTIO_MAX                = 2
	X_POSIX_AIO_MAX                       = 1
	X_POSIX_ARG_MAX                       = 4096
	X_POSIX_ASYNCHRONOUS_IO               = 200112
	X_POSIX_BARRIERS                      = 200112
	X_POSIX_CHILD_MAX                     = 25
	X_POSIX_CHOWN_RESTRICTED              = 1
	X_POSIX_CLOCKRES_MIN                  = 20000000
	X_POSIX_CLOCK_SELECTION               = -1
	X_POSIX_CPUTIME                       = 200112
	X_POSIX_DELAYTIMER_MAX                = 32
	X_POSIX_FSYNC                         = 200112
	X_POSIX_HOST_NAME_MAX                 = 255
	X_POSIX_IPV6                          = 0
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_LINK_MAX                      = 8
	X_POSIX_LOGIN_NAME_MAX                = 9
	X_POSIX_MAPPED_FILES                  = 200112
	X_POSIX_MAX_CANON                     = 255
	X_POSIX_MAX_INPUT                     = 255
	X_POSIX_MEMLOCK                       = -1
	X_POSIX_MEMLOCK_RANGE                 = 200112
	X_POSIX_MEMORY_PROTECTION             = 200112
	X_POSIX_MESSAGE_PASSING               = 200112
	X_POSIX_MONOTONIC_CLOCK               = 200112
	X_POSIX_MQ_OPEN_MAX                   = 8
	X_POSIX_MQ_PRIO_MAX                   = 32
	X_POSIX_NAME_MAX                      = 14
	X_POSIX_NGROUPS_MAX                   = 8
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_OPEN_MAX                      = 20
	X_POSIX_PATH_MAX                      = 256
	X_POSIX_PIPE_BUF                      = 512
	X_POSIX_PRIORITIZED_IO                = -1
	X_POSIX_PRIORITY_SCHEDULING           = 0
	X_POSIX_RAW_SOCKETS                   = 200112
	X_POSIX_READER_WRITER_LOCKS           = 200112
	X_POSIX_REALTIME_SIGNALS              = 200112
	X_POSIX_REGEXP                        = 1
	X_POSIX_RE_DUP_MAX                    = 255
	X_POSIX_RTSIG_MAX                     = 8
	X_POSIX_SEMAPHORES                    = 200112
	X_POSIX_SEM_NSEMS_MAX                 = 256
	X_POSIX_SEM_VALUE_MAX                 = 32767
	X_POSIX_SHARED_MEMORY_OBJECTS         = 200112
	X_POSIX_SHELL                         = 1
	X_POSIX_SIGQUEUE_MAX                  = 32
	X_POSIX_SPAWN                         = 200112
	X_POSIX_SPIN_LOCKS                    = 200112
	X_POSIX_SPORADIC_SERVER               = -1
	X_POSIX_SSIZE_MAX                     = 32767
	X_POSIX_SS_REPL_MAX                   = 4
	X_POSIX_STREAM_MAX                    = 8
	X_POSIX_SYMLINK_MAX                   = 255
	X_POSIX_SYMLOOP_MAX                   = 8
	X_POSIX_SYNCHRONIZED_IO               = -1
	X_POSIX_THREADS                       = 200112
	X_POSIX_THREAD_ATTR_STACKADDR         = 200112
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200112
	X_POSIX_THREAD_CPUTIME                = 200112
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS  = 4
	X_POSIX_THREAD_KEYS_MAX               = 128
	X_POSIX_THREAD_PRIORITY_SCHEDULING    = 200112
	X_POSIX_THREAD_PRIO_INHERIT           = 200112
	X_POSIX_THREAD_PRIO_PROTECT           = 200112
	X_POSIX_THREAD_PROCESS_SHARED         = 200112
	X_POSIX_THREAD_SAFE_FUNCTIONS         = -1
	X_POSIX_THREAD_SPORADIC_SERVER        = -1
	X_POSIX_THREAD_THREADS_MAX            = 64
	X_POSIX_TIMEOUTS                      = 200112
	X_POSIX_TIMERS                        = 200112
	X_POSIX_TIMER_MAX                     = 32
	X_POSIX_TRACE                         = -1
	X_POSIX_TRACE_EVENT_FILTER            = -1
	X_POSIX_TRACE_EVENT_NAME_MAX          = 30
	X_POSIX_TRACE_INHERIT                 = -1
	X_POSIX_TRACE_LOG                     = -1
	X_POSIX_TRACE_NAME_MAX                = 8
	X_POSIX_TRACE_SYS_MAX                 = 8
	X_POSIX_TRACE_USER_EVENT_MAX          = 32
	X_POSIX_TTY_NAME_MAX                  = 9
	X_POSIX_TYPED_MEMORY_OBJECTS          = -1
	X_POSIX_TZNAME_MAX                    = 6
	X_POSIX_VDISABLE                      = 0xff
	X_POSIX_VERSION                       = 200112
	X_PTHREAD_T_DECLARED                  = 0
	X_PTRDIFF_T_DECLARED                  = 0
	X_PWD_CURRENT_VERSION                 = 4
	X_PWD_H_                              = 0
	X_PWF_CHANGE                          = 16
	X_PWF_CLASS                           = 32
	X_PWF_DIR                             = 128
	X_PWF_EXPIRE                          = 512
	X_PWF_FILES                           = 0x1000
	X_PWF_GECOS                           = 64
	X_PWF_GID                             = 8
	X_PWF_HESIOD                          = 0x3000
	X_PWF_NAME                            = 1
	X_PWF_NIS                             = 0x2000
	X_PWF_PASSWD                          = 2
	X_PWF_SHELL                           = 256
	X_PWF_SOURCE                          = 0x3000
	X_PWF_UID                             = 4
	X_PW_KEYBYNAME                        = 49
	X_PW_KEYBYNUM                         = 50
	X_PW_KEYBYUID                         = 51
	X_PW_KEYYPBYNUM                       = 53
	X_PW_KEYYPENABLED                     = 52
	X_PW_VERSION_MASK                     = 240
	X_QUAD_HIGHWORD                       = 1
	X_QUAD_LOWWORD                        = 0
	X_REGEX_H_                            = 0
	X_RLIM_T_DECLARED                     = 0
	X_RUNETYPE_H_                         = 0
	X_RUNE_MAGIC_1                        = "RuneMagi"
	X_RUNE_T_DECLARED                     = 0
	X_SA_FAMILY_T_DECLARED                = 0
	X_SC_2_CHAR_TERM                      = 20
	X_SC_2_C_BIND                         = 18
	X_SC_2_C_DEV                          = 19
	X_SC_2_FORT_DEV                       = 21
	X_SC_2_FORT_RUN                       = 22
	X_SC_2_LOCALEDEF                      = 23
	X_SC_2_PBS                            = 59
	X_SC_2_PBS_ACCOUNTING                 = 60
	X_SC_2_PBS_CHECKPOINT                 = 61
	X_SC_2_PBS_LOCATE                     = 62
	X_SC_2_PBS_MESSAGE                    = 63
	X_SC_2_PBS_TRACK                      = 64
	X_SC_2_SW_DEV                         = 24
	X_SC_2_UPE                            = 25
	X_SC_2_VERSION                        = 17
	X_SC_ADVISORY_INFO                    = 65
	X_SC_AIO_LISTIO_MAX                   = 42
	X_SC_AIO_MAX                          = 43
	X_SC_AIO_PRIO_DELTA_MAX               = 44
	X_SC_ARG_MAX                          = 1
	X_SC_ASYNCHRONOUS_IO                  = 28
	X_SC_ATEXIT_MAX                       = 107
	X_SC_BARRIERS                         = 66
	X_SC_BC_BASE_MAX                      = 9
	X_SC_BC_DIM_MAX                       = 10
	X_SC_BC_SCALE_MAX                     = 11
	X_SC_BC_STRING_MAX                    = 12
	X_SC_CHILD_MAX                        = 2
	X_SC_CLK_TCK                          = 3
	X_SC_CLOCK_SELECTION                  = 67
	X_SC_COLL_WEIGHTS_MAX                 = 13
	X_SC_CPUSET_SIZE                      = 122
	X_SC_CPUTIME                          = 68
	X_SC_DELAYTIMER_MAX                   = 45
	X_SC_EXPR_NEST_MAX                    = 14
	X_SC_FILE_LOCKING                     = 69
	X_SC_FSYNC                            = 38
	X_SC_GETGR_R_SIZE_MAX                 = 70
	X_SC_GETPW_R_SIZE_MAX                 = 71
	X_SC_HOST_NAME_MAX                    = 72
	X_SC_IOV_MAX                          = 56
	X_SC_IPV6                             = 118
	X_SC_JOB_CONTROL                      = 6
	X_SC_LINE_MAX                         = 15
	X_SC_LOGIN_NAME_MAX                   = 73
	X_SC_MAPPED_FILES                     = 29
	X_SC_MEMLOCK                          = 30
	X_SC_MEMLOCK_RANGE                    = 31
	X_SC_MEMORY_PROTECTION                = 32
	X_SC_MESSAGE_PASSING                  = 33
	X_SC_MONOTONIC_CLOCK                  = 74
	X_SC_MQ_OPEN_MAX                      = 46
	X_SC_MQ_PRIO_MAX                      = 75
	X_SC_NGROUPS_MAX                      = 4
	X_SC_NPROCESSORS_CONF                 = 57
	X_SC_NPROCESSORS_ONLN                 = 58
	X_SC_OPEN_MAX                         = 5
	X_SC_PAGESIZE                         = 47
	X_SC_PAGE_SIZE                        = 47
	X_SC_PHYS_PAGES                       = 121
	X_SC_PRIORITIZED_IO                   = 34
	X_SC_PRIORITY_SCHEDULING              = 35
	X_SC_RAW_SOCKETS                      = 119
	X_SC_READER_WRITER_LOCKS              = 76
	X_SC_REALTIME_SIGNALS                 = 36
	X_SC_REGEXP                           = 77
	X_SC_RE_DUP_MAX                       = 16
	X_SC_RTSIG_MAX                        = 48
	X_SC_SAVED_IDS                        = 7
	X_SC_SEMAPHORES                       = 37
	X_SC_SEM_NSEMS_MAX                    = 49
	X_SC_SEM_VALUE_MAX                    = 50
	X_SC_SHARED_MEMORY_OBJECTS            = 39
	X_SC_SHELL                            = 78
	X_SC_SIGQUEUE_MAX                     = 51
	X_SC_SPAWN                            = 79
	X_SC_SPIN_LOCKS                       = 80
	X_SC_SPORADIC_SERVER                  = 81
	X_SC_STREAM_MAX                       = 26
	X_SC_SYMLOOP_MAX                      = 120
	X_SC_SYNCHRONIZED_IO                  = 40
	X_SC_THREADS                          = 96
	X_SC_THREAD_ATTR_STACKADDR            = 82
	X_SC_THREAD_ATTR_STACKSIZE            = 83
	X_SC_THREAD_CPUTIME                   = 84
	X_SC_THREAD_DESTRUCTOR_ITERATIONS     = 85
	X_SC_THREAD_KEYS_MAX                  = 86
	X_SC_THREAD_PRIORITY_SCHEDULING       = 89
	X_SC_THREAD_PRIO_INHERIT              = 87
	X_SC_THREAD_PRIO_PROTECT              = 88
	X_SC_THREAD_PROCESS_SHARED            = 90
	X_SC_THREAD_SAFE_FUNCTIONS            = 91
	X_SC_THREAD_SPORADIC_SERVER           = 92
	X_SC_THREAD_STACK_MIN                 = 93
	X_SC_THREAD_THREADS_MAX               = 94
	X_SC_TIMEOUTS                         = 95
	X_SC_TIMERS                           = 41
	X_SC_TIMER_MAX                        = 52
	X_SC_TRACE                            = 97
	X_SC_TRACE_EVENT_FILTER               = 98
	X_SC_TRACE_INHERIT                    = 99
	X_SC_TRACE_LOG                        = 100
	X_SC_TTY_NAME_MAX                     = 101
	X_SC_TYPED_MEMORY_OBJECTS             = 102
	X_SC_TZNAME_MAX                       = 27
	X_SC_V6_ILP32_OFF32                   = 103
	X_SC_V6_ILP32_OFFBIG                  = 104
	X_SC_V6_LP64_OFF64                    = 105
	X_SC_V6_LPBIG_OFFBIG                  = 106
	X_SC_VERSION                          = 8
	X_SC_XOPEN_CRYPT                      = 108
	X_SC_XOPEN_ENH_I18N                   = 109
	X_SC_XOPEN_LEGACY                     = 110
	X_SC_XOPEN_REALTIME                   = 111
	X_SC_XOPEN_REALTIME_THREADS           = 112
	X_SC_XOPEN_SHM                        = 113
	X_SC_XOPEN_STREAMS                    = 114
	X_SC_XOPEN_UNIX                       = 115
	X_SC_XOPEN_VERSION                    = 116
	X_SC_XOPEN_XCU_VERSION                = 117
	X_SELECT_DECLARED                     = 0
	X_SIGNAL_H_                           = 0
	X_SIGSET_T_DECLARED                   = 0
	X_SIG_MAXSIG                          = 128
	X_SIG_WORDS                           = 4
	X_SMP_DB                              = "spwd.db"
	X_SOCKLEN_T_DECLARED                  = 0
	X_SS_MAXSIZE                          = 128
	X_STDDEF_H_                           = 0
	X_STDLIB_H_                           = 0
	X_STRINGS_H_                          = 0
	X_STRING_H_                           = 0
	X_STRUCT_IN_ADDR_DECLARED             = 0
	X_SUSECONDS_T_DECLARED                = 0
	X_SWAB_DECLARED                       = 0
	X_SYS_DIRENT_H_                       = 0
	X_SYS_ERRNO_H_                        = 0
	X_SYS_FCNTL_H_                        = 0
	X_SYS_FILE_H_                         = 0
	X_SYS_LIMITS_H_                       = 0
	X_SYS_PARAM_H_                        = 0
	X_SYS_SELECT_H_                       = 0
	X_SYS_SIGNAL_H_                       = 0
	X_SYS_SOCKET_H_                       = 0
	X_SYS_STAT_H_                         = 0
	X_SYS_STDINT_H_                       = 0
	X_SYS_SYSLIMITS_H_                    = 0
	X_SYS_TIMESPEC_H_                     = 0
	X_SYS_TIME_H_                         = 0
	X_SYS_TYPES_H_                        = 0
	X_SYS_UNISTD_H_                       = 0
	X_SYS_UTSNAME_H                       = 0
	X_SYS_WAIT_H_                         = 0
	X_SYS__IOVEC_H_                       = 0
	X_SYS__PTHREADTYPES_H_                = 0
	X_SYS__SIGSET_H_                      = 0
	X_SYS__SOCKADDR_STORAGE_H_            = 0
	X_SYS__STDINT_H_                      = 0
	X_SYS__TIMESPEC_H_                    = 0
	X_SYS__TIMEVAL_H_                     = 0
	X_SYS__UCONTEXT_H_                    = 0
	X_TCLINT                              = 0
	X_TCLINTDECLS                         = 0
	X_TCLINTPLATDECLS                     = 0
	X_TCLOODECLS                          = 0
	X_TCLPORT                             = 0
	X_TCLREGEXP                           = 0
	X_TCLTOMMATHDECLS                     = 0
	X_TCLUNIXPORT                         = 0
	X_TIMER_T_DECLARED                    = 0
	X_TIME_H_                             = 0
	X_TIME_T_DECLARED                     = 0
	X_UID_T_DECLARED                      = 0
	X_UINT16_T_DECLARED                   = 0
	X_UINT32_T_DECLARED                   = 0
	X_UINT64_T_DECLARED                   = 0
	X_UINT8_T_DECLARED                    = 0
	X_UINTMAX_T_DECLARED                  = 0
	X_UINTPTR_T_DECLARED                  = 0
	X_UNISTD_H_                           = 0
	X_USECONDS_T_DECLARED                 = 0
	X_UTIME_H_                            = 0
	X_V6_ILP32_OFF32                      = -1
	X_V6_ILP32_OFFBIG                     = 0
	X_V6_LP64_OFF64                       = 0
	X_V6_LPBIG_OFFBIG                     = -1
	X_WCHAR_T_DECLARED                    = 0
	X_WSTOPPED                            = 0177
	X_X86_INCLUDE__ALIGN_H_               = 0
	X_X86_SIGNAL_H                        = 1
	X_X86_UCONTEXT_H_                     = 0
	X_XLOCALE_CTYPE_H                     = 0
	X_XLOCALE_LOCALE1_H                   = 0
	X_XLOCALE_LOCALE_H                    = 0
	X_XLOCALE_RUN_FUNCTIONS_DEFINED       = 1
	X_XLOCALE_STRING1_H                   = 0
	X_XLOCALE_STRINGS1_H                  = 0
	X_XOPEN_CRYPT                         = -1
	X_XOPEN_ENH_I18N                      = -1
	X_XOPEN_IOV_MAX                       = 16
	X_XOPEN_LEGACY                        = -1
	X_XOPEN_NAME_MAX                      = 255
	X_XOPEN_PATH_MAX                      = 1024
	X_XOPEN_REALTIME                      = -1
	X_XOPEN_REALTIME_THREADS              = -1
	X_XOPEN_SHM                           = 1
	X_XOPEN_STREAMS                       = -1
	X_XOPEN_UNIX                          = -1
	Math_errhandling                      = 2
	Pseudo_AF_HDRCMPLT                    = 31
	Pseudo_AF_KEY                         = 27
	Pseudo_AF_PIP                         = 25
	Pseudo_AF_RTIP                        = 22
	Pseudo_AF_XTP                         = 19
	BN_CUTOFFS_C                          = 0
	BN_DEPRECATED_C                       = 0
	BN_FAST_MP_INVMOD_C                   = 0
	BN_FAST_MP_MONTGOMERY_REDUCE_C        = 0
	BN_FAST_S_MP_MUL_DIGS_C               = 0
	BN_FAST_S_MP_MUL_HIGH_DIGS_C          = 0
	BN_FAST_S_MP_SQR_C                    = 0
	BN_MP_2EXPT_C                         = 0
	BN_MP_ABS_C                           = 0
	BN_MP_ADDMOD_C                        = 0
	BN_MP_ADD_C                           = 0
	BN_MP_ADD_D_C                         = 0
	BN_MP_AND_C                           = 0
	BN_MP_BALANCE_MUL_C                   = 0
	BN_MP_CLAMP_C                         = 0
	BN_MP_CLEAR_C                         = 0
	BN_MP_CLEAR_MULTI_C                   = 0
	BN_MP_CMP_C                           = 0
	BN_MP_CMP_D_C                         = 0
	BN_MP_CMP_MAG_C                       = 0
	BN_MP_CNT_LSB_C                       = 0
	BN_MP_COMPLEMENT_C                    = 0
	BN_MP_COPY_C                          = 0
	BN_MP_COUNT_BITS_C                    = 0
	BN_MP_DECR_C                          = 0
	BN_MP_DIV_2D_C                        = 0
	BN_MP_DIV_2_C                         = 0
	BN_MP_DIV_3_C                         = 0
	BN_MP_DIV_C                           = 0
	BN_MP_DIV_D_C                         = 0
	BN_MP_DR_IS_MODULUS_C                 = 0
	BN_MP_DR_REDUCE_C                     = 0
	BN_MP_DR_SETUP_C                      = 0
	BN_MP_ERROR_TO_STRING_C               = 0
	BN_MP_EXCH_C                          = 0
	BN_MP_EXPORT_C                        = 0
	BN_MP_EXPTMOD_C                       = 0
	BN_MP_EXPTMOD_FAST_C                  = 0
	BN_MP_EXPT_D_C                        = 0
	BN_MP_EXPT_D_EX_C                     = 0
	BN_MP_EXPT_U32_C                      = 0
	BN_MP_EXTEUCLID_C                     = 0
	BN_MP_FREAD_C                         = 0
	BN_MP_FROM_SBIN_C                     = 0
	BN_MP_FROM_UBIN_C                     = 0
	BN_MP_FWRITE_C                        = 0
	BN_MP_GCD_C                           = 0
	BN_MP_GET_BIT_C                       = 0
	BN_MP_GET_DOUBLE_C                    = 0
	BN_MP_GET_I32_C                       = 0
	BN_MP_GET_I64_C                       = 0
	BN_MP_GET_INT_C                       = 0
	BN_MP_GET_LL_C                        = 0
	BN_MP_GET_LONG_C                      = 0
	BN_MP_GET_LONG_LONG_C                 = 0
	BN_MP_GET_L_C                         = 0
	BN_MP_GET_MAG_U32_C                   = 0
	BN_MP_GET_MAG_U64_C                   = 0
	BN_MP_GET_MAG_ULL_C                   = 0
	BN_MP_GET_MAG_UL_C                    = 0
	BN_MP_GROW_C                          = 0
	BN_MP_IMPORT_C                        = 0
	BN_MP_INCR_C                          = 0
	BN_MP_INIT_C                          = 0
	BN_MP_INIT_COPY_C                     = 0
	BN_MP_INIT_I32_C                      = 0
	BN_MP_INIT_I64_C                      = 0
	BN_MP_INIT_LL_C                       = 0
	BN_MP_INIT_L_C                        = 0
	BN_MP_INIT_MULTI_C                    = 0
	BN_MP_INIT_SET_C                      = 0
	BN_MP_INIT_SET_INT_C                  = 0
	BN_MP_INIT_SIZE_C                     = 0
	BN_MP_INIT_U32_C                      = 0
	BN_MP_INIT_U64_C                      = 0
	BN_MP_INIT_ULL_C                      = 0
	BN_MP_INIT_UL_C                       = 0
	BN_MP_INVMOD_C                        = 0
	BN_MP_INVMOD_SLOW_C                   = 0
	BN_MP_ISEVEN_C                        = 0
	BN_MP_ISODD_C                         = 0
	BN_MP_IS_SQUARE_C                     = 0
	BN_MP_JACOBI_C                        = 0
	BN_MP_KARATSUBA_MUL_C                 = 0
	BN_MP_KARATSUBA_SQR_C                 = 0
	BN_MP_KRONECKER_C                     = 0
	BN_MP_LCM_C                           = 0
	BN_MP_LOG_U32_C                       = 0
	BN_MP_LSHD_C                          = 0
	BN_MP_MOD_2D_C                        = 0
	BN_MP_MOD_C                           = 0
	BN_MP_MOD_D_C                         = 0
	BN_MP_MONTGOMERY_CALC_NORMALIZATION_C = 0
	BN_MP_MONTGOMERY_REDUCE_C             = 0
	BN_MP_MONTGOMERY_SETUP_C              = 0
	BN_MP_MULMOD_C                        = 0
	BN_MP_MUL_2D_C                        = 0
	BN_MP_MUL_2_C                         = 0
	BN_MP_MUL_C                           = 0
	BN_MP_MUL_D_C                         = 0
	BN_MP_NEG_C                           = 0
	BN_MP_N_ROOT_C                        = 0
	BN_MP_N_ROOT_EX_C                     = 0
	BN_MP_OR_C                            = 0
	BN_MP_PACK_C                          = 0
	BN_MP_PACK_COUNT_C                    = 0
	BN_MP_PRIME_FERMAT_C                  = 0
	BN_MP_PRIME_FROBENIUS_UNDERWOOD_C     = 0
	BN_MP_PRIME_IS_DIVISIBLE_C            = 0
	BN_MP_PRIME_IS_PRIME_C                = 0
	BN_MP_PRIME_MILLER_RABIN_C            = 0
	BN_MP_PRIME_NEXT_PRIME_C              = 0
	BN_MP_PRIME_RABIN_MILLER_TRIALS_C     = 0
	BN_MP_PRIME_RANDOM_EX_C               = 0
	BN_MP_PRIME_RAND_C                    = 0
	BN_MP_PRIME_STRONG_LUCAS_SELFRIDGE_C  = 0
	BN_MP_RADIX_SIZE_C                    = 0
	BN_MP_RADIX_SMAP_C                    = 0
	BN_MP_RAND_C                          = 0
	BN_MP_RAND_DIGIT_C                    = 0
	BN_MP_RAND_SOURCE_C                   = 0
	BN_MP_READ_RADIX_C                    = 0
	BN_MP_READ_SIGNED_BIN_C               = 0
	BN_MP_READ_UNSIGNED_BIN_C             = 0
	BN_MP_REDUCE_2K_C                     = 0
	BN_MP_REDUCE_2K_L_C                   = 0
	BN_MP_REDUCE_2K_SETUP_C               = 0
	BN_MP_REDUCE_2K_SETUP_L_C             = 0
	BN_MP_REDUCE_C                        = 0
	BN_MP_REDUCE_IS_2K_C                  = 0
	BN_MP_REDUCE_IS_2K_L_C                = 0
	BN_MP_REDUCE_SETUP_C                  = 0
	BN_MP_ROOT_U32_C                      = 0
	BN_MP_RSHD_C                          = 0
	BN_MP_SBIN_SIZE_C                     = 0
	BN_MP_SET_C                           = 0
	BN_MP_SET_DOUBLE_C                    = 0
	BN_MP_SET_I32_C                       = 0
	BN_MP_SET_I64_C                       = 0
	BN_MP_SET_INT_C                       = 0
	BN_MP_SET_LL_C                        = 0
	BN_MP_SET_LONG_C                      = 0
	BN_MP_SET_LONG_LONG_C                 = 0
	BN_MP_SET_L_C                         = 0
	BN_MP_SET_U32_C                       = 0
	BN_MP_SET_U64_C                       = 0
	BN_MP_SET_ULL_C                       = 0
	BN_MP_SET_UL_C                        = 0
	BN_MP_SHRINK_C                        = 0
	BN_MP_SIGNED_BIN_SIZE_C               = 0
	BN_MP_SIGNED_RSH_C                    = 0
	BN_MP_SQRMOD_C                        = 0
	BN_MP_SQRTMOD_PRIME_C                 = 0
	BN_MP_SQRT_C                          = 0
	BN_MP_SQR_C                           = 0
	BN_MP_SUBMOD_C                        = 0
	BN_MP_SUB_C                           = 0
	BN_MP_SUB_D_C                         = 0
	BN_MP_TC_AND_C                        = 0
	BN_MP_TC_DIV_2D_C                     = 0
	BN_MP_TC_OR_C                         = 0
	BN_MP_TC_XOR_C                        = 0
	BN_MP_TOOM_MUL_C                      = 0
	BN_MP_TOOM_SQR_C                      = 0
	BN_MP_TORADIX_C                       = 0
	BN_MP_TORADIX_N_C                     = 0
	BN_MP_TO_RADIX_C                      = 0
	BN_MP_TO_SBIN_C                       = 0
	BN_MP_TO_SIGNED_BIN_C                 = 0
	BN_MP_TO_SIGNED_BIN_N_C               = 0
	BN_MP_TO_UBIN_C                       = 0
	BN_MP_TO_UNSIGNED_BIN_C               = 0
	BN_MP_TO_UNSIGNED_BIN_N_C             = 0
	BN_MP_UBIN_SIZE_C                     = 0
	BN_MP_UNPACK_C                        = 0
	BN_MP_UNSIGNED_BIN_SIZE_C             = 0
	BN_MP_XOR_C                           = 0
	BN_MP_ZERO_C                          = 0
	BN_PRIME_TAB_C                        = 0
	BN_S_MP_ADD_C                         = 0
	BN_S_MP_BALANCE_MUL_C                 = 0
	BN_S_MP_EXPTMOD_C                     = 0
	BN_S_MP_EXPTMOD_FAST_C                = 0
	BN_S_MP_GET_BIT_C                     = 0
	BN_S_MP_INVMOD_FAST_C                 = 0
	BN_S_MP_INVMOD_SLOW_C                 = 0
	BN_S_MP_KARATSUBA_MUL_C               = 0
	BN_S_MP_KARATSUBA_SQR_C               = 0
	BN_S_MP_MONTGOMERY_REDUCE_FAST_C      = 0
	BN_S_MP_MUL_DIGS_C                    = 0
	BN_S_MP_MUL_DIGS_FAST_C               = 0
	BN_S_MP_MUL_HIGH_DIGS_C               = 0
	BN_S_MP_MUL_HIGH_DIGS_FAST_C          = 0
	BN_S_MP_MUL_SI_C                      = 0
	BN_S_MP_PRIME_IS_DIVISIBLE_C          = 0
	BN_S_MP_PRIME_RANDOM_EX_C             = 0
	BN_S_MP_RAND_CB_C                     = 0
	BN_S_MP_RAND_JENKINS_C                = 0
	BN_S_MP_RAND_JENKINS_INIT_C           = 0
	BN_S_MP_RAND_PLATFORM_C               = 0
	BN_S_MP_RAND_SOURCE_C                 = 0
	BN_S_MP_REVERSE_C                     = 0
	BN_S_MP_SQR_C                         = 0
	BN_S_MP_SQR_FAST_C                    = 0
	BN_S_MP_SUB_C                         = 0
	BN_S_MP_TOOM_MUL_C                    = 0
	BN_S_MP_TOOM_SQR_C                    = 0
	LTM1                                  = 0
	LTM2                                  = 0
	LTM3                                  = 0
	LTM_ALL                               = 0
	LTM_LAST                              = 0
	MAX_STRINGS                           = 11
	NUMBER_OF_OBJECT_VARS                 = 20
	STATIC_BUILD                          = 1
	VARPTR_KEY                            = "TCLOBJTEST_VARPTR"
	CPUSTATES                             = 5
	CP_IDLE                               = 4
	CP_INTR                               = 3
	CP_NICE                               = 1
	CP_SYS                                = 2
	CP_USER                               = 0
	MAX_PIPES                             = 10
	PRIO_MAX                              = 20
	PRIO_MIN                              = -20
	PRIO_PGRP                             = 1
	PRIO_PROCESS                          = 0
	PRIO_USER                             = 2
	RLIMIT_AS                             = 10
	RLIMIT_CORE                           = 4
	RLIMIT_CPU                            = 0
	RLIMIT_DATA                           = 2
	RLIMIT_FSIZE                          = 1
	RLIMIT_KQUEUES                        = 13
	RLIMIT_MEMLOCK                        = 6
	RLIMIT_NOFILE                         = 8
	RLIMIT_NPROC                          = 7
	RLIMIT_NPTS                           = 11
	RLIMIT_RSS                            = 5
	RLIMIT_SBSIZE                         = 9
	RLIMIT_STACK                          = 3
	RLIMIT_SWAP                           = 12
	RLIMIT_UMTXP                          = 14
	RLIMIT_VMEM                           = 10
	RLIM_NLIMITS                          = 15
	RUSAGE_CHILDREN                       = -1
	RUSAGE_SELF                           = 0
	RUSAGE_THREAD                         = 1
	X_SYS_RESOURCE_H_                     = 0
)

// Positions to pass to Tcl_QueueEvent:

const ( /* tcl.h:1402:1: */
	TCL_QUEUE_TAIL = 0
	TCL_QUEUE_HEAD = 1
	TCL_QUEUE_MARK = 2
)

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

const ( /* tcl.h:1624:1: */
	TCL_PATH_ABSOLUTE        = 0
	TCL_PATH_RELATIVE        = 1
	TCL_PATH_VOLUME_RELATIVE = 2
)

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

const ( /* tcl.h:705:1: */
	TCL_INT      = 0
	TCL_DOUBLE   = 1
	TCL_EITHER   = 2
	TCL_WIDE_INT = 3
)

// TIP #268.
// Values for the selection mode, i.e the package require preferences.

const ( /* tclInt.h:1736:1: */
	PKG_PREFER_LATEST = 0
	PKG_PREFER_STABLE = 1
)

// Macros that use the TSD-ekeko.

// Macros for script cancellation support (TIP #285).

// Macros for splicing into and out of doubly linked lists. They assume
// existence of struct items 'prevPtr' and 'nextPtr'.
//
// a = element to add or remove.
// b = list head.
//
// TclSpliceIn adds to the head of the list.

// EvalFlag bits for Interp structures:
//
// TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
//			code other than TCL_OK or TCL_ERROR; 0 means codes
//			other than these should be turned into errors.

// Flag bits for Interp structures:
//
// DELETED:		Non-zero means the interpreter has been deleted:
//			don't process any more commands for it, and destroy
//			the structure as soon as all nested invocations of
//			Tcl_Eval are done.
// ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
//			iPtr->errorInfo for the current Tcl_Eval instance, so
//			Tcl_Eval needn't log it (used to implement the "error
//			message log" command).
// DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
//			not compile any commands into an inline sequence of
//			instructions. This is set 1, for example, when command
//			traces are requested.
// RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
//			has not be initialized. This is set 1 when we first
//			use the rand() or srand() functions.
// SAFE_INTERP:		Non zero means that the current interp is a safe
//			interp (i.e. it has only the safe commands installed,
//			less privilege than a regular interp).
// INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
//			debug/info mechanisms (e.g. info frame eval/uplevel
//			tracing) which are performance intensive.
// INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
//			active; so no further trace callbacks should be
//			invoked.
// INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
//			of the wrong-num-args string in Tcl_WrongNumArgs.
//			Makes it append instead of replacing and uses
//			different intermediate text.
// CANCELED:		Non-zero means that the script in progress should be
//			canceled as soon as possible. This can be checked by
//			extensions (and the core itself) by calling
//			Tcl_Canceled and checking if TCL_ERROR is returned.
//			This is a one-shot flag that is reset immediately upon
//			being detected; however, if the TCL_CANCEL_UNWIND flag
//			is set Tcl_Canceled will continue to report that the
//			script in progress has been canceled thereby allowing
//			the evaluation stack for the interp to be fully
//			unwound.
//
// WARNING: For the sake of some extensions that have made use of former
// internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
// or 8 (formerly ERROR_CODE_SET).

// Maximum number of levels of nesting permitted in Tcl commands (used to
// catch infinite recursion).

// The macro below is used to modify a "char" value (e.g. by casting it to an
// unsigned character) so that it can be used safely with macros such as
// isspace.

// This macro is used to properly align the memory allocated by Tcl, giving
// the same alignment as the native malloc.

// This macro is used to determine the offset needed to safely allocate any
// data structure in memory. Given a starting offset or size, it "rounds up"
// or "aligns" the offset to the next 8-byte boundary so that any data
// structure can be placed at the resulting offset without fear of an
// alignment error.
//
// WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
// wrong result on platforms that allocate addresses that are divisible by 4
// or 2. Only use it for offsets or sizes.
//
// This macro is only used by tclCompile.c in the core (Bug 926445). It
// however not be made file static, as extensions that touch bytecodes
// (notably tbcload) require it.

// The following enum values are used to specify the runtime platform setting
// of the tclPlatform variable.

const ( /* tclInt.h:2325:1: */
	TCL_PLATFORM_UNIX    = 0 // Any Unix-like OS.
	TCL_PLATFORM_WINDOWS = 2
)

// The following enum values are used to indicate the translation of a Tcl
// channel. Declared here so that each platform can define
// TCL_PLATFORM_TRANSLATION to the native translation on that platform.

const ( /* tclInt.h:2336:1: */
	TCL_TRANSLATE_AUTO = 0 // Eol == \r, \n and \r\n.
	TCL_TRANSLATE_CR   = 1 // Eol == \r.
	TCL_TRANSLATE_LF   = 2 // Eol == \n.
	TCL_TRANSLATE_CRLF = 3
)

// The "globParameters" argument of the function TclGlob is an or'ed
// combination of the following values:

const ( /* tclInt.h:2572:1: */
	TCL_PATH_DIRNAME   = 0
	TCL_PATH_TAIL      = 1
	TCL_PATH_EXTENSION = 2
	TCL_PATH_ROOT      = 3
)

const ( /* tclInt.h:2746:1: */
	TCL_EMPTYSTRING_UNKNOWN = -1
	TCL_EMPTYSTRING_NO      = 0
	TCL_EMPTYSTRING_YES     = 1
)

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.3 (Berkeley) 1/21/94

// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// This file holds definitions relevant to the wait4 system call and the
// alternate interfaces that use it (wait, wait3, waitpid).

// Macros to test the exit status returned by wait and extract the relevant
// values.

// Option bits for the third argument of wait4.  WNOHANG causes the
// wait to not hang if there are no stopped or terminated processes, rather
// returning an error indication in this case (pid==0).  WUNTRACED
// indicates that the caller should receive status about untraced children
// which stop due to signals.  If children are stopped and a wait without
// this option is done, it is as though they were still running... nothing
// about them is returned. WNOWAIT only request information about zombie,
// leaving the proc around, available for later waits.

const ( /* wait.h:94:1: */
	// These names were mostly lifted from Solaris source code and
	// still use Solaris style naming to avoid breaking any
	// OpenSolaris code which has been ported to FreeBSD.  There
	// is no clear FreeBSD counterpart for all of the names, but
	// some have a clear correspondence to FreeBSD entities.
	//
	// The numerical values are kept synchronized with the Solaris
	// values.
	P_PID    = 0  // A process identifier.
	P_PPID   = 1  // A parent process identifier.
	P_PGID   = 2  // A process group identifier.
	P_SID    = 3  // A session identifier.
	P_CID    = 4  // A scheduling class identifier.
	P_UID    = 5  // A user identifier.
	P_GID    = 6  // A group identifier.
	P_ALL    = 7  // All processes.
	P_LWPID  = 8  // An LWP identifier.
	P_TASKID = 9  // A task identifier.
	P_PROJID = 10 // A project identifier.
	P_POOLID = 11 // A pool identifier.
	P_JAILID = 12 // A zone identifier.
	P_CTID   = 13 // A (process) contract identifier.
	P_CPUID  = 14 // CPU identifier.
	P_PSETID = 15
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */ // compatibility w/GNU headers

// When the following macro is defined, the system uses 64-bit inode numbers.
// Programs can use this to avoid including <sys/param.h>, with its associated
// namespace pollution.

type fpos_t = int64 /* stdio.h:47:18 */

type rsize_t = size_t /* stdio.h:56:16 */

type off_t = int64   /* stdio.h:62:18 */
type ssize_t = int64 /* stdio.h:66:19 */

type off64_t = int64 /* stdio.h:72:19 */

type va_list = uintptr /* stdio.h:77:19 */

// NB: to fit things in six character monocase externals, the stdio
// code uses the prefix `__s' for stdio objects, typically followed
// by a three-character attempt at a mnemonic.

// stdio buffers
type __sbuf = struct {
	_base uintptr
	_size int32
	_     [4]byte
} /* stdio.h:91:1 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// Certain members of __sFILE are accessed directly via macros or
// inline functions.  To preserve ABI compat, these members must not
// be disturbed.  These members are marked below with (*).
type __sFILE = struct {
	_p     uintptr
	_r     int32
	_w     int32
	_flags int16
	_file  int16
	_      [4]byte
	_bf    struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_lbfsize int32
	_        [4]byte
	_cookie  uintptr
	_close   uintptr
	_read    uintptr
	_seek    uintptr
	_write   uintptr
	_ub      struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_up   uintptr
	_ur   int32
	_ubuf [3]uint8
	_nbuf [1]uint8
	_lb   struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_blksize     int32
	_            [4]byte
	_offset      fpos_t
	_fl_mutex    uintptr
	_fl_owner    uintptr
	_fl_count    int32
	_orientation int32
	_mbstate     struct {
		_          [0]uint64
		__mbstate8 [128]int8
	}
	_flags2 int32
	_       [4]byte
} /* stdio.h:124:1 */

type FILE = __sFILE /* stdio.h:165:24 */
type cookie_io_functions_t = struct {
	read  uintptr
	write uintptr
	seek  uintptr
	close uintptr
} /* stdio.h:428:3 */

// See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
// B.8.2.7 for the rationale behind the *_unlocked() macros.

//----------------------------------------------------------------------------
// Support for functions with a variable number of arguments.
//
// The following TCL_VARARGS* macros are to support old extensions
// written for older versions of Tcl where the macros permitted
// support for the varargs.h system as well as stdarg.h .
//
// New code should just directly be written to use stdarg.h conventions.

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause
//
// Copyright (c) 2017 Poul-Henning Kamp.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 2002 David E. O'Brien.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Allow a part of Tcl's API to be explicitly marked as deprecated.
//
// Used to make TIP 330/336 generate moans even if people use the
// compatibility macros. Change your code, guys! We won't support you forever.

//----------------------------------------------------------------------------
// Macros used to declare a function to be exported by a DLL. Used by Windows,
// maps to no-op declarations on non-Windows systems. The default build on
// windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be
// nonempty. To build a static library, the macro STATIC_BUILD should be
// defined.
//
// Note: when building static but linking dynamically to MSVCRT we must still
//       correctly decorate the C library imported function.  Use CRTIMPORT
//       for this purpose.  _DLL is defined by the compiler when linking to
//       MSVCRT.

// These macros are used to control whether functions are being declared for
// import or export. If a function is being declared while it is being built
// to be included in a shared library, then it should have the DLLEXPORT
// storage class. If is being declared for use by a module that is going to
// link against the shared library, then it should have the DLLIMPORT storage
// class. If the symbol is being declared for a static build or for use from a
// stub library, then the storage class should be empty.
//
// The convention is that a macro called BUILD_xxxx, where xxxx is the name of
// a library we are building, is set on the compile line for sources that are
// to be placed in the library. When this macro is set, the storage class will
// be set to DLLEXPORT. At the end of the header file, the storage class will
// be reset to DLLIMPORT.

// The following _ANSI_ARGS_ macro is to support old extensions
// written for older versions of Tcl where it permitted support
// for compilers written in the pre-prototype era of C.
//
// New code should use prototypes.

// Definitions that allow this header file to be used either with or without
// ANSI C features.

// Make sure EXTERN isn't defined elsewhere.

//----------------------------------------------------------------------------
// The following code is copied from winnt.h. If we don't replicate it here,
// then <windows.h> can't be included after tcl.h, since tcl.h also defines
// VOID. This block is skipped under Cygwin and Mingw.

// Macro to use instead of "void" for arguments that must have type "void *"
// in ANSI C; maps them to type "char *" in non-ANSI systems.

// Miscellaneous declarations.

type ClientData = uintptr /* tcl.h:344:15 */

// Darwin specific configure overrides (to support fat compiles, where
// configure runs only once for multiple architectures):

// Cross-compiling 32-bit on a 64-bit platform? Then our
// configure script does the wrong thing. Correct that here.

// Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define
// Tcl_WideUInt to be the unsigned variant of that type (assuming that where
// we have one, we can have the other.)
//
// Also defines the following macros:
// TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a
//	LP64 system such as modern Solaris or Linux ... not including Win64)
// Tcl_WideAsLong - forgetful converter from wideInt to long.
// Tcl_LongAsWide - sign-extending converter from long to wideInt.
// Tcl_WideAsDouble - converter from wideInt to double.
// Tcl_DoubleAsWide - converter from double to wideInt.
//
// The following invariant should hold for any long value 'longVal':
//	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
//
// Note on converting between Tcl_WideInt and strings. This implementation (in
// tclObj.c) depends on the function
// sprintf(...,"%" TCL_LL_MODIFIER "d",...).

type Tcl_WideInt = int64   /* tcl.h:430:28 */
type Tcl_WideUInt = uint64 /* tcl.h:431:36 */

type stat = struct {
	st_dev      dev_t
	st_ino      ino_t
	st_nlink    nlink_t
	st_mode     mode_t
	st_padding0 int16
	st_uid      uid_t
	st_gid      gid_t
	st_padding1 int32
	st_rdev     dev_t
	st_atim     struct {
		tv_sec  time_t
		tv_nsec int64
	}
	st_mtim struct {
		tv_sec  time_t
		tv_nsec int64
	}
	st_ctim struct {
		tv_sec  time_t
		tv_nsec int64
	}
	st_birthtim struct {
		tv_sec  time_t
		tv_nsec int64
	}
	st_size    off_t
	st_blocks  blkcnt_t
	st_blksize blksize_t
	st_flags   fflags_t
	st_gen     uint64
	st_spare   [10]uint64
} /* stat.h:160:1 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp1 = struct {
	resultDontUse    uintptr
	freeProcDontUse  uintptr
	errorLineDontUse int32
	_                [4]byte
} /* tcl.h:508:9 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp = Tcl_Interp1 /* tcl.h:540:1 */

type Tcl_AsyncHandler = uintptr       /* tcl.h:542:34 */
type Tcl_Channel = uintptr            /* tcl.h:543:29 */
type Tcl_ChannelTypeVersion = uintptr /* tcl.h:544:40 */
type Tcl_Command = uintptr            /* tcl.h:545:29 */
type Tcl_Condition = uintptr          /* tcl.h:546:31 */
type Tcl_Dict = uintptr               /* tcl.h:547:26 */
type Tcl_EncodingState = uintptr      /* tcl.h:548:35 */
type Tcl_Encoding = uintptr           /* tcl.h:549:30 */
type Tcl_Event1 = struct {
	proc    uintptr
	nextPtr uintptr
} /* tcl.h:550:9 */

type Tcl_Event = Tcl_Event1    /* tcl.h:550:26 */
type Tcl_InterpState = uintptr /* tcl.h:551:33 */
type Tcl_LoadHandle_ = struct {
	clientData        ClientData
	findSymbolProcPtr uintptr
	unloadFileProcPtr uintptr
} /* tcl.h:552:9 */

type Tcl_LoadHandle = uintptr    /* tcl.h:552:32 */
type Tcl_Mutex = uintptr         /* tcl.h:553:27 */
type Tcl_Pid = uintptr           /* tcl.h:554:25 */
type Tcl_RegExp = uintptr        /* tcl.h:555:28 */
type Tcl_ThreadDataKey = uintptr /* tcl.h:556:35 */
type Tcl_ThreadId = uintptr      /* tcl.h:557:30 */
type Tcl_TimerToken = uintptr    /* tcl.h:558:32 */
type Tcl_Trace = uintptr         /* tcl.h:559:27 */
type Tcl_Var = uintptr           /* tcl.h:560:25 */
type Tcl_ZlibStream = uintptr    /* tcl.h:561:32 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices1 = struct {
	start int64
	end   int64
} /* tcl.h:638:9 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices = Tcl_RegExpIndices1 /* tcl.h:643:3 */

type Tcl_RegExpInfo1 = struct {
	nsubs       int32
	_           [4]byte
	matches     uintptr
	extendStart int64
	reserved    int64
} /* tcl.h:645:9 */

type Tcl_RegExpInfo = Tcl_RegExpInfo1 /* tcl.h:652:3 */

// Picky compilers complain if this typdef doesn't appear before the struct's
// reference in tclDecls.h.

type Tcl_Stat_ = uintptr    /* tcl.h:659:21 */
type Tcl_OldStat_ = uintptr /* tcl.h:660:21 */

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

type Tcl_ValueType = uint32 /* tcl.h:707:3 */

type Tcl_Value1 = struct {
	__type      Tcl_ValueType
	_           [4]byte
	intValue    int64
	doubleValue float64
	wideValue   Tcl_WideInt
} /* tcl.h:709:9 */

type Tcl_Value = Tcl_Value1 /* tcl.h:715:3 */

// Forward declaration of Tcl_Obj to prevent an error when the forward
// reference to Tcl_Obj is encountered in the function types declared below.

type Tcl_Obj1 = struct {
	refCount    int32
	_           [4]byte
	bytes       uintptr
	length      int32
	_           [4]byte
	typePtr     uintptr
	internalRep struct {
		longValue int64
		_         [8]byte
	}
} /* tcl.h:722:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType1 = struct {
	name             uintptr
	freeIntRepProc   uintptr
	dupIntRepProc    uintptr
	updateStringProc uintptr
	setFromAnyProc   uintptr
} /* tcl.h:722:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType = Tcl_ObjType1 /* tcl.h:811:3 */

// One of the following structures exists for each object in the Tcl system.
// An object stores a value as either a string, some internal representation,
// or both.

type Tcl_Obj = Tcl_Obj1 /* tcl.h:858:3 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult1 = struct {
	result       uintptr
	freeProc     uintptr
	objResultPtr uintptr
	appendResult uintptr
	appendAvl    int32
	appendUsed   int32
	resultSpace  [201]int8
	_            [7]byte
} /* tcl.h:879:9 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult = Tcl_SavedResult1 /* tcl.h:887:3 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace1 = struct {
	name       uintptr
	fullName   uintptr
	clientData ClientData
	deleteProc uintptr
	parentPtr  uintptr
} /* tcl.h:896:9 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace = Tcl_Namespace1 /* tcl.h:912:3 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame1 = struct {
	nsPtr   uintptr
	dummy1  int32
	dummy2  int32
	dummy3  uintptr
	dummy4  uintptr
	dummy5  uintptr
	dummy6  int32
	_       [4]byte
	dummy7  uintptr
	dummy8  uintptr
	dummy9  int32
	_       [4]byte
	dummy10 uintptr
	dummy11 uintptr
	dummy12 uintptr
	dummy13 uintptr
} /* tcl.h:937:9 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame = Tcl_CallFrame1 /* tcl.h:952:3 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo1 = struct {
	isNativeObjectProc int32
	_                  [4]byte
	objProc            uintptr
	objClientData      ClientData
	proc               uintptr
	clientData         ClientData
	deleteProc         uintptr
	deleteData         ClientData
	namespacePtr       uintptr
} /* tcl.h:969:9 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo = Tcl_CmdInfo1 /* tcl.h:988:3 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString1 = struct {
	string      uintptr
	length      int32
	spaceAvl    int32
	staticSpace [200]int8
} /* tcl.h:998:9 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString = Tcl_DString1 /* tcl.h:1008:3 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType1 = struct {
	version         int32
	flags           int32
	hashKeyProc     uintptr
	compareKeysProc uintptr
	allocEntryProc  uintptr
	freeEntryProc   uintptr
} /* tcl.h:1167:9 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType = Tcl_HashKeyType1 /* tcl.h:1167:32 */
type Tcl_HashTable1 = struct {
	buckets       uintptr
	staticBuckets [4]uintptr
	numBuckets    int32
	numEntries    int32
	rebuildSize   int32
	downShift     int32
	mask          int32
	keyType       int32
	findProc      uintptr
	createProc    uintptr
	typePtr       uintptr
} /* tcl.h:1168:9 */

type Tcl_HashTable = Tcl_HashTable1 /* tcl.h:1168:30 */
type Tcl_HashEntry1 = struct {
	nextPtr    uintptr
	tablePtr   uintptr
	hash       uintptr
	clientData ClientData
	key        struct{ oneWordValue uintptr }
} /* tcl.h:1168:9 */

type Tcl_HashEntry = Tcl_HashEntry1 /* tcl.h:1169:30 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch1 = struct {
	tablePtr     uintptr
	nextIndex    int32
	_            [4]byte
	nextEntryPtr uintptr
} /* tcl.h:1323:9 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch = Tcl_HashSearch1 /* tcl.h:1329:3 */

// Acceptable key types for hash tables:
//
// TCL_STRING_KEYS:		The keys are strings, they are copied into the
//				entry.
// TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
//				in the entry.
// TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
//				into the entry.
// TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
//				pointer is stored in the entry.
//
// While maintaining binary compatibility the above have to be distinct values
// as they are used to differentiate between old versions of the hash table
// which don't have a typePtr and new ones which do. Once binary compatibility
// is discarded in favour of making more wide spread changes TCL_STRING_KEYS
// can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the
// same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is
// accessed from the entry and not the behaviour.

// Structure definition for information used to keep track of searches through
// dictionaries. These fields should not be accessed by code outside
// tclDictObj.c

type Tcl_DictSearch = struct {
	next          uintptr
	epoch         int32
	_             [4]byte
	dictionaryPtr Tcl_Dict
} /* tcl.h:1369:3 */

// Positions to pass to Tcl_QueueEvent:

type Tcl_QueuePosition = uint32 /* tcl.h:1404:3 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time1 = struct {
	sec  int64
	usec int64
} /* tcl.h:1420:9 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time = Tcl_Time1 /* tcl.h:1423:3 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType1 = struct {
	typeName         uintptr
	version          Tcl_ChannelTypeVersion
	closeProc        uintptr
	inputProc        uintptr
	outputProc       uintptr
	seekProc         uintptr
	setOptionProc    uintptr
	getOptionProc    uintptr
	watchProc        uintptr
	getHandleProc    uintptr
	close2Proc       uintptr
	blockModeProc    uintptr
	flushProc        uintptr
	handlerProc      uintptr
	wideSeekProc     uintptr
	threadActionProc uintptr
	truncateProc     uintptr
} /* tcl.h:1539:9 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType = Tcl_ChannelType1 /* tcl.h:1607:3 */

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

type Tcl_PathType = uint32 /* tcl.h:1628:3 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData1 = struct {
	__type     int32
	perm       int32
	macType    uintptr
	macCreator uintptr
} /* tcl.h:1635:9 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData = Tcl_GlobTypeData1 /* tcl.h:1640:3 */
// We have to declare the utime structure here.
type utimbuf = struct {
	actime  time_t
	modtime time_t
} /* utime.h:46:1 */

type Tcl_FSVersion = uintptr /* tcl.h:1715:31 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together the functions that form the interface for a particulr the
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem1 = struct {
	typeName                 uintptr
	structureLength          int32
	_                        [4]byte
	version                  Tcl_FSVersion
	pathInFilesystemProc     uintptr
	dupInternalRepProc       uintptr
	freeInternalRepProc      uintptr
	internalToNormalizedProc uintptr
	createInternalRepProc    uintptr
	normalizePathProc        uintptr
	filesystemPathTypeProc   uintptr
	filesystemSeparatorProc  uintptr
	statProc                 uintptr
	accessProc               uintptr
	openFileChannelProc      uintptr
	matchInDirectoryProc     uintptr
	utimeProc                uintptr
	linkProc                 uintptr
	listVolumesProc          uintptr
	fileAttrStringsProc      uintptr
	fileAttrsGetProc         uintptr
	fileAttrsSetProc         uintptr
	createDirectoryProc      uintptr
	removeDirectoryProc      uintptr
	deleteFileProc           uintptr
	copyFileProc             uintptr
	renameFileProc           uintptr
	copyDirectoryProc        uintptr
	lstatProc                uintptr
	loadFileProc             uintptr
	getCwdProc               uintptr
	chdirProc                uintptr
} /* tcl.h:1741:9 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together the functions that form the interface for a particulr the
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem = Tcl_Filesystem1 /* tcl.h:1860:3 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs1 = struct {
	setTimerProc          uintptr
	waitForEventProc      uintptr
	createFileHandlerProc uintptr
	deleteFileHandlerProc uintptr
	initNotifierProc      uintptr
	finalizeNotifierProc  uintptr
	alertNotifierProc     uintptr
	serviceModeHookProc   uintptr
} /* tcl.h:1881:9 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs = Tcl_NotifierProcs1 /* tcl.h:1890:3 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token1 = struct {
	__type        int32
	_             [4]byte
	start         uintptr
	size          int32
	numComponents int32
} /* tcl.h:1901:9 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token = Tcl_Token1 /* tcl.h:1911:3 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse1 = struct {
	commentStart    uintptr
	commentSize     int32
	_               [4]byte
	commandStart    uintptr
	commandSize     int32
	numWords        int32
	tokenPtr        uintptr
	numTokens       int32
	tokensAvailable int32
	errorType       int32
	_               [4]byte
	string          uintptr
	end             uintptr
	interp          uintptr
	term            uintptr
	incomplete      int32
	_               [4]byte
	staticTokens    [20]Tcl_Token
} /* tcl.h:2017:9 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse = Tcl_Parse1 /* tcl.h:2070:3 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType1 = struct {
	encodingName uintptr
	toUtfProc    uintptr
	fromUtfProc  uintptr
	freeProc     uintptr
	clientData   ClientData
	nullSize     int32
	_            [4]byte
} /* tcl.h:2078:9 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType = Tcl_EncodingType1 /* tcl.h:2098:3 */

// The following definitions are used as values for the conversion control
// flags argument when converting text from one character set to another:
//
// TCL_ENCODING_START -		Signifies that the source buffer is the first
//				block in a (potentially multi-block) input
//				stream. Tells the conversion function to reset
//				to an initial state and perform any
//				initialization that needs to occur before the
//				first byte is converted. If the source buffer
//				contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_END -		Signifies that the source buffer is the last
//				block in a (potentially multi-block) input
//				stream. Tells the conversion routine to
//				perform any finalization that needs to occur
//				after the last byte is converted and then to
//				reset to an initial state. If the source
//				buffer contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_STOPONERROR -	If set, the converter returns immediately upon
//				encountering an invalid byte sequence or a
//				source character that has no mapping in the
//				target encoding. If clear, the converter
//				substitues the problematic character(s) with
//				one or more "close" characters in the
//				destination buffer and then continues to
//				convert the source.
// TCL_ENCODING_NO_TERMINATE - 	If set, Tcl_ExternalToUtf does not append a
//				terminating NUL byte.  Since it does not need
//				an extra byte for a terminating NUL, it fills
//				all dstLen bytes with encoded UTF-8 content if
//				needed.  If clear, a byte is reserved in the
//				dst space for NUL termination, and a
//				terminating NUL is appended.
// TCL_ENCODING_CHAR_LIMIT -	If set and dstCharsPtr is not NULL, then
//				Tcl_ExternalToUtf takes the initial value of
//				*dstCharsPtr as a limit of the maximum number
//				of chars to produce in the encoded UTF-8
//				content.  Otherwise, the number of chars
//				produced is controlled only by other limiting
//				factors.

// The following definitions are the error codes returned by the conversion
// routines:
//
// TCL_OK -			All characters were converted.
// TCL_CONVERT_NOSPACE -	The output buffer would not have been large
//				enough for all of the converted data; as many
//				characters as could fit were converted though.
// TCL_CONVERT_MULTIBYTE -	The last few bytes in the source string were
//				the beginning of a multibyte sequence, but
//				more bytes were needed to complete this
//				sequence. A subsequent call to the conversion
//				routine should pass the beginning of this
//				unconverted sequence plus additional bytes
//				from the source stream to properly convert the
//				formerly split-up multibyte sequence.
// TCL_CONVERT_SYNTAX -		The source stream contained an invalid
//				character sequence. This may occur if the
//				input stream has been damaged or if the input
//				encoding method was misidentified. This error
//				is reported only if TCL_ENCODING_STOPONERROR
//				was specified.
// TCL_CONVERT_UNKNOWN -	The source string contained a character that
//				could not be represented in the target
//				encoding. This error is reported only if
//				TCL_ENCODING_STOPONERROR was specified.

// The maximum number of bytes that are necessary to represent a single
// Unicode character in UTF-8. The valid values should be 3, 4 or 6
// (or perhaps 1 if we want to support a non-unicode enabled core). If 3 or
// 4, then Tcl_UniChar must be 2-bytes in size (UCS-2) (the default). If 6,
// then Tcl_UniChar must be 4-bytes in size (UCS-4). At this time UCS-2 mode
// is the default and recommended mode. UCS-4 is experimental and not
// recommended. It works for the core, but most extensions expect UCS-2.

// This represents a Unicode character. Any changes to this should also be
// reflected in regcustom.h.

type Tcl_UniChar = uint16 /* tcl.h:2212:24 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config1 = struct {
	key   uintptr
	value uintptr
} /* tcl.h:2221:9 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config = Tcl_Config1 /* tcl.h:2226:3 */

//----------------------------------------------------------------------------
// Override definitions for libtommath.

type mp_int1 = struct {
	used  int32
	alloc int32
	sign  mp_sign
	_     [4]byte
	dp    uintptr
} /* tcl.h:2250:9 */

type mp_digit = uint32 /* tcl.h:2252:22 */

//----------------------------------------------------------------------------
// Definitions needed for Tcl_ParseArgvObj routines.
// Based on tkArgv.c.
// Modifications from the original are copyright (c) Sam Bromley 2006

type Tcl_ArgvInfo = struct {
	__type     int32
	_          [4]byte
	keyStr     uintptr
	srcPtr     uintptr
	dstPtr     uintptr
	helpStr    uintptr
	clientData ClientData
} /* tcl.h:2273:3 */

type TclPlatStubs1 = struct {
	magic int32
	_     [4]byte
	hooks uintptr
} /* tclDecls.h:1851:11 */

type TclIntStubs1 = struct {
	magic                        int32
	_                            [4]byte
	hooks                        uintptr
	reserved0                    uintptr
	reserved1                    uintptr
	reserved2                    uintptr
	tclAllocateFreeObjects       uintptr
	reserved4                    uintptr
	tclCleanupChildren           uintptr
	tclCleanupCommand            uintptr
	tclCopyAndCollapse           uintptr
	tclCopyChannelOld            uintptr
	tclCreatePipeline            uintptr
	tclCreateProc                uintptr
	tclDeleteCompiledLocalVars   uintptr
	tclDeleteVars                uintptr
	reserved13                   uintptr
	tclDumpMemoryInfo            uintptr
	reserved15                   uintptr
	tclExprFloatError            uintptr
	reserved17                   uintptr
	reserved18                   uintptr
	reserved19                   uintptr
	reserved20                   uintptr
	reserved21                   uintptr
	tclFindElement               uintptr
	tclFindProc                  uintptr
	tclFormatInt                 uintptr
	tclFreePackageInfo           uintptr
	reserved26                   uintptr
	reserved27                   uintptr
	tclpGetDefaultStdChannel     uintptr
	reserved29                   uintptr
	reserved30                   uintptr
	tclGetExtension              uintptr
	tclGetFrame                  uintptr
	reserved33                   uintptr
	tclGetIntForIndex            uintptr
	reserved35                   uintptr
	reserved36                   uintptr
	tclGetLoadedPackages         uintptr
	tclGetNamespaceForQualName   uintptr
	tclGetObjInterpProc          uintptr
	tclGetOpenMode               uintptr
	tclGetOriginalCommand        uintptr
	tclpGetUserHome              uintptr
	reserved43                   uintptr
	tclGuessPackageName          uintptr
	tclHideUnsafeCommands        uintptr
	tclInExit                    uintptr
	reserved47                   uintptr
	reserved48                   uintptr
	reserved49                   uintptr
	tclInitCompiledLocals        uintptr
	tclInterpInit                uintptr
	reserved52                   uintptr
	tclInvokeObjectCommand       uintptr
	tclInvokeStringCommand       uintptr
	tclIsProc                    uintptr
	reserved56                   uintptr
	reserved57                   uintptr
	tclLookupVar                 uintptr
	reserved59                   uintptr
	tclNeedSpace                 uintptr
	tclNewProcBodyObj            uintptr
	tclObjCommandComplete        uintptr
	tclObjInterpProc             uintptr
	tclObjInvoke                 uintptr
	reserved65                   uintptr
	reserved66                   uintptr
	reserved67                   uintptr
	reserved68                   uintptr
	tclpAlloc                    uintptr
	reserved70                   uintptr
	reserved71                   uintptr
	reserved72                   uintptr
	reserved73                   uintptr
	tclpFree                     uintptr
	tclpGetClicks                uintptr
	tclpGetSeconds               uintptr
	tclpGetTime                  uintptr
	reserved78                   uintptr
	reserved79                   uintptr
	reserved80                   uintptr
	tclpRealloc                  uintptr
	reserved82                   uintptr
	reserved83                   uintptr
	reserved84                   uintptr
	reserved85                   uintptr
	reserved86                   uintptr
	reserved87                   uintptr
	tclPrecTraceProc             uintptr
	tclPreventAliasLoop          uintptr
	reserved90                   uintptr
	tclProcCleanupProc           uintptr
	tclProcCompileProc           uintptr
	tclProcDeleteProc            uintptr
	reserved94                   uintptr
	reserved95                   uintptr
	tclRenameCommand             uintptr
	tclResetShadowedCmdRefs      uintptr
	tclServiceIdle               uintptr
	reserved99                   uintptr
	reserved100                  uintptr
	tclSetPreInitScript          uintptr
	tclSetupEnv                  uintptr
	tclSockGetPort               uintptr
	tclSockMinimumBuffersOld     uintptr
	reserved105                  uintptr
	reserved106                  uintptr
	reserved107                  uintptr
	tclTeardownNamespace         uintptr
	tclUpdateReturnInfo          uintptr
	tclSockMinimumBuffers        uintptr
	tcl_AddInterpResolvers       uintptr
	tcl_AppendExportList         uintptr
	tcl_CreateNamespace          uintptr
	tcl_DeleteNamespace          uintptr
	tcl_Export                   uintptr
	tcl_FindCommand              uintptr
	tcl_FindNamespace            uintptr
	tcl_GetInterpResolvers       uintptr
	tcl_GetNamespaceResolvers    uintptr
	tcl_FindNamespaceVar         uintptr
	tcl_ForgetImport             uintptr
	tcl_GetCommandFromObj        uintptr
	tcl_GetCommandFullName       uintptr
	tcl_GetCurrentNamespace      uintptr
	tcl_GetGlobalNamespace       uintptr
	tcl_GetVariableFullName      uintptr
	tcl_Import                   uintptr
	tcl_PopCallFrame             uintptr
	tcl_PushCallFrame            uintptr
	tcl_RemoveInterpResolvers    uintptr
	tcl_SetNamespaceResolvers    uintptr
	tclpHasSockets               uintptr
	tclpGetDate                  uintptr
	reserved134                  uintptr
	reserved135                  uintptr
	reserved136                  uintptr
	reserved137                  uintptr
	tclGetEnv                    uintptr
	reserved139                  uintptr
	reserved140                  uintptr
	tclpGetCwd                   uintptr
	tclSetByteCodeFromAny        uintptr
	tclAddLiteralObj             uintptr
	tclHideLiteral               uintptr
	tclGetAuxDataType            uintptr
	tclHandleCreate              uintptr
	tclHandleFree                uintptr
	tclHandlePreserve            uintptr
	tclHandleRelease             uintptr
	tclRegAbout                  uintptr
	tclRegExpRangeUniChar        uintptr
	tclSetLibraryPath            uintptr
	tclGetLibraryPath            uintptr
	reserved154                  uintptr
	reserved155                  uintptr
	tclRegError                  uintptr
	tclVarTraceExists            uintptr
	tclSetStartupScriptFileName  uintptr
	tclGetStartupScriptFileName  uintptr
	reserved160                  uintptr
	tclChannelTransform          uintptr
	tclChannelEventScriptInvoker uintptr
	tclGetInstructionTable       uintptr
	tclExpandCodeArray           uintptr
	tclpSetInitialEncodings      uintptr
	tclListObjSetElement         uintptr
	tclSetStartupScriptPath      uintptr
	tclGetStartupScriptPath      uintptr
	tclpUtfNcmp2                 uintptr
	tclCheckInterpTraces         uintptr
	tclCheckExecutionTraces      uintptr
	tclInThreadExit              uintptr
	tclUniCharMatch              uintptr
	reserved174                  uintptr
	tclCallVarTraces             uintptr
	tclCleanupVar                uintptr
	tclVarErrMsg                 uintptr
	tcl_SetStartupScript         uintptr
	tcl_GetStartupScript         uintptr
	reserved180                  uintptr
	reserved181                  uintptr
	tclpLocaltime                uintptr
	tclpGmtime                   uintptr
	reserved184                  uintptr
	reserved185                  uintptr
	reserved186                  uintptr
	reserved187                  uintptr
	reserved188                  uintptr
	reserved189                  uintptr
	reserved190                  uintptr
	reserved191                  uintptr
	reserved192                  uintptr
	reserved193                  uintptr
	reserved194                  uintptr
	reserved195                  uintptr
	reserved196                  uintptr
	reserved197                  uintptr
	tclObjGetFrame               uintptr
	reserved199                  uintptr
	tclpObjRemoveDirectory       uintptr
	tclpObjCopyDirectory         uintptr
	tclpObjCreateDirectory       uintptr
	tclpObjDeleteFile            uintptr
	tclpObjCopyFile              uintptr
	tclpObjRenameFile            uintptr
	tclpObjStat                  uintptr
	tclpObjAccess                uintptr
	tclpOpenFileChannel          uintptr
	reserved209                  uintptr
	reserved210                  uintptr
	reserved211                  uintptr
	tclpFindExecutable           uintptr
	tclGetObjNameOfExecutable    uintptr
	tclSetObjNameOfExecutable    uintptr
	tclStackAlloc                uintptr
	tclStackFree                 uintptr
	tclPushStackFrame            uintptr
	tclPopStackFrame             uintptr
	reserved219                  uintptr
	reserved220                  uintptr
	reserved221                  uintptr
	reserved222                  uintptr
	reserved223                  uintptr
	tclGetPlatform               uintptr
	tclTraceDictPath             uintptr
	tclObjBeingDeleted           uintptr
	tclSetNsPath                 uintptr
	reserved228                  uintptr
	tclPtrMakeUpvar              uintptr
	tclObjLookupVar              uintptr
	tclGetNamespaceFromObj       uintptr
	tclEvalObjEx                 uintptr
	tclGetSrcInfoForPc           uintptr
	tclVarHashCreateVar          uintptr
	tclInitVarHashTable          uintptr
	tclBackgroundException       uintptr
	tclResetCancellation         uintptr
	tclNRInterpProc              uintptr
	tclNRInterpProcCore          uintptr
	tclNRRunCallbacks            uintptr
	tclNREvalObjEx               uintptr
	tclNREvalObjv                uintptr
	tclDbDumpActiveObjects       uintptr
	tclGetNamespaceChildTable    uintptr
	tclGetNamespaceCommandTable  uintptr
	tclInitRewriteEnsemble       uintptr
	tclResetRewriteEnsemble      uintptr
	tclCopyChannel               uintptr
	tclDoubleDigits              uintptr
	tclSetSlaveCancelFlags       uintptr
	tclRegisterLiteral           uintptr
	tclPtrGetVar                 uintptr
	tclPtrSetVar                 uintptr
	tclPtrIncrObjVar             uintptr
	tclPtrObjMakeUpvar           uintptr
	tclPtrUnsetVar               uintptr
	tclStaticPackage             uintptr
	reserved258                  uintptr
	reserved259                  uintptr
	tclUnusedStubEntry           uintptr
} /* tclDecls.h:1852:11 */

type TclIntPlatStubs1 = struct {
	magic                           int32
	_                               [4]byte
	hooks                           uintptr
	tclGetAndDetachPids             uintptr
	tclpCloseFile                   uintptr
	tclpCreateCommandChannel        uintptr
	tclpCreatePipe                  uintptr
	tclpCreateProcess               uintptr
	tclUnixWaitForFile_             uintptr
	tclpMakeFile                    uintptr
	tclpOpenFile                    uintptr
	tclUnixWaitForFile              uintptr
	tclpCreateTempFile              uintptr
	tclpReaddir                     uintptr
	tclpLocaltime_unix              uintptr
	tclpGmtime_unix                 uintptr
	tclpInetNtoa                    uintptr
	tclUnixCopyFile                 uintptr
	tclMacOSXGetFileAttribute       uintptr
	tclMacOSXSetFileAttribute       uintptr
	tclMacOSXCopyFileAttributes     uintptr
	tclMacOSXMatchType              uintptr
	tclMacOSXNotifierAddRunLoopMode uintptr
	reserved20                      uintptr
	reserved21                      uintptr
	tclpCreateTempFile_             uintptr
	reserved23                      uintptr
	reserved24                      uintptr
	reserved25                      uintptr
	reserved26                      uintptr
	reserved27                      uintptr
	reserved28                      uintptr
	tclWinCPUID                     uintptr
	tclUnixOpenTemporaryFile        uintptr
} /* tclDecls.h:1853:11 */

type TclStubHooks = struct {
	tclPlatStubs    uintptr
	tclIntStubs     uintptr
	tclIntPlatStubs uintptr
} /* tclDecls.h:1854:3 */

type TclStubs1 = struct {
	magic                                  int32
	_                                      [4]byte
	hooks                                  uintptr
	tcl_PkgProvideEx                       uintptr
	tcl_PkgRequireEx                       uintptr
	tcl_Panic                              uintptr
	tcl_Alloc                              uintptr
	tcl_Free                               uintptr
	tcl_Realloc                            uintptr
	tcl_DbCkalloc                          uintptr
	tcl_DbCkfree                           uintptr
	tcl_DbCkrealloc                        uintptr
	tcl_CreateFileHandler                  uintptr
	tcl_DeleteFileHandler                  uintptr
	tcl_SetTimer                           uintptr
	tcl_Sleep                              uintptr
	tcl_WaitForEvent                       uintptr
	tcl_AppendAllObjTypes                  uintptr
	tcl_AppendStringsToObj                 uintptr
	tcl_AppendToObj                        uintptr
	tcl_ConcatObj                          uintptr
	tcl_ConvertToType                      uintptr
	tcl_DbDecrRefCount                     uintptr
	tcl_DbIncrRefCount                     uintptr
	tcl_DbIsShared                         uintptr
	tcl_DbNewBooleanObj                    uintptr
	tcl_DbNewByteArrayObj                  uintptr
	tcl_DbNewDoubleObj                     uintptr
	tcl_DbNewListObj                       uintptr
	tcl_DbNewLongObj                       uintptr
	tcl_DbNewObj                           uintptr
	tcl_DbNewStringObj                     uintptr
	tcl_DuplicateObj                       uintptr
	tclFreeObj                             uintptr
	tcl_GetBoolean                         uintptr
	tcl_GetBooleanFromObj                  uintptr
	tcl_GetByteArrayFromObj                uintptr
	tcl_GetDouble                          uintptr
	tcl_GetDoubleFromObj                   uintptr
	tcl_GetIndexFromObj                    uintptr
	tcl_GetInt                             uintptr
	tcl_GetIntFromObj                      uintptr
	tcl_GetLongFromObj                     uintptr
	tcl_GetObjType                         uintptr
	tcl_GetStringFromObj                   uintptr
	tcl_InvalidateStringRep                uintptr
	tcl_ListObjAppendList                  uintptr
	tcl_ListObjAppendElement               uintptr
	tcl_ListObjGetElements                 uintptr
	tcl_ListObjIndex                       uintptr
	tcl_ListObjLength                      uintptr
	tcl_ListObjReplace                     uintptr
	tcl_NewBooleanObj                      uintptr
	tcl_NewByteArrayObj                    uintptr
	tcl_NewDoubleObj                       uintptr
	tcl_NewIntObj                          uintptr
	tcl_NewListObj                         uintptr
	tcl_NewLongObj                         uintptr
	tcl_NewObj                             uintptr
	tcl_NewStringObj                       uintptr
	tcl_SetBooleanObj                      uintptr
	tcl_SetByteArrayLength                 uintptr
	tcl_SetByteArrayObj                    uintptr
	tcl_SetDoubleObj                       uintptr
	tcl_SetIntObj                          uintptr
	tcl_SetListObj                         uintptr
	tcl_SetLongObj                         uintptr
	tcl_SetObjLength                       uintptr
	tcl_SetStringObj                       uintptr
	tcl_AddErrorInfo                       uintptr
	tcl_AddObjErrorInfo                    uintptr
	tcl_AllowExceptions                    uintptr
	tcl_AppendElement                      uintptr
	tcl_AppendResult                       uintptr
	tcl_AsyncCreate                        uintptr
	tcl_AsyncDelete                        uintptr
	tcl_AsyncInvoke                        uintptr
	tcl_AsyncMark                          uintptr
	tcl_AsyncReady                         uintptr
	tcl_BackgroundError                    uintptr
	tcl_Backslash                          uintptr
	tcl_BadChannelOption                   uintptr
	tcl_CallWhenDeleted                    uintptr
	tcl_CancelIdleCall                     uintptr
	tcl_Close                              uintptr
	tcl_CommandComplete                    uintptr
	tcl_Concat                             uintptr
	tcl_ConvertElement                     uintptr
	tcl_ConvertCountedElement              uintptr
	tcl_CreateAlias                        uintptr
	tcl_CreateAliasObj                     uintptr
	tcl_CreateChannel                      uintptr
	tcl_CreateChannelHandler               uintptr
	tcl_CreateCloseHandler                 uintptr
	tcl_CreateCommand                      uintptr
	tcl_CreateEventSource                  uintptr
	tcl_CreateExitHandler                  uintptr
	tcl_CreateInterp                       uintptr
	tcl_CreateMathFunc                     uintptr
	tcl_CreateObjCommand                   uintptr
	tcl_CreateSlave                        uintptr
	tcl_CreateTimerHandler                 uintptr
	tcl_CreateTrace                        uintptr
	tcl_DeleteAssocData                    uintptr
	tcl_DeleteChannelHandler               uintptr
	tcl_DeleteCloseHandler                 uintptr
	tcl_DeleteCommand                      uintptr
	tcl_DeleteCommandFromToken             uintptr
	tcl_DeleteEvents                       uintptr
	tcl_DeleteEventSource                  uintptr
	tcl_DeleteExitHandler                  uintptr
	tcl_DeleteHashEntry                    uintptr
	tcl_DeleteHashTable                    uintptr
	tcl_DeleteInterp                       uintptr
	tcl_DetachPids                         uintptr
	tcl_DeleteTimerHandler                 uintptr
	tcl_DeleteTrace                        uintptr
	tcl_DontCallWhenDeleted                uintptr
	tcl_DoOneEvent                         uintptr
	tcl_DoWhenIdle                         uintptr
	tcl_DStringAppend                      uintptr
	tcl_DStringAppendElement               uintptr
	tcl_DStringEndSublist                  uintptr
	tcl_DStringFree                        uintptr
	tcl_DStringGetResult                   uintptr
	tcl_DStringInit                        uintptr
	tcl_DStringResult                      uintptr
	tcl_DStringSetLength                   uintptr
	tcl_DStringStartSublist                uintptr
	tcl_Eof                                uintptr
	tcl_ErrnoId                            uintptr
	tcl_ErrnoMsg                           uintptr
	tcl_Eval                               uintptr
	tcl_EvalFile                           uintptr
	tcl_EvalObj                            uintptr
	tcl_EventuallyFree                     uintptr
	tcl_Exit                               uintptr
	tcl_ExposeCommand                      uintptr
	tcl_ExprBoolean                        uintptr
	tcl_ExprBooleanObj                     uintptr
	tcl_ExprDouble                         uintptr
	tcl_ExprDoubleObj                      uintptr
	tcl_ExprLong                           uintptr
	tcl_ExprLongObj                        uintptr
	tcl_ExprObj                            uintptr
	tcl_ExprString                         uintptr
	tcl_Finalize                           uintptr
	tcl_FindExecutable                     uintptr
	tcl_FirstHashEntry                     uintptr
	tcl_Flush                              uintptr
	tcl_FreeResult                         uintptr
	tcl_GetAlias                           uintptr
	tcl_GetAliasObj                        uintptr
	tcl_GetAssocData                       uintptr
	tcl_GetChannel                         uintptr
	tcl_GetChannelBufferSize               uintptr
	tcl_GetChannelHandle                   uintptr
	tcl_GetChannelInstanceData             uintptr
	tcl_GetChannelMode                     uintptr
	tcl_GetChannelName                     uintptr
	tcl_GetChannelOption                   uintptr
	tcl_GetChannelType                     uintptr
	tcl_GetCommandInfo                     uintptr
	tcl_GetCommandName                     uintptr
	tcl_GetErrno                           uintptr
	tcl_GetHostName                        uintptr
	tcl_GetInterpPath                      uintptr
	tcl_GetMaster                          uintptr
	tcl_GetNameOfExecutable                uintptr
	tcl_GetObjResult                       uintptr
	tcl_GetOpenFile                        uintptr
	tcl_GetPathType                        uintptr
	tcl_Gets                               uintptr
	tcl_GetsObj                            uintptr
	tcl_GetServiceMode                     uintptr
	tcl_GetSlave                           uintptr
	tcl_GetStdChannel                      uintptr
	tcl_GetStringResult                    uintptr
	tcl_GetVar                             uintptr
	tcl_GetVar2                            uintptr
	tcl_GlobalEval                         uintptr
	tcl_GlobalEvalObj                      uintptr
	tcl_HideCommand                        uintptr
	tcl_Init                               uintptr
	tcl_InitHashTable                      uintptr
	tcl_InputBlocked                       uintptr
	tcl_InputBuffered                      uintptr
	tcl_InterpDeleted                      uintptr
	tcl_IsSafe                             uintptr
	tcl_JoinPath                           uintptr
	tcl_LinkVar                            uintptr
	reserved188                            uintptr
	tcl_MakeFileChannel                    uintptr
	tcl_MakeSafe                           uintptr
	tcl_MakeTcpClientChannel               uintptr
	tcl_Merge                              uintptr
	tcl_NextHashEntry                      uintptr
	tcl_NotifyChannel                      uintptr
	tcl_ObjGetVar2                         uintptr
	tcl_ObjSetVar2                         uintptr
	tcl_OpenCommandChannel                 uintptr
	tcl_OpenFileChannel                    uintptr
	tcl_OpenTcpClient                      uintptr
	tcl_OpenTcpServer                      uintptr
	tcl_Preserve                           uintptr
	tcl_PrintDouble                        uintptr
	tcl_PutEnv                             uintptr
	tcl_PosixError                         uintptr
	tcl_QueueEvent                         uintptr
	tcl_Read                               uintptr
	tcl_ReapDetachedProcs                  uintptr
	tcl_RecordAndEval                      uintptr
	tcl_RecordAndEvalObj                   uintptr
	tcl_RegisterChannel                    uintptr
	tcl_RegisterObjType                    uintptr
	tcl_RegExpCompile                      uintptr
	tcl_RegExpExec                         uintptr
	tcl_RegExpMatch                        uintptr
	tcl_RegExpRange                        uintptr
	tcl_Release                            uintptr
	tcl_ResetResult                        uintptr
	tcl_ScanElement                        uintptr
	tcl_ScanCountedElement                 uintptr
	tcl_SeekOld                            uintptr
	tcl_ServiceAll                         uintptr
	tcl_ServiceEvent                       uintptr
	tcl_SetAssocData                       uintptr
	tcl_SetChannelBufferSize               uintptr
	tcl_SetChannelOption                   uintptr
	tcl_SetCommandInfo                     uintptr
	tcl_SetErrno                           uintptr
	tcl_SetErrorCode                       uintptr
	tcl_SetMaxBlockTime                    uintptr
	tcl_SetPanicProc                       uintptr
	tcl_SetRecursionLimit                  uintptr
	tcl_SetResult                          uintptr
	tcl_SetServiceMode                     uintptr
	tcl_SetObjErrorCode                    uintptr
	tcl_SetObjResult                       uintptr
	tcl_SetStdChannel                      uintptr
	tcl_SetVar                             uintptr
	tcl_SetVar2                            uintptr
	tcl_SignalId                           uintptr
	tcl_SignalMsg                          uintptr
	tcl_SourceRCFile                       uintptr
	tcl_SplitList                          uintptr
	tcl_SplitPath                          uintptr
	tcl_StaticPackage                      uintptr
	tcl_StringMatch                        uintptr
	tcl_TellOld                            uintptr
	tcl_TraceVar                           uintptr
	tcl_TraceVar2                          uintptr
	tcl_TranslateFileName                  uintptr
	tcl_Ungets                             uintptr
	tcl_UnlinkVar                          uintptr
	tcl_UnregisterChannel                  uintptr
	tcl_UnsetVar                           uintptr
	tcl_UnsetVar2                          uintptr
	tcl_UntraceVar                         uintptr
	tcl_UntraceVar2                        uintptr
	tcl_UpdateLinkedVar                    uintptr
	tcl_UpVar                              uintptr
	tcl_UpVar2                             uintptr
	tcl_VarEval                            uintptr
	tcl_VarTraceInfo                       uintptr
	tcl_VarTraceInfo2                      uintptr
	tcl_Write                              uintptr
	tcl_WrongNumArgs                       uintptr
	tcl_DumpActiveMemory                   uintptr
	tcl_ValidateAllMemory                  uintptr
	tcl_AppendResultVA                     uintptr
	tcl_AppendStringsToObjVA               uintptr
	tcl_HashStats                          uintptr
	tcl_ParseVar                           uintptr
	tcl_PkgPresent                         uintptr
	tcl_PkgPresentEx                       uintptr
	tcl_PkgProvide                         uintptr
	tcl_PkgRequire                         uintptr
	tcl_SetErrorCodeVA                     uintptr
	tcl_VarEvalVA                          uintptr
	tcl_WaitPid                            uintptr
	tcl_PanicVA                            uintptr
	tcl_GetVersion                         uintptr
	tcl_InitMemory                         uintptr
	tcl_StackChannel                       uintptr
	tcl_UnstackChannel                     uintptr
	tcl_GetStackedChannel                  uintptr
	tcl_SetMainLoop                        uintptr
	reserved285                            uintptr
	tcl_AppendObjToObj                     uintptr
	tcl_CreateEncoding                     uintptr
	tcl_CreateThreadExitHandler            uintptr
	tcl_DeleteThreadExitHandler            uintptr
	tcl_DiscardResult                      uintptr
	tcl_EvalEx                             uintptr
	tcl_EvalObjv                           uintptr
	tcl_EvalObjEx                          uintptr
	tcl_ExitThread                         uintptr
	tcl_ExternalToUtf                      uintptr
	tcl_ExternalToUtfDString               uintptr
	tcl_FinalizeThread                     uintptr
	tcl_FinalizeNotifier                   uintptr
	tcl_FreeEncoding                       uintptr
	tcl_GetCurrentThread                   uintptr
	tcl_GetEncoding                        uintptr
	tcl_GetEncodingName                    uintptr
	tcl_GetEncodingNames                   uintptr
	tcl_GetIndexFromObjStruct              uintptr
	tcl_GetThreadData                      uintptr
	tcl_GetVar2Ex                          uintptr
	tcl_InitNotifier                       uintptr
	tcl_MutexLock                          uintptr
	tcl_MutexUnlock                        uintptr
	tcl_ConditionNotify                    uintptr
	tcl_ConditionWait                      uintptr
	tcl_NumUtfChars                        uintptr
	tcl_ReadChars                          uintptr
	tcl_RestoreResult                      uintptr
	tcl_SaveResult                         uintptr
	tcl_SetSystemEncoding                  uintptr
	tcl_SetVar2Ex                          uintptr
	tcl_ThreadAlert                        uintptr
	tcl_ThreadQueueEvent                   uintptr
	tcl_UniCharAtIndex                     uintptr
	tcl_UniCharToLower                     uintptr
	tcl_UniCharToTitle                     uintptr
	tcl_UniCharToUpper                     uintptr
	tcl_UniCharToUtf                       uintptr
	tcl_UtfAtIndex                         uintptr
	tcl_UtfCharComplete                    uintptr
	tcl_UtfBackslash                       uintptr
	tcl_UtfFindFirst                       uintptr
	tcl_UtfFindLast                        uintptr
	tcl_UtfNext                            uintptr
	tcl_UtfPrev                            uintptr
	tcl_UtfToExternal                      uintptr
	tcl_UtfToExternalDString               uintptr
	tcl_UtfToLower                         uintptr
	tcl_UtfToTitle                         uintptr
	tcl_UtfToUniChar                       uintptr
	tcl_UtfToUpper                         uintptr
	tcl_WriteChars                         uintptr
	tcl_WriteObj                           uintptr
	tcl_GetString                          uintptr
	tcl_GetDefaultEncodingDir              uintptr
	tcl_SetDefaultEncodingDir              uintptr
	tcl_AlertNotifier                      uintptr
	tcl_ServiceModeHook                    uintptr
	tcl_UniCharIsAlnum                     uintptr
	tcl_UniCharIsAlpha                     uintptr
	tcl_UniCharIsDigit                     uintptr
	tcl_UniCharIsLower                     uintptr
	tcl_UniCharIsSpace                     uintptr
	tcl_UniCharIsUpper                     uintptr
	tcl_UniCharIsWordChar                  uintptr
	tcl_UniCharLen                         uintptr
	tcl_UniCharNcmp                        uintptr
	tcl_UniCharToUtfDString                uintptr
	tcl_UtfToUniCharDString                uintptr
	tcl_GetRegExpFromObj                   uintptr
	tcl_EvalTokens                         uintptr
	tcl_FreeParse                          uintptr
	tcl_LogCommandInfo                     uintptr
	tcl_ParseBraces                        uintptr
	tcl_ParseCommand                       uintptr
	tcl_ParseExpr                          uintptr
	tcl_ParseQuotedString                  uintptr
	tcl_ParseVarName                       uintptr
	tcl_GetCwd                             uintptr
	tcl_Chdir                              uintptr
	tcl_Access                             uintptr
	tcl_Stat                               uintptr
	tcl_UtfNcmp                            uintptr
	tcl_UtfNcasecmp                        uintptr
	tcl_StringCaseMatch                    uintptr
	tcl_UniCharIsControl                   uintptr
	tcl_UniCharIsGraph                     uintptr
	tcl_UniCharIsPrint                     uintptr
	tcl_UniCharIsPunct                     uintptr
	tcl_RegExpExecObj                      uintptr
	tcl_RegExpGetInfo                      uintptr
	tcl_NewUnicodeObj                      uintptr
	tcl_SetUnicodeObj                      uintptr
	tcl_GetCharLength                      uintptr
	tcl_GetUniChar                         uintptr
	tcl_GetUnicode                         uintptr
	tcl_GetRange                           uintptr
	tcl_AppendUnicodeToObj                 uintptr
	tcl_RegExpMatchObj                     uintptr
	tcl_SetNotifier                        uintptr
	tcl_GetAllocMutex                      uintptr
	tcl_GetChannelNames                    uintptr
	tcl_GetChannelNamesEx                  uintptr
	tcl_ProcObjCmd                         uintptr
	tcl_ConditionFinalize                  uintptr
	tcl_MutexFinalize                      uintptr
	tcl_CreateThread                       uintptr
	tcl_ReadRaw                            uintptr
	tcl_WriteRaw                           uintptr
	tcl_GetTopChannel                      uintptr
	tcl_ChannelBuffered                    uintptr
	tcl_ChannelName                        uintptr
	tcl_ChannelVersion                     uintptr
	tcl_ChannelBlockModeProc               uintptr
	tcl_ChannelCloseProc                   uintptr
	tcl_ChannelClose2Proc                  uintptr
	tcl_ChannelInputProc                   uintptr
	tcl_ChannelOutputProc                  uintptr
	tcl_ChannelSeekProc                    uintptr
	tcl_ChannelSetOptionProc               uintptr
	tcl_ChannelGetOptionProc               uintptr
	tcl_ChannelWatchProc                   uintptr
	tcl_ChannelGetHandleProc               uintptr
	tcl_ChannelFlushProc                   uintptr
	tcl_ChannelHandlerProc                 uintptr
	tcl_JoinThread                         uintptr
	tcl_IsChannelShared                    uintptr
	tcl_IsChannelRegistered                uintptr
	tcl_CutChannel                         uintptr
	tcl_SpliceChannel                      uintptr
	tcl_ClearChannelHandlers               uintptr
	tcl_IsChannelExisting                  uintptr
	tcl_UniCharNcasecmp                    uintptr
	tcl_UniCharCaseMatch                   uintptr
	tcl_FindHashEntry                      uintptr
	tcl_CreateHashEntry                    uintptr
	tcl_InitCustomHashTable                uintptr
	tcl_InitObjHashTable                   uintptr
	tcl_CommandTraceInfo                   uintptr
	tcl_TraceCommand                       uintptr
	tcl_UntraceCommand                     uintptr
	tcl_AttemptAlloc                       uintptr
	tcl_AttemptDbCkalloc                   uintptr
	tcl_AttemptRealloc                     uintptr
	tcl_AttemptDbCkrealloc                 uintptr
	tcl_AttemptSetObjLength                uintptr
	tcl_GetChannelThread                   uintptr
	tcl_GetUnicodeFromObj                  uintptr
	tcl_GetMathFuncInfo                    uintptr
	tcl_ListMathFuncs                      uintptr
	tcl_SubstObj                           uintptr
	tcl_DetachChannel                      uintptr
	tcl_IsStandardChannel                  uintptr
	tcl_FSCopyFile                         uintptr
	tcl_FSCopyDirectory                    uintptr
	tcl_FSCreateDirectory                  uintptr
	tcl_FSDeleteFile                       uintptr
	tcl_FSLoadFile                         uintptr
	tcl_FSMatchInDirectory                 uintptr
	tcl_FSLink                             uintptr
	tcl_FSRemoveDirectory                  uintptr
	tcl_FSRenameFile                       uintptr
	tcl_FSLstat                            uintptr
	tcl_FSUtime                            uintptr
	tcl_FSFileAttrsGet                     uintptr
	tcl_FSFileAttrsSet                     uintptr
	tcl_FSFileAttrStrings                  uintptr
	tcl_FSStat                             uintptr
	tcl_FSAccess                           uintptr
	tcl_FSOpenFileChannel                  uintptr
	tcl_FSGetCwd                           uintptr
	tcl_FSChdir                            uintptr
	tcl_FSConvertToPathType                uintptr
	tcl_FSJoinPath                         uintptr
	tcl_FSSplitPath                        uintptr
	tcl_FSEqualPaths                       uintptr
	tcl_FSGetNormalizedPath                uintptr
	tcl_FSJoinToPath                       uintptr
	tcl_FSGetInternalRep                   uintptr
	tcl_FSGetTranslatedPath                uintptr
	tcl_FSEvalFile                         uintptr
	tcl_FSNewNativePath                    uintptr
	tcl_FSGetNativePath                    uintptr
	tcl_FSFileSystemInfo                   uintptr
	tcl_FSPathSeparator                    uintptr
	tcl_FSListVolumes                      uintptr
	tcl_FSRegister                         uintptr
	tcl_FSUnregister                       uintptr
	tcl_FSData                             uintptr
	tcl_FSGetTranslatedStringPath          uintptr
	tcl_FSGetFileSystemForPath             uintptr
	tcl_FSGetPathType                      uintptr
	tcl_OutputBuffered                     uintptr
	tcl_FSMountsChanged                    uintptr
	tcl_EvalTokensStandard                 uintptr
	tcl_GetTime                            uintptr
	tcl_CreateObjTrace                     uintptr
	tcl_GetCommandInfoFromToken            uintptr
	tcl_SetCommandInfoFromToken            uintptr
	tcl_DbNewWideIntObj                    uintptr
	tcl_GetWideIntFromObj                  uintptr
	tcl_NewWideIntObj                      uintptr
	tcl_SetWideIntObj                      uintptr
	tcl_AllocStatBuf                       uintptr
	tcl_Seek                               uintptr
	tcl_Tell                               uintptr
	tcl_ChannelWideSeekProc                uintptr
	tcl_DictObjPut                         uintptr
	tcl_DictObjGet                         uintptr
	tcl_DictObjRemove                      uintptr
	tcl_DictObjSize                        uintptr
	tcl_DictObjFirst                       uintptr
	tcl_DictObjNext                        uintptr
	tcl_DictObjDone                        uintptr
	tcl_DictObjPutKeyList                  uintptr
	tcl_DictObjRemoveKeyList               uintptr
	tcl_NewDictObj                         uintptr
	tcl_DbNewDictObj                       uintptr
	tcl_RegisterConfig                     uintptr
	tcl_CreateNamespace                    uintptr
	tcl_DeleteNamespace                    uintptr
	tcl_AppendExportList                   uintptr
	tcl_Export                             uintptr
	tcl_Import                             uintptr
	tcl_ForgetImport                       uintptr
	tcl_GetCurrentNamespace                uintptr
	tcl_GetGlobalNamespace                 uintptr
	tcl_FindNamespace                      uintptr
	tcl_FindCommand                        uintptr
	tcl_GetCommandFromObj                  uintptr
	tcl_GetCommandFullName                 uintptr
	tcl_FSEvalFileEx                       uintptr
	tcl_SetExitProc                        uintptr
	tcl_LimitAddHandler                    uintptr
	tcl_LimitRemoveHandler                 uintptr
	tcl_LimitReady                         uintptr
	tcl_LimitCheck                         uintptr
	tcl_LimitExceeded                      uintptr
	tcl_LimitSetCommands                   uintptr
	tcl_LimitSetTime                       uintptr
	tcl_LimitSetGranularity                uintptr
	tcl_LimitTypeEnabled                   uintptr
	tcl_LimitTypeExceeded                  uintptr
	tcl_LimitTypeSet                       uintptr
	tcl_LimitTypeReset                     uintptr
	tcl_LimitGetCommands                   uintptr
	tcl_LimitGetTime                       uintptr
	tcl_LimitGetGranularity                uintptr
	tcl_SaveInterpState                    uintptr
	tcl_RestoreInterpState                 uintptr
	tcl_DiscardInterpState                 uintptr
	tcl_SetReturnOptions                   uintptr
	tcl_GetReturnOptions                   uintptr
	tcl_IsEnsemble                         uintptr
	tcl_CreateEnsemble                     uintptr
	tcl_FindEnsemble                       uintptr
	tcl_SetEnsembleSubcommandList          uintptr
	tcl_SetEnsembleMappingDict             uintptr
	tcl_SetEnsembleUnknownHandler          uintptr
	tcl_SetEnsembleFlags                   uintptr
	tcl_GetEnsembleSubcommandList          uintptr
	tcl_GetEnsembleMappingDict             uintptr
	tcl_GetEnsembleUnknownHandler          uintptr
	tcl_GetEnsembleFlags                   uintptr
	tcl_GetEnsembleNamespace               uintptr
	tcl_SetTimeProc                        uintptr
	tcl_QueryTimeProc                      uintptr
	tcl_ChannelThreadActionProc            uintptr
	tcl_NewBignumObj                       uintptr
	tcl_DbNewBignumObj                     uintptr
	tcl_SetBignumObj                       uintptr
	tcl_GetBignumFromObj                   uintptr
	tcl_TakeBignumFromObj                  uintptr
	tcl_TruncateChannel                    uintptr
	tcl_ChannelTruncateProc                uintptr
	tcl_SetChannelErrorInterp              uintptr
	tcl_GetChannelErrorInterp              uintptr
	tcl_SetChannelError                    uintptr
	tcl_GetChannelError                    uintptr
	tcl_InitBignumFromDouble               uintptr
	tcl_GetNamespaceUnknownHandler         uintptr
	tcl_SetNamespaceUnknownHandler         uintptr
	tcl_GetEncodingFromObj                 uintptr
	tcl_GetEncodingSearchPath              uintptr
	tcl_SetEncodingSearchPath              uintptr
	tcl_GetEncodingNameFromEnvironment     uintptr
	tcl_PkgRequireProc                     uintptr
	tcl_AppendObjToErrorInfo               uintptr
	tcl_AppendLimitedToObj                 uintptr
	tcl_Format                             uintptr
	tcl_AppendFormatToObj                  uintptr
	tcl_ObjPrintf                          uintptr
	tcl_AppendPrintfToObj                  uintptr
	tcl_CancelEval                         uintptr
	tcl_Canceled                           uintptr
	tcl_CreatePipe                         uintptr
	tcl_NRCreateCommand                    uintptr
	tcl_NREvalObj                          uintptr
	tcl_NREvalObjv                         uintptr
	tcl_NRCmdSwap                          uintptr
	tcl_NRAddCallback                      uintptr
	tcl_NRCallObjProc                      uintptr
	tcl_GetFSDeviceFromStat                uintptr
	tcl_GetFSInodeFromStat                 uintptr
	tcl_GetModeFromStat                    uintptr
	tcl_GetLinkCountFromStat               uintptr
	tcl_GetUserIdFromStat                  uintptr
	tcl_GetGroupIdFromStat                 uintptr
	tcl_GetDeviceTypeFromStat              uintptr
	tcl_GetAccessTimeFromStat              uintptr
	tcl_GetModificationTimeFromStat        uintptr
	tcl_GetChangeTimeFromStat              uintptr
	tcl_GetSizeFromStat                    uintptr
	tcl_GetBlocksFromStat                  uintptr
	tcl_GetBlockSizeFromStat               uintptr
	tcl_SetEnsembleParameterList           uintptr
	tcl_GetEnsembleParameterList           uintptr
	tcl_ParseArgsObjv                      uintptr
	tcl_GetErrorLine                       uintptr
	tcl_SetErrorLine                       uintptr
	tcl_TransferResult                     uintptr
	tcl_InterpActive                       uintptr
	tcl_BackgroundException                uintptr
	tcl_ZlibDeflate                        uintptr
	tcl_ZlibInflate                        uintptr
	tcl_ZlibCRC32                          uintptr
	tcl_ZlibAdler32                        uintptr
	tcl_ZlibStreamInit                     uintptr
	tcl_ZlibStreamGetCommandName           uintptr
	tcl_ZlibStreamEof                      uintptr
	tcl_ZlibStreamChecksum                 uintptr
	tcl_ZlibStreamPut                      uintptr
	tcl_ZlibStreamGet                      uintptr
	tcl_ZlibStreamClose                    uintptr
	tcl_ZlibStreamReset                    uintptr
	tcl_SetStartupScript                   uintptr
	tcl_GetStartupScript                   uintptr
	tcl_CloseEx                            uintptr
	tcl_NRExprObj                          uintptr
	tcl_NRSubstObj                         uintptr
	tcl_LoadFile                           uintptr
	tcl_FindSymbol                         uintptr
	tcl_FSUnloadFile                       uintptr
	tcl_ZlibStreamSetCompressionDictionary uintptr
	reserved631                            uintptr
	reserved632                            uintptr
	reserved633                            uintptr
	reserved634                            uintptr
	reserved635                            uintptr
	reserved636                            uintptr
	reserved637                            uintptr
	reserved638                            uintptr
	reserved639                            uintptr
	reserved640                            uintptr
	reserved641                            uintptr
	reserved642                            uintptr
	reserved643                            uintptr
	reserved644                            uintptr
	reserved645                            uintptr
	reserved646                            uintptr
	reserved647                            uintptr
	reserved648                            uintptr
	reserved649                            uintptr
	reserved650                            uintptr
	reserved651                            uintptr
	reserved652                            uintptr
	reserved653                            uintptr
	reserved654                            uintptr
	reserved655                            uintptr
	reserved656                            uintptr
	reserved657                            uintptr
	reserved658                            uintptr
	reserved659                            uintptr
	tclUnusedStubEntry                     uintptr
} /* tclDecls.h:1856:9 */

type TclStubs = TclStubs1 /* tclDecls.h:2545:3 */

// !END!: Do not edit above this line.

// Deprecated Tcl procedures:

// Include platform specific public function declarations that are accessible
// via the stubs table. Make all TclOO symbols MODULE_SCOPE (which only
// has effect on building it as a shared library). See ticket [3010352].

// tclPlatDecls.h --
//
//	Declarations of platform specific Tcl APIs.
//
// Copyright (c) 1998-1999 by Scriptics Corporation.
// All rights reserved.

// WARNING: This file is automatically generated by the tools/genStubs.tcl
// script.  Any modifications to the function declarations below should be made
// in the generic/tcl.decls script.

// TCHAR is needed here for win32, so if it is not defined yet do it here.
// This way, we don't need to include <tchar.h> just for one define.

// !BEGIN!: Do not edit below this line.

// Exported function declarations:

type TclPlatStubs = TclPlatStubs1 /* tclPlatDecls.h:89:3 */

// The following #if block allows you to change how Tcl finds the startup
// script, prime the library or encoding paths, fiddle with the argv, etc.,
// without needing to rewrite Tcl_Main()

//----------------------------------------------------------------------
//
// main --
//
//	This is the main program for the application.
//
// Results:
//	None: Tcl_Main never returns here, so this procedure never returns
//	either.
//
// Side effects:
//	Just about anything, since from here we call arbitrary Tcl code.
//
//----------------------------------------------------------------------

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 { /* tclAppInit.c:72:1: */

	tcl.XTcl_MainEx(tls, argc, argv, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{Tcl_AppInit})), tcl.XTcl_CreateInterp(tls))
	return 0 // Needed only to prevent compiler warning.
}

//----------------------------------------------------------------------
//
// Tcl_AppInit --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcl_AppInit(tls *libc.TLS, interp uintptr) int32 { /* tclAppInit.c:108:1: */
	if tcl.XTcl_Init(tls, interp) == TCL_ERROR {
		return TCL_ERROR
	}

	if Tcltest_Init(tls, interp) == TCL_ERROR {
		return TCL_ERROR
	}
	tcl.XTcl_StaticPackage(tls, interp, ts, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{Tcltest_Init})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{Tcltest_SafeInit})))

	// Call the init procedures for included packages. Each call should look
	// like this:
	//
	// if (Mod_Init(interp) == TCL_ERROR) {
	//     return TCL_ERROR;
	// }
	//
	// where "Mod" is the name of the module. (Dynamically-loadable packages
	// should have the same entry-point name.)

	// Call Tcl_CreateCommand for application-specific commands, if they
	// weren't already created by the init procedures called above.

	// Specify a user-specific startup file to invoke if the application is
	// run interactively. Typically the startup file is "~/.apprc" where "app"
	// is the name of the application. If this line is deleted then no
	// user-specific startup file will be run under any conditions.

	tcl.XTcl_ObjSetVar2(tls, interp, tcl.XTcl_NewStringObj(tls, ts+8, -1), uintptr(0),
		tcl.XTcl_NewStringObj(tls, ts+23, -1), TCL_GLOBAL_ONLY)

	return TCL_OK
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// 11 was EAGAIN

// math software

// non-blocking and interrupt i/o

// ipc/network software -- argument errors

// ipc/network software -- operational errors

// should be rearranged

// quotas & mush

// Network File System

// ISO/IEC 9899:2011 K.3.2.2
type errno_t = int32 /* errno.h:204:13 */ // compatibility w/GNU headers

// When the following macro is defined, the system uses 64-bit inode numbers.
// Programs can use this to avoid including <sys/param.h>, with its associated
// namespace pollution.

type mode_t = uint16 /* fcntl.h:53:18 */

type pid_t = int32 /* fcntl.h:63:18 */

// File status flags: these are used by open(2), fcntl(2).
// They are also used (indirectly) in the kernel file structure f_flags,
// which is a superset of the open/fcntl flags.  Open flags and f_flags
// are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
// Open/fcntl flags begin with O_; kernel-internal flags begin with F.
// open-only flags

// Kernel encoding of open mode; separate read and write bits that are
// independently testable: 1 greater than the above.
//
// XXX
// FREAD and FWRITE are excluded from the #ifdef _KERNEL so that TIOCFLUSH,
// which was documented to use FREAD/FWRITE, continues to work.

// Defined by POSIX 1003.1; BSD default, but must be distinct from O_RDONLY.

// Attempt to bypass buffer cache

// Defined by POSIX 1003.1-2008; BSD default, but reserve for future use.

/* #define O_UNUSED1	0x00400000   */ // Was O_BENEATH

// XXX missing O_RSYNC.

// The O_* flags used to have only F* names, which were used in the kernel
// and by fcntl.  We retain the F* names for the kernel f_flag field
// and for backward compatibility for fcntl.  These flags are deprecated.

// Historically, we ran out of bits in f_flag (which was once a short).
// However, the flag bits not set in FMASK are only meaningful in the
// initial open syscall.  Those bits were thus given a
// different meaning for fcntl(2).
// Read ahead

// Magic value that specify the use of the current working directory
// to determine the target of relative file paths in the openat() and
// similar syscalls.

// Miscellaneous flags for the *at() syscalls.
/* #define AT_UNUSED1		0x1000 */ // Was AT_BENEATH

// Constants used for fcntl(2)

// command values

// Seals (F_ADD_SEALS, F_GET_SEALS).

// file descriptor flags (F_GETFD, F_SETFD)

// record locking flags (F_GETLK, F_SETLK, F_SETLKW)

// Advisory file segment locking data type -
// information passed to system by user
type flock = struct {
	l_start  off_t
	l_len    off_t
	l_pid    pid_t
	l_type   int16
	l_whence int16
	l_sysid  int32
	_        [4]byte
} /* fcntl.h:294:1 */

// Old advisory file segment locking data type,
// before adding l_sysid.
type __oflock = struct {
	l_start  off_t
	l_len    off_t
	l_pid    pid_t
	l_type   int16
	l_whence int16
} /* fcntl.h:308:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)pwd.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type gid_t = uint32 /* pwd.h:47:18 */

type time_t = int64 /* pwd.h:52:18 */

type uid_t = uint32 /* pwd.h:57:18 */

// Historically, the keys in _PATH_MP_DB/_PATH_SMP_DB had the format
// `1 octet tag | key', where the tag is one of the _PW_KEY* values
// listed below.  These values happen to be ASCII digits.  Starting
// with FreeBSD 5.1, the tag is now still a single octet, but the
// upper 4 bits are interpreted as a version.  Pre-FreeBSD 5.1 format
// entries are version `3' -- this conveniently results in the same
// key values as before.  The new, architecture-independent entries
// are version `4'.
// As it happens, some applications read the database directly.
// (Bad app, no cookie!)  Thus, we leave the _PW_KEY* symbols at their
// old pre-FreeBSD 5.1 values so these apps still work.  Consequently
// we have to muck around a bit more to get the correct, versioned
// tag, and that is what the _PW_VERSIONED macro is about.

// The database also contains a key to indicate the format version of
// the entries therein.  There may be other, older versioned entries
// as well.

type passwd = struct {
	pw_name   uintptr
	pw_passwd uintptr
	pw_uid    uid_t
	pw_gid    gid_t
	pw_change time_t
	pw_class  uintptr
	pw_gecos  uintptr
	pw_dir    uintptr
	pw_shell  uintptr
	pw_expire time_t
	pw_fields int32
	_         [4]byte
} /* pwd.h:114:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.3 (Berkeley) 3/30/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.4 (Berkeley) 5/4/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.4 (Berkeley) 5/4/95
// $FreeBSD$

// sigset_t macros.

type __sigset = struct{ __bits [4]uint32 } /* _sigset.h:53:9 */

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// Copyright (c) 2003 Peter Wemm.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.1 (Berkeley) 6/11/93
// $FreeBSD$

// Machine-dependent signal definitions

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.4 (Berkeley) 5/4/95
// $FreeBSD$

type sig_atomic_t = int64 /* signal.h:101:14 */

// Information pushed on stack when a signal is delivered.
// This is used by the kernel to restore state following
// execution of the signal handler.  It is also made available
// to the handler to allow it to restore state properly if
// a non-standard exit is performed.
//
// The sequence of the fields/registers after sc_mask in struct
// sigcontext must match those in mcontext_t and struct trapframe.
type sigcontext = struct {
	sc_mask          struct{ __bits [4]uint32 }
	sc_onstack       int64
	sc_rdi           int64
	sc_rsi           int64
	sc_rdx           int64
	sc_rcx           int64
	sc_r8            int64
	sc_r9            int64
	sc_rax           int64
	sc_rbx           int64
	sc_rbp           int64
	sc_r10           int64
	sc_r11           int64
	sc_r12           int64
	sc_r13           int64
	sc_r14           int64
	sc_r15           int64
	sc_trapno        int32
	sc_fs            int16
	sc_gs            int16
	sc_addr          int64
	sc_flags         int32
	sc_es            int16
	sc_ds            int16
	sc_err           int64
	sc_rip           int64
	sc_cs            int64
	sc_rflags        int64
	sc_rsp           int64
	sc_ss            int64
	sc_len           int64
	sc_fpformat      int64
	sc_ownedfp       int64
	sc_fpstate       [64]int64
	sc_fsbase        int64
	sc_gsbase        int64
	sc_xfpustate     int64
	sc_xfpustate_len int64
	sc_spare         [4]int64
} /* signal.h:114:1 */

type pthread_once = struct {
	state int32
	_     [4]byte
	mutex pthread_mutex_t
} /* _pthreadtypes.h:52:1 */

// Primitive system data type definitions required by P1003.1c.
//
// Note that P1003.1c specifies that there are no defined comparison
// or assignment operators for the types pthread_attr_t, pthread_cond_t,
// pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t.
type pthread_t = uintptr             /* _pthreadtypes.h:67:26 */
type pthread_attr_t = uintptr        /* _pthreadtypes.h:70:30 */
type pthread_mutex_t = uintptr       /* _pthreadtypes.h:71:31 */
type pthread_mutexattr_t = uintptr   /* _pthreadtypes.h:72:35 */
type pthread_cond_t = uintptr        /* _pthreadtypes.h:73:30 */
type pthread_condattr_t = uintptr    /* _pthreadtypes.h:74:34 */
type pthread_key_t = int32           /* _pthreadtypes.h:75:20 */
type pthread_once_t = pthread_once   /* _pthreadtypes.h:76:30 */
type pthread_rwlock_t = uintptr      /* _pthreadtypes.h:77:32 */
type pthread_rwlockattr_t = uintptr  /* _pthreadtypes.h:78:35 */
type pthread_barrier_t = uintptr     /* _pthreadtypes.h:79:33 */
type pthread_barrierattr_t = uintptr /* _pthreadtypes.h:80:36 */
type pthread_spinlock_t = uintptr    /* _pthreadtypes.h:81:33 */

// Additional type definitions:
//
// Note that P1003.1c reserves the prefixes pthread_ and PTHREAD_ for
// use in header symbols.
type pthread_addr_t = uintptr         /* _pthreadtypes.h:89:14 */
type pthread_startroutine_t = uintptr /* _pthreadtypes.h:90:14 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type timespec = struct {
	tv_sec  time_t
	tv_nsec int64
} /* _timespec.h:46:1 */

type sigset_t = __sigset /* signal.h:166:20 */

type sigval = struct {
	_         [0]uint64
	sival_int int32
	_         [4]byte
} /* signal.h:171:1 */

type sigevent = struct {
	sigev_notify int32
	sigev_signo  int32
	sigev_value  struct {
		_         [0]uint64
		sival_int int32
		_         [4]byte
	}
	_sigev_un struct {
		_         [0]uint64
		_threadid int32
		_         [60]byte
	}
} /* signal.h:195:1 */

type __siginfo = struct {
	si_signo  int32
	si_errno  int32
	si_code   int32
	si_pid    int32
	si_uid    uint32
	si_status int32
	si_addr   uintptr
	si_value  struct {
		_         [0]uint64
		sival_int int32
		_         [4]byte
	}
	_reason struct {
		_      [0]uint64
		_fault struct{ _trapno int32 }
		_      [36]byte
	}
} /* signal.h:229:9 */

type siginfo_t = __siginfo /* signal.h:263:3 */

// Signal vector "template" used in sigaction call.
type sigaction = struct {
	__sigaction_u struct{ __sa_handler uintptr }
	sa_flags      int32
	sa_mask       sigset_t
	_             [4]byte
} /* signal.h:368:1 */

// If SA_SIGINFO is set, sa_sigaction must be used instead of sa_handler.

// a timer set by timer_settime().
// an asynchronous I/O request.
// message on an empty message queue.

type sig_t = uintptr /* signal.h:420:24 */

type sigaltstack = struct {
	ss_sp    uintptr
	ss_size  uint64
	ss_flags int32
	_        [4]byte
} /* signal.h:428:9 */

type stack_t = sigaltstack /* signal.h:428:26 */

// 4.3 compatibility:
// Signal vector "template" used in sigvec call.
type sigvec = struct {
	sv_handler uintptr
	sv_mask    int32
	sv_flags   int32
} /* signal.h:452:1 */

// Keep this in one place only

// Structure used in sigstack call.
type sigstack = struct {
	ss_sp      uintptr
	ss_onstack int32
	_          [4]byte
} /* signal.h:479:1 */

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 2003 Peter Wemm
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// mc_flags bits. Shall be in sync with TF_XXX.

type __mcontext = struct {
	mc_onstack       int64
	mc_rdi           int64
	mc_rsi           int64
	mc_rdx           int64
	mc_rcx           int64
	mc_r8            int64
	mc_r9            int64
	mc_rax           int64
	mc_rbx           int64
	mc_rbp           int64
	mc_r10           int64
	mc_r11           int64
	mc_r12           int64
	mc_r13           int64
	mc_r14           int64
	mc_r15           int64
	mc_trapno        uint32
	mc_fs            uint16
	mc_gs            uint16
	mc_addr          int64
	mc_flags         uint32
	mc_es            uint16
	mc_ds            uint16
	mc_err           int64
	mc_rip           int64
	mc_cs            int64
	mc_rflags        int64
	mc_rsp           int64
	mc_ss            int64
	mc_len           int64
	mc_fpformat      int64
	mc_ownedfp       int64
	mc_fpstate       [64]int64
	mc_fsbase        int64
	mc_gsbase        int64
	mc_xfpustate     int64
	mc_xfpustate_len int64
	mc_spare         [4]int64
} /* ucontext.h:106:9 */

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 2003 Peter Wemm
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// mc_flags bits. Shall be in sync with TF_XXX.

type mcontext_t = __mcontext /* ucontext.h:164:3 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

type __ucontext = struct {
	uc_sigmask  struct{ __bits [4]uint32 }
	uc_mcontext mcontext_t
	uc_link     uintptr
	uc_stack    struct {
		ss_sp    uintptr
		ss_size  uint64
		ss_flags int32
		_        [4]byte
	}
	uc_flags  int32
	__spare__ [4]int32
	_         [4]byte
} /* _ucontext.h:36:9 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

type ucontext_t = __ucontext /* _ucontext.h:52:3 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)param.h	8.3 (Berkeley) 4/4/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2003 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// __FreeBSD_version numbers are documented in the Porter's Handbook.
// If you bump the version for any reason, you should update the documentation
// there.
// Currently this lives here in the doc/ repository:
//
//	documentation/content/en/books/porters-handbook/versions/chapter.adoc
//
// scheme is:  <major><two digit minor>Rxx
//		'R' is in the range 0 to 4 if this is a release branch or
//		X.0-CURRENT before releng/X.0 is created, otherwise 'R' is
//		in the range 5 to 9.

// __FreeBSD_kernel__ indicates that this system uses the kernel of FreeBSD,
// which by definition is always true on FreeBSD. This macro is also defined
// on other systems that use the kernel of FreeBSD, such as GNU/kFreeBSD.
//
// It is tempting to use this macro in userland code when we want to enable
// kernel-specific routines, and in fact it's fine to do this in code that
// is part of FreeBSD itself.  However, be aware that as presence of this
// macro is still not widespread (e.g. older FreeBSD versions, 3rd party
// compilers, etc), it is STRONGLY DISCOURAGED to check for this macro in
// external applications without also checking for __FreeBSD__ as an
// alternative.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.6 (Berkeley) 2/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Machine type dependent parameters.
// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1987, 1991 Regents of the University of California.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)endian.h	7.8 (Berkeley) 4/3/91
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Define the order of 32-bit words in 64-bit words.

// Definitions for byte order, according to byte significance from low
// address to high.

// Deprecated variants that don't have enough underscores to be useful in more
// strict namespaces.

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1993, 1994 by Chris Provenzano, proven@mit.edu
// Copyright (c) 1995-1998 by John Birrell <jb@cimlogic.com.au>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//  This product includes software developed by Chris Provenzano.
// 4. The name of Chris Provenzano may not be used to endorse or promote
//	  products derived from this software without specific prior written
//	  permission.
//
// THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type u_char = uint8   /* types.h:52:23 */
type u_short = uint16 /* types.h:53:24 */
type u_int = uint32   /* types.h:54:22 */
type u_long = uint64  /* types.h:55:23 */
type ushort = uint16  /* types.h:57:24 */ // Sys V compatibility
type uint = uint32    /* types.h:58:22 */ // Sys V compatibility

// XXX POSIX sized integrals that should appear only in <sys/stdint.h>.
// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2011 David E. O'Brien <obrien@FreeBSD.org>
// Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type int8_t = int8 /* _stdint.h:36:19 */

type int16_t = int16 /* _stdint.h:41:20 */

type int32_t = int32 /* _stdint.h:46:20 */

type int64_t = int64 /* _stdint.h:51:20 */

type uint8_t = uint8 /* _stdint.h:56:20 */

type uint16_t = uint16 /* _stdint.h:61:21 */

type uint32_t = uint32 /* _stdint.h:66:21 */

type uint64_t = uint64 /* _stdint.h:71:21 */

type intptr_t = int64   /* _stdint.h:76:21 */
type uintptr_t = uint64 /* _stdint.h:80:22 */
type intmax_t = int64   /* _stdint.h:84:21 */
type uintmax_t = uint64 /* _stdint.h:88:22 */

type u_int8_t = uint8   /* types.h:67:19 */ // unsigned integrals (deprecated)
type u_int16_t = uint16 /* types.h:68:20 */
type u_int32_t = uint32 /* types.h:69:20 */
type u_int64_t = uint64 /* types.h:70:20 */

type u_quad_t = uint64 /* types.h:72:20 */ // quads (deprecated)
type quad_t = int64    /* types.h:73:19 */
type qaddr_t = uintptr /* types.h:74:16 */

type caddr_t = uintptr   /* types.h:76:14 */ // core address
type c_caddr_t = uintptr /* types.h:77:20 */ // core address, pointer to const

type blksize_t = int32 /* types.h:80:21 */

type cpuwhich_t = int32 /* types.h:84:22 */
type cpulevel_t = int32 /* types.h:85:22 */
type cpusetid_t = int32 /* types.h:86:22 */

type blkcnt_t = int64 /* types.h:89:20 */

type clock_t = int32 /* types.h:94:19 */

type clockid_t = int32 /* types.h:99:21 */

type critical_t = int64 /* types.h:103:22 */ // Critical section value
type daddr_t = int64    /* types.h:104:19 */ // disk address

type dev_t = uint64 /* types.h:107:18 */ // device number or struct cdev

type fflags_t = uint32 /* types.h:112:20 */ // file flags

type fixpt_t = uint32 /* types.h:116:19 */ // fixed point number

type fsblkcnt_t = uint64 /* types.h:119:22 */
type fsfilcnt_t = uint64 /* types.h:120:22 */

type in_addr_t = uint32 /* types.h:130:20 */ // base type for internet address

type in_port_t = uint16 /* types.h:135:20 */

type id_t = int64 /* types.h:140:17 */ // can hold a uid_t or pid_t

type ino_t = uint64 /* types.h:145:18 */ // inode number

type key_t = int64 /* types.h:150:18 */ // IPC key (for Sys V IPC)

type lwpid_t = int32 /* types.h:155:19 */ // Thread ID (a.k.a. LWP)

type accmode_t = int32 /* types.h:165:21 */ // access permissions

type nlink_t = uint64 /* types.h:170:19 */ // file offset (alias)

type register_t = int64 /* types.h:189:22 */

type rlim_t = int64 /* types.h:192:18 */ // resource limit

type sbintime_t = int64 /* types.h:196:19 */

type segsz_t = int64 /* types.h:198:19 */

type suseconds_t = int64 /* types.h:211:23 */ // microseconds (signed)

type timer_t = uintptr /* types.h:221:19 */

type mqd_t = uintptr /* types.h:226:17 */

type u_register_t = uint64 /* types.h:230:24 */

type useconds_t = uint32 /* types.h:238:22 */ // microseconds (unsigned)

type cap_ioctl_t = uint64 /* types.h:244:23 */

// Types suitable for exporting physical addresses, virtual addresses
// (pointers), and memory object sizes from the kernel independent of native
// word size.  These should be used in place of vm_paddr_t, (u)intptr_t, and
// size_t in structs which contain such types that are shared with userspace.
type kpaddr_t = uint64 /* types.h:260:20 */
type kvaddr_t = uint64 /* types.h:261:20 */
type ksize_t = uint64  /* types.h:262:20 */
type kssize_t = int64  /* types.h:263:19 */

type vm_offset_t = uint64  /* types.h:265:23 */
type vm_ooffset_t = uint64 /* types.h:266:20 */
type vm_paddr_t = uint64   /* types.h:267:22 */
type vm_pindex_t = uint64  /* types.h:268:20 */
type vm_size_t = uint64    /* types.h:269:21 */

type rman_res_t = uint64 /* types.h:271:25 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.4 (Berkeley) 5/4/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Structure returned by gettimeofday(2) system call, and used in other calls.
type timeval = struct {
	tv_sec  time_t
	tv_usec suseconds_t
} /* _timeval.h:49:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// Structure defined by POSIX.1b to be like a itimerval, but with
// timespecs. Used in the timer_*() system calls.
type itimerspec = struct {
	it_interval struct {
		tv_sec  time_t
		tv_nsec int64
	}
	it_value struct {
		tv_sec  time_t
		tv_nsec int64
	}
} /* timespec.h:60:1 */

type fd_mask = uint64 /* select.h:46:19 */

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).
// FD_SETSIZE may be defined by the user, but the default here should
// be enough for most uses.

type fd_set1 = struct{ __fds_bits [16]uint64 } /* select.h:73:9 */

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).
// FD_SETSIZE may be defined by the user, but the default here should
// be enough for most uses.

type fd_set = fd_set1 /* select.h:75:3 */

// Machine-independent constants (some used in following include files).
// Redefined constants are from POSIX 1003.1 limits file.
//
// MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)syslimits.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// Do not add any new variables here.  (See the comment at the end of
// the file for why.)

// We leave the following values undefined to force applications to either
// assume conservative values or call sysconf() to get the current value.
//
// HOST_NAME_MAX
//
// (We should do this for most of the values currently defined here,
// but many programs are not prepared to deal with this yet.)

// More types and definitions used throughout the kernel.

// Signals.
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.4 (Berkeley) 5/4/95
// $FreeBSD$

// Machine type dependent parameters.
// -
// SPDX-License-Identifier: BSD-4-Clause
//
// Copyright (c) 2002 David E. O'Brien.  All rights reserved.
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// the Systems Programming Group of the University of Utah Computer
// Science Department and Ralph Campbell.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)param.h	8.1 (Berkeley) 6/10/93
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-4-Clause
//
// Copyright (c) 2001 David E. O'Brien
// Copyright (c) 1990 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// William Jolitz.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	from: @(#)param.h	5.8 (Berkeley) 6/28/91
// $FreeBSD$

// Round p (pointer or byte index) up to a correctly-aligned value
// for all data types (int, long, ...).   The result is unsigned int
// and must be cast to any desired pointer type.

// Machine dependent constants for AMD64.

// ALIGNED_POINTER is a boolean macro that checks whether an address
// is valid to fetch data elements of type t from on this architecture.
// This does not reflect the optimal alignment, just the possibility
// (within reasonable limits).

// CACHE_LINE_SIZE is the compile-time maximum cache line size for an
// architecture.  It should be used with appropriate caution.

// Size of the level 1 page table units
// Size of the level 2 page directory units
// Size of the level 3 page directory pointer table units
// Size of the level 4 page-map level-4 table units
// Size of the level 5 page-map level-5 table units

// I/O permission bitmap has a bit for each I/O port plus an additional
// byte at the end with all bits set. See section "I/O Permission Bit Map"
// in the Intel SDM for more details.

// Mach derived conversion macros

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94
// $FreeBSD$

// Constants related to network buffer management.
// MCLBYTES must be no larger than PAGE_SIZE.

// Some macros for units conversion

// clicks to bytes

// bytes to clicks

// btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
// want to shift an unsigned type to avoid sign extension and we don't
// want to widen `bytes' unnecessarily.  Assume that the result fits in
// a daddr_t.

// File system parameters and macros.
//
// MAXBSIZE -	Filesystems are made out of blocks of at most MAXBSIZE bytes
//		per block.  MAXBSIZE may be made larger without effecting
//		any existing filesystems as long as it does not exceed MAXPHYS,
//		and may be made smaller at the risk of not being able to use
//		filesystems which require a block size exceeding MAXBSIZE.
//
// MAXBCACHEBUF - Maximum size of a buffer in the buffer cache.  This must
//		be >= MAXBSIZE and can be set differently for different
//		architectures by defining it in <machine/param.h>.
//		Making this larger allows NFS to do larger reads/writes.
//
// BKVASIZE -	Nominal buffer space per buffer, in bytes.  BKVASIZE is the
//		minimum KVM memory reservation the kernel is willing to make.
//		Filesystems can of course request smaller chunks.  Actual
//		backing memory uses a chunk size of a page (PAGE_SIZE).
//		The default value here can be overridden on a per-architecture
//		basis by defining it in <machine/param.h>.
//
//		If you make BKVASIZE too small you risk seriously fragmenting
//		the buffer KVM map which may slow things down a bit.  If you
//		make it too big the kernel will not be able to optimally use
//		the KVM memory reserved for the buffer cache and will wind
//		up with too-few buffers.
//
//		The default is 16384, roughly 2x the block size used by a
//		normal UFS filesystem.

// MAXPATHLEN defines the longest permissible path length after expanding
// symbolic links. It is used to allocate a temporary buffer from the buffer
// pool in which to do the name expansion, hence should be a power of two,
// and must be less than or equal to MAXBSIZE.  MAXSYMLINKS defines the
// maximum number of symbolic links that may be expanded in a path name.
// It should be set high enough to allow all legitimate uses, but halt
// infinite loops reasonably quickly.

// Bit map related macros.

// Macros for counting and rounding.

// Macros for min/max.

// Scale factor for scaled integers used to count %cpu time and load avgs.
//
// The number of CPU `tick's that map to a unique `%age' can be expressed
// by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
// can be calculated (assuming 32 bits) can be closely approximated using
// the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
//
// For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
// FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.

// Old spelling of __containerof().

// Access a variable length array that has been declared as a fixed
// length array.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.6 (Berkeley) 2/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)dirent.h	8.2 (Berkeley) 7/28/94
// $FreeBSD$

// The kernel defines the format of directory entries returned by
// the getdirentries(2) system call.
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)dirent.h	8.3 (Berkeley) 8/10/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// The dirent structure defines the format of directory entries returned by
// the getdirentries(2) system call.
//
// A directory entry has a struct dirent at the front of it, containing its
// inode number, the length of the entry, and the length of the name
// contained in the entry.  These are followed by the name padded to an 8
// byte boundary with null bytes.  All names are guaranteed null terminated.
// The maximum length of a name in a directory is MAXNAMLEN.
//
// Explicit padding between the last member of the header (d_namlen) and
// d_name avoids ABI padding at the end of dirent on LP64 architectures.
// There is code depending on d_name being last.

type dirent = struct {
	d_fileno ino_t
	d_off    off_t
	d_reclen uint16
	d_type   uint8
	d_pad0   uint8
	d_namlen uint16
	d_pad1   uint16
	d_name   [256]int8
} /* dirent.h:66:1 */

//---------------------------------------------------------------------------
// Parameterize for 64-bit filesystem support.
//---------------------------------------------------------------------------

type Tcl_DirEntry = dirent /* tclUnixPort.h:63:24 */

type Tcl_SeekOffset = off_t /* tclUnixPort.h:83:16 */

//---------------------------------------------------------------------------
// Miscellaneous includes that might be missing.
//---------------------------------------------------------------------------

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)file.h	8.3 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.6 (Berkeley) 2/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1983, 1990, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)fcntl.h	8.3 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)unistd.h	8.2 (Berkeley) 1/7/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// POSIX options and option groups we unconditionally do or don't
// implement.  Those options which are implemented (or not) entirely
// in user mode are defined in <unistd.h>.  Please keep this list in
// alphabetical order.
//
// Anything which is defined as zero below **must** have an
// implementation for the corresponding sysconf() which is able to
// determine conclusively whether or not the feature is supported.
// Anything which is defined as other than -1 below **must** have
// complete headers, types, and function declarations as specified by
// the POSIX standard; however, if the relevant sysconf() function
// returns -1, the functions may be stubbed out.

// Although we have saved user/group IDs, we do not use them in setuid
// as described in POSIX 1003.1, because the feature does not work for
// root.  We use the saved IDs in seteuid/setegid, which are not currently
// part of the POSIX 1003.1 specification.  XXX revisit for 1003.1-2001
// as this is now mandatory.

// Define the POSIX.1 version we target for compliance.

// access function

// whence values for lseek(2)

// whence values for lseek(2); renamed by POSIX 1003.1

// configurable pathname variables

// From OpenSolaris, used by SEEK_DATA/SEEK_HOLE.

// rfork() options.
//
// XXX currently, some operations without RFPROC set are not supported.
// kernel: parent sleeps until child exits (vfork)
// user: vfork(2) semantics, clear signals

// Userland version of struct file, for sysctl
type xfile = struct {
	xf_size        ksize_t
	xf_pid         pid_t
	xf_uid         uid_t
	xf_fd          int32
	_xf_int_pad1   int32
	xf_file        kvaddr_t
	xf_type        int16
	_xf_short_pad1 int16
	xf_count       int32
	xf_msgcount    int32
	_xf_int_pad2   int32
	xf_offset      off_t
	xf_data        kvaddr_t
	xf_vnode       kvaddr_t
	xf_flag        u_int
	_xf_int_pad3   int32
	_xf_int64_pad  [6]int64_t
} /* file.h:218:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stat.h	8.12 (Berkeley) 6/16/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// XXX We get miscellaneous namespace pollution with this.
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.6 (Berkeley) 2/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

type timezone = struct {
	tz_minuteswest int32
	tz_dsttime     int32
} /* time.h:42:1 */

type bintime = struct {
	sec  time_t
	frac uint64_t
} /* time.h:55:1 */

// Decimal<->sbt conversions.  Multiplying or dividing by SBT_1NS results in
// large roundoff errors which sbttons() and nstosbt() avoid.  Millisecond and
// microsecond functions are also provided for completeness.
//
// These functions return the smallest sbt larger or equal to the
// number of seconds requested so that sbttoX(Xtosbt(y)) == y.  Unlike
// top of second computations below, which require that we tick at the
// top of second, these need to be rounded up so we do whatever for at
// least as long as requested.
//
// The naive computation we'd do is this
//	((unit * 2^64 / SIFACTOR) + 2^32-1) >> 32
// However, that overflows. Instead, we compute
//	((unit * 2^63 / SIFACTOR) + 2^31-1) >> 32
// and use pre-computed constants that are the ceil of the 2^63 / SIFACTOR
// term to ensure we are using exactly the right constant. We use the lesser
// evil of ull rather than a uint64_t cast to ensure we have well defined
// right shift semantics. With these changes, we get all the ns, us and ms
// conversions back and forth right.
// Note: This file is used for both kernel and userland includes, so we can't
// rely on KASSERT being defined, nor can we pollute the namespace by including
// assert.h.
func sbttons(tls *libc.TLS, _sbt sbintime_t) int64_t { /* time.h:185:1: */
	var ns uint64_t

	ns = uint64_t(_sbt)
	if ns >= uint64(sbintime_t(int64(1))<<32) {
		ns = ns >> 32 * uint64(1000000000)
	} else {
		ns = uint64(0)
	}

	return int64_t(ns + uint64_t(int64(1000000000)*(_sbt&int64(0xffffffff))>>32))
}

func nstosbt(tls *libc.TLS, _ns int64_t) sbintime_t { /* time.h:202:1: */
	var sb sbintime_t = int64(0)

	if _ns >= sbintime_t(int64(1))<<32 {
		sb = _ns / int64(1000000000) * (sbintime_t(int64(1)) << 32)
		_ns = _ns % int64(1000000000)
	}
	// 9223372037 = ceil(2^63 / 1000000000)
	sb = sbintime_t(uint64(sb) + (uint64(_ns)*9223372037+uint64(0x7fffffff))>>31)
	return sb
}

func sbttous(tls *libc.TLS, _sbt sbintime_t) int64_t { /* time.h:219:1: */

	return int64(1000000) * _sbt >> 32
}

func ustosbt(tls *libc.TLS, _us int64_t) sbintime_t { /* time.h:226:1: */
	var sb sbintime_t = int64(0)

	if _us >= sbintime_t(int64(1))<<32 {
		sb = _us / int64(1000000) * (sbintime_t(int64(1)) << 32)
		_us = _us % int64(1000000)
	}
	// 9223372036855 = ceil(2^63 / 1000000)
	sb = sbintime_t(uint64(sb) + (uint64(_us)*9223372036855+uint64(0x7fffffff))>>31)
	return sb
}

// Operations on timespecs

// Names of the interval timers, and structure
// defining a timer setting.

type itimerval = struct {
	it_interval struct {
		tv_sec  time_t
		tv_usec suseconds_t
	}
	it_value struct {
		tv_sec  time_t
		tv_usec suseconds_t
	}
} /* time.h:447:1 */

// Getkerninfo clock information structure
type clockinfo = struct {
	hz     int32
	tick   int32
	spare  int32
	stathz int32
	profhz int32
} /* time.h:455:1 */

// These macros are also in time.h.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.3 (Berkeley) 1/21/94

// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2003 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Frequency of the clock ticks reported by times().  Deprecated - use
// sysconf(_SC_CLK_TCK) instead.  (Removed in 1003.1-2001.)

// Frequency of the clock ticks reported by clock().

// New in POSIX 1003.1b-1993.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// These macros are also in sys/time.h.

type tm = struct {
	tm_sec    int32
	tm_min    int32
	tm_hour   int32
	tm_mday   int32
	tm_mon    int32
	tm_year   int32
	tm_wday   int32
	tm_yday   int32
	tm_isdst  int32
	_         [4]byte
	tm_gmtoff int64
	tm_zone   uintptr
} /* time.h:129:1 */

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2011, 2012 The FreeBSD Foundation
// All rights reserved.
//
// This software was developed by David Chisnall under sponsorship from
// the FreeBSD Foundation.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type locale_t = uintptr /* _time.h:36:25 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.3 (Berkeley) 1/21/94

// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// This file holds definitions relevant to the wait4 system call and the
// alternate interfaces that use it (wait, wait3, waitpid).

// Macros to test the exit status returned by wait and extract the relevant
// values.

// Option bits for the third argument of wait4.  WNOHANG causes the
// wait to not hang if there are no stopped or terminated processes, rather
// returning an error indication in this case (pid==0).  WUNTRACED
// indicates that the caller should receive status about untraced children
// which stop due to signals.  If children are stopped and a wait without
// this option is done, it is as though they were still running... nothing
// about them is returned. WNOWAIT only request information about zombie,
// leaving the proc around, available for later waits.

type idtype_t = uint32 /* wait.h:125:3 */
type rusage = struct {
	ru_utime struct {
		tv_sec  time_t
		tv_usec suseconds_t
	}
	ru_stime struct {
		tv_sec  time_t
		tv_usec suseconds_t
	}
	ru_maxrss   int64
	ru_ixrss    int64
	ru_idrss    int64
	ru_isrss    int64
	ru_minflt   int64
	ru_majflt   int64
	ru_nswap    int64
	ru_inblock  int64
	ru_oublock  int64
	ru_msgsnd   int64
	ru_msgrcv   int64
	ru_nsignals int64
	ru_nvcsw    int64
	ru_nivcsw   int64
} /* wait.h:166:1 */

type __wrusage = struct {
	wru_self struct {
		ru_utime struct {
			tv_sec  time_t
			tv_usec suseconds_t
		}
		ru_stime struct {
			tv_sec  time_t
			tv_usec suseconds_t
		}
		ru_maxrss   int64
		ru_ixrss    int64
		ru_idrss    int64
		ru_isrss    int64
		ru_minflt   int64
		ru_majflt   int64
		ru_nswap    int64
		ru_inblock  int64
		ru_oublock  int64
		ru_msgsnd   int64
		ru_msgrcv   int64
		ru_nsignals int64
		ru_nvcsw    int64
		ru_nivcsw   int64
	}
	wru_children struct {
		ru_utime struct {
			tv_sec  time_t
			tv_usec suseconds_t
		}
		ru_stime struct {
			tv_sec  time_t
			tv_usec suseconds_t
		}
		ru_maxrss   int64
		ru_ixrss    int64
		ru_idrss    int64
		ru_isrss    int64
		ru_minflt   int64
		ru_majflt   int64
		ru_nswap    int64
		ru_inblock  int64
		ru_oublock  int64
		ru_msgsnd   int64
		ru_msgrcv   int64
		ru_nsignals int64
		ru_nvcsw    int64
		ru_nivcsw   int64
	}
} /* wait.h:167:1 */

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-NetBSD
//
// Copyright (c) 2001 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Klaus Klein.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
//	From: $NetBSD: int_fmtio.h,v 1.2 2001/04/26 16:25:21 kleink Exp $
// $FreeBSD$

// Macros for format specifiers.

// fprintf(3) macros for signed integers.

// fprintf(3) macros for unsigned integers.

// fscanf(3) macros for signed integers.

// fscanf(3) macros for unsigned integers.

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-4-Clause
//
// Copyright (c) 2001, 2002 Mike Barcroft <mike@FreeBSD.org>
// Copyright (c) 2001 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Klaus Klein.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//        This product includes software developed by the NetBSD
//        Foundation, Inc. and its contributors.
// 4. Neither the name of The NetBSD Foundation nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94
// $FreeBSD$

// ISO/IEC 9899:1999
// 7.18.2.1 Limits of exact-width integer types

// ISO/IEC 9899:1999
// 7.18.2.2  Limits of minimum-width integer types
// Minimum values of minimum-width signed integer types.

// Maximum values of minimum-width signed integer types.

// Maximum values of minimum-width unsigned integer types.

// ISO/IEC 9899:1999
// 7.18.2.3  Limits of fastest minimum-width integer types
// Minimum values of fastest minimum-width signed integer types.

// Maximum values of fastest minimum-width signed integer types.

// Maximum values of fastest minimum-width unsigned integer types.

// ISO/IEC 9899:1999
// 7.18.2.4  Limits of integer types capable of holding object pointers

// ISO/IEC 9899:1999
// 7.18.2.5  Limits of greatest-width integer types

// ISO/IEC 9899:1999
// 7.18.3  Limits of other integer types
// Limits of ptrdiff_t.

// Limits of sig_atomic_t.

// Limit of size_t.

// Limits of wint_t.

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2011 David E. O'Brien <obrien@FreeBSD.org>
// Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type int_least8_t = int8   /* stdint.h:40:25 */
type int_least16_t = int16 /* stdint.h:41:26 */
type int_least32_t = int32 /* stdint.h:42:26 */
type int_least64_t = int64 /* stdint.h:43:26 */

type uint_least8_t = uint8   /* stdint.h:45:26 */
type uint_least16_t = uint16 /* stdint.h:46:26 */
type uint_least32_t = uint32 /* stdint.h:47:26 */
type uint_least64_t = uint64 /* stdint.h:48:26 */

type int_fast8_t = int32  /* stdint.h:50:24 */
type int_fast16_t = int32 /* stdint.h:51:25 */
type int_fast32_t = int32 /* stdint.h:52:25 */
type int_fast64_t = int64 /* stdint.h:53:25 */

type uint_fast8_t = uint32  /* stdint.h:55:25 */
type uint_fast16_t = uint32 /* stdint.h:56:26 */
type uint_fast32_t = uint32 /* stdint.h:57:26 */
type uint_fast64_t = uint64 /* stdint.h:58:26 */

type imaxdiv_t = struct {
	quot intmax_t
	rem  intmax_t
} /* inttypes.h:47:3 */ // select(2)

type crypt_data = struct {
	initialized int32
	__buf       [256]int8
} /* unistd.h:489:1 */

//---------------------------------------------------------------------------
// Socket support stuff: This likely needs more work to parameterize for each
// system.
//---------------------------------------------------------------------------

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)socket.h	8.4 (Berkeley) 2/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)uio.h	8.5 (Berkeley) 2/22/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type iovec = struct {
	iov_base uintptr
	iov_len  size_t
} /* _iovec.h:45:1 */

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-4-Clause
//
// Copyright (c) 2001 David E. O'Brien
// Copyright (c) 1990 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// William Jolitz.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	from: @(#)param.h	5.8 (Berkeley) 6/28/91
// $FreeBSD$

// Definitions related to sockets: types, address families, options.

// Data types.

type sa_family_t = uint8 /* socket.h:68:23 */

type socklen_t = uint32 /* socket.h:73:21 */

// Types

// Creation flags, OR'ed into socket() and socketpair() type argument.

// Option flags per-socket.

// Additional options, not kept in so_options.

// Space reserved for new socket options added by third-party vendors.
// This range applies to all socket option levels.  New socket options
// in FreeBSD should always use an option value less than SO_VENDOR.

// Structure used for manipulating linger option.
type linger = struct {
	l_onoff  int32
	l_linger int32
} /* socket.h:198:1 */

type accept_filter_arg = struct {
	af_name [16]int8
	af_arg  [240]int8
} /* socket.h:204:1 */

// Level number for (get/set)sockopt() to apply to socket itself.

// Address families.
// When allocating a new AF_ constant, please only allocate
// even numbered constants for FreeBSD until 134 as odd numbered AF_
// constants 39-133 are now reserved for vendors.

// Structure used by kernel to store most
// addresses.
type sockaddr = struct {
	sa_len    uint8
	sa_family sa_family_t
	sa_data   [14]int8
} /* socket.h:328:1 */

// Structure used by kernel to pass protocol
// information in raw sockets.
type sockproto = struct {
	sp_family   uint16
	sp_protocol uint16
} /* socket.h:340:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)socket.h	8.4 (Berkeley) 2/21/94
// $FreeBSD$

// RFC 2553: protocol-independent placeholder for socket addresses

type sockaddr_storage = struct {
	ss_len     uint8
	ss_family  sa_family_t
	__ss_pad1  [6]int8
	__ss_align int64
	__ss_pad2  [112]int8
} /* _sockaddr_storage.h:48:1 */

// Protocol families, same as address families for now.

// Definitions for network related sysctl, CTL_NET.
//
// Second level is protocol family.
// Third level is protocol number.
//
// Further levels are defined by the individual families.

// PF_ROUTE - Routing table
//
// Three additional levels are defined:
//	Fourth: address family, 0 is wildcard
//	Fifth: type of info, defined below
//	Sixth: flag(s) to mask with for NET_RT_FLAGS

// Maximum queue length specifiable by listen.

// Message header for recvmsg and sendmsg calls.
// Used value-result for recvmsg, value only for sendmsg.
type msghdr = struct {
	msg_name       uintptr
	msg_namelen    socklen_t
	_              [4]byte
	msg_iov        uintptr
	msg_iovlen     int32
	_              [4]byte
	msg_control    uintptr
	msg_controllen socklen_t
	msg_flags      int32
} /* socket.h:432:1 */

//			 0x00000200	   unused
//			 0x00000400	   unused
//			 0x00000800	   unused
//			 0x00001000	   unused

// Header for ancillary data objects in msg_control buffer.
// Used for additional information with/about a datagram
// not expressible by flags.  The format is a sequence
// of message elements headed by cmsghdr structures.
type cmsghdr = struct {
	cmsg_len   socklen_t
	cmsg_level int32
	cmsg_type  int32
} /* socket.h:481:1 */

// While we may have more groups than this, the cmsgcred struct must
// be able to fit in an mbuf and we have historically supported a
// maximum of 16 groups.

// Credentials structure, used to verify the identity of a peer
// process that has sent us a message. This is allocated by the
// peer process but filled in by the kernel. This prevents the
// peer from lying about its identity. (Note that cmcred_groups[0]
// is the effective GID.)
type cmsgcred = struct {
	cmcred_pid     pid_t
	cmcred_uid     uid_t
	cmcred_euid    uid_t
	cmcred_gid     gid_t
	cmcred_ngroups int16
	_              [2]byte
	cmcred_groups  [16]gid_t
} /* socket.h:503:1 */

// Socket credentials (LOCAL_CREDS).
type sockcred = struct {
	sc_uid     uid_t
	sc_euid    uid_t
	sc_gid     gid_t
	sc_egid    gid_t
	sc_ngroups int32
	sc_groups  [1]gid_t
} /* socket.h:515:1 */

// Compute size of a sockcred structure with groups.

// Socket credentials (LOCAL_CREDS_PERSISTENT).
type sockcred2 = struct {
	sc_version int32
	sc_pid     pid_t
	sc_uid     uid_t
	sc_euid    uid_t
	sc_gid     gid_t
	sc_egid    gid_t
	sc_ngroups int32
	sc_groups  [1]gid_t
} /* socket.h:533:1 */

// given pointer to struct cmsghdr, return pointer to data

// given pointer to struct cmsghdr, return pointer to next cmsghdr

// RFC 2292 requires to check msg_controllen, in case that the kernel returns
// an empty list for some reasons.

// RFC 2292 additions

// "Socket"-level control message types:

type sock_timestamp_info = struct {
	st_info_flags uint32
	st_info_pad0  uint32
	st_info_rsv   [7]uint64
} /* socket.h:592:1 */

// 4.3 compat sockaddr, move to compat file later
type osockaddr = struct {
	sa_family uint16
	sa_data   [14]int8
} /* socket.h:607:1 */

// 4.3-compat message header (move to compat file later).
type omsghdr = struct {
	msg_name         uintptr
	msg_namelen      int32
	_                [4]byte
	msg_iov          uintptr
	msg_iovlen       int32
	_                [4]byte
	msg_accrights    uintptr
	msg_accrightslen int32
	_                [4]byte
} /* socket.h:615:1 */

// howto arguments for shutdown(2), specified by Posix.1g.

// for SCTP
// we cheat and use the SHUT_XX defines for these

// sendfile(2) header/trailer struct
type sf_hdtr = struct {
	headers  uintptr
	hdr_cnt  int32
	_        [4]byte
	trailers uintptr
	trl_cnt  int32
	_        [4]byte
} /* socket.h:644:1 */

// Sendfile-specific flag(s)

// Sendmmsg/recvmmsg specific structure(s)
type mmsghdr = struct {
	msg_hdr struct {
		msg_name       uintptr
		msg_namelen    socklen_t
		_              [4]byte
		msg_iov        uintptr
		msg_iovlen     int32
		_              [4]byte
		msg_control    uintptr
		msg_controllen socklen_t
		msg_flags      int32
	}
	msg_len ssize_t
} /* socket.h:668:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1994
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chuck Karish of Mindcraft, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)utsname.h	8.1 (Berkeley) 1/4/94
// $FreeBSD$

type utsname = struct {
	sysname  [256]int8
	nodename [256]int8
	release  [256]int8
	version  [256]int8
	machine  [256]int8
} /* utsname.h:49:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)in.h	8.3 (Berkeley) 1/3/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1987, 1991 Regents of the University of California.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)endian.h	7.8 (Berkeley) 4/3/91
// $FreeBSD$

// Protocols common to RFC 1700, POSIX, and X/Open.

// Internet address (a structure for historical reasons).
type in_addr = struct{ s_addr in_addr_t } /* in.h:83:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)socket.h	8.4 (Berkeley) 2/21/94
// $FreeBSD$

// Socket address, internet style.
type sockaddr_in = struct {
	sin_len    uint8_t
	sin_family sa_family_t
	sin_port   in_port_t
	sin_addr   struct{ s_addr in_addr_t }
	sin_zero   [8]int8
} /* in.h:97:1 */

// Constants and structures defined by the internet system,
// Per RFC 790, September 1981, and numerous additions.

// Protocols (RFC 1700)
// 101-254: Partly Unassigned
// 255: Reserved
// BSD Private, local use, namespace incursion, no longer used

// last return value of *_input(), meaning "all job for this pkt is done".

// Only used internally, so can be outside the range of valid IP protocols.

// Defined to avoid confusion.  The master value is defined by
// PROTO_SPACER in sys/protosw.h.

// Local port number conventions:
//
// When a user does a bind(2) or connect(2) with a port number of zero,
// a non-conflicting local port address is chosen.
// The default range is IPPORT_HIFIRSTAUTO through
// IPPORT_HILASTAUTO, although that is settable by sysctl.
//
// A user may set the IPPROTO_IP option IP_PORTRANGE to change this
// default assignment range.
//
// The value IP_PORTRANGE_DEFAULT causes the default behavior.
//
// The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
// into the "high" range.  These are reserved for client outbound connections
// which do not want to be filtered by any firewalls.
//
// The value IP_PORTRANGE_LOW changes the range to the "low" are
// that is (by convention) restricted to privileged processes.  This
// convention is based on "vouchsafe" principles only.  It is only secure
// if you trust the remote host to restrict these ports.
//
// The default range of ports and the high range can be changed by
// sysctl(3).  (net.inet.ip.portrange.{hi,low,}{first,last})
//
// Changing those values has bad security implications if you are
// using a stateless firewall that is allowing packets outside of that
// range in order to allow transparent outgoing connections.
//
// Such a firewall configuration will generally depend on the use of these
// default values.  If you change them, you may find your Security
// Administrator looking for you with a heavy object.
//
// For a slightly more orthodox text view on this:
//
//            ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers
//
//    port numbers are divided into three ranges:
//
//                0 -  1023 Well Known Ports
//             1024 - 49151 Registered Ports
//            49152 - 65535 Dynamic and/or Private Ports
//

// Ports < IPPORT_RESERVED are reserved for
// privileged processes (e.g. root).         (IP_PORTRANGE_LOW)

// Default local port range, used by IP_PORTRANGE_DEFAULT

// Dynamic port range, used by IP_PORTRANGE_HIGH.

// Scanning for a free reserved port return a value below IPPORT_RESERVED,
// but higher than IPPORT_RESERVEDSTART.  Traditionally the start value was
// 512, but that conflicts with some well-known-services that firewalls may
// have a fit if we use.

// Definitions of bits in internet address integers.
// On subnets, the decomposition of addresses to host and net parts
// is done according to subnet mask, not the masks here.

// Options for use with [gs]etsockopt at the IP level.
// First word of comment is data type; bool is stored in int.
// for IPSEC
// unused; was IP_FAITH

// Options for controlling the firewall and dummynet.
// Historical options (from 40 to 64) will eventually be
// replaced by only two options, IP_FW3 and IP_DUMMYNET3.

// IPv4 Source Filter Multicast API [RFC3678]

// The following option is private; do not use it from user applications.

// The following option deals with the 802.1Q Ethernet Priority Code Point
//      -1 use interface default

// Protocol Independent Multicast API [RFC3678]

// Flow and RSS definitions

// Defaults and limits for options

// Limit for IPv4 multicast memberships

// Default resource limits for IPv4 multicast source filtering.
// These may be modified by sysctl.

// Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
type ip_mreq = struct {
	imr_multiaddr struct{ s_addr in_addr_t }
	imr_interface struct{ s_addr in_addr_t }
} /* in.h:527:1 */

// Modified argument structure for IP_MULTICAST_IF, obtained from Linux.
// This is used to specify an interface index for multicast sends, as
// the IPv4 legacy APIs do not support this (unless IP_SENDIF is available).
type ip_mreqn = struct {
	imr_multiaddr struct{ s_addr in_addr_t }
	imr_address   struct{ s_addr in_addr_t }
	imr_ifindex   int32
} /* in.h:537:1 */

// Argument structure for IPv4 Multicast Source Filter APIs. [RFC3678]
type ip_mreq_source = struct {
	imr_multiaddr  struct{ s_addr in_addr_t }
	imr_sourceaddr struct{ s_addr in_addr_t }
	imr_interface  struct{ s_addr in_addr_t }
} /* in.h:546:1 */

// Argument structures for Protocol-Independent Multicast Source
// Filter APIs. [RFC3678]
type group_req = struct {
	gr_interface uint32_t
	_            [4]byte
	gr_group     struct {
		ss_len     uint8
		ss_family  sa_family_t
		__ss_pad1  [6]int8
		__ss_align int64
		__ss_pad2  [112]int8
	}
} /* in.h:556:1 */

type group_source_req = struct {
	gsr_interface uint32_t
	_             [4]byte
	gsr_group     struct {
		ss_len     uint8
		ss_family  sa_family_t
		__ss_pad1  [6]int8
		__ss_align int64
		__ss_pad2  [112]int8
	}
	gsr_source struct {
		ss_len     uint8
		ss_family  sa_family_t
		__ss_pad1  [6]int8
		__ss_align int64
		__ss_pad2  [112]int8
	}
} /* in.h:561:1 */

// The following structure is private; do not use it from user applications.
// It is used to communicate IP_MSFILTER/IPV6_MSFILTER information between
// the RFC 3678 libc functions and the kernel.
type __msfilterreq = struct {
	msfr_ifindex uint32_t
	msfr_fmode   uint32_t
	msfr_nsrcs   uint32_t
	_            [4]byte
	msfr_group   struct {
		ss_len     uint8
		ss_family  sa_family_t
		__ss_pad1  [6]int8
		__ss_align int64
		__ss_pad2  [112]int8
	}
	msfr_srcs uintptr
} /* in.h:574:1 */

// Filter modes; also used to represent per-socket filter mode internally.

// Argument for IP_PORTRANGE:
// - which range to search when port is unspecified at bind() or connect()

// Identifiers for IP sysctl nodes
//	IPCTL_RTEXPIRE		5	deprecated
//	IPCTL_RTMINEXPIRE	6	deprecated
//	IPCTL_RTMAXCACHE	7	deprecated
// 15, unused, was: IPCTL_KEEPFAITH

// INET6 stuff
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the project nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	$KAME: in6.h,v 1.89 2001/05/27 13:28:35 itojun Exp $

// -
// Copyright (c) 1982, 1986, 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)in.h	8.3 (Berkeley) 1/3/94
// $FreeBSD$

// Identification of the network protocol stack
// for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
// has the table of implementation/integration differences.

// IPv6 port allocation rules should mirror the IPv4 rules and are controlled
// by the net.inet.ip.portrange sysctl tree. The following defines exist
// for compatibility with userland applications that need them.

// IPv6 address
type in6_addr = struct {
	__u6_addr struct {
		_          [0]uint32
		__u6_addr8 [16]uint8_t
	}
} /* in6.h:97:1 */

// XXX missing POSIX.1-2001 macro IPPROTO_IPV6.

// Socket address for IPv6

type sockaddr_in6 = struct {
	sin6_len      uint8_t
	sin6_family   sa_family_t
	sin6_port     in_port_t
	sin6_flowinfo uint32_t
	sin6_addr     struct {
		__u6_addr struct {
			_          [0]uint32
			__u6_addr8 [16]uint8_t
		}
	}
	sin6_scope_id uint32_t
} /* in6.h:125:1 */

type route_in6 = struct {
	ro_nh      uintptr
	ro_lle     uintptr
	ro_prepend uintptr
	ro_plen    uint16_t
	ro_flags   uint16_t
	ro_mtu     uint16_t
	spare      uint16_t
	ro_dst     struct {
		sin6_len      uint8_t
		sin6_family   sa_family_t
		sin6_port     in_port_t
		sin6_flowinfo uint32_t
		sin6_addr     struct {
			__u6_addr struct {
				_          [0]uint32
				__u6_addr8 [16]uint8_t
			}
		}
		sin6_scope_id uint32_t
	}
	_ [4]byte
} /* in6.h:379:1 */

// Options for use with [gs]etsockopt at the IPV6 level.
// First word of comment is data type; bool is stored in int.
// no hdrincl
// RFC2292 options

// 29; unused; was IPV6_FAITH

// new socket options introduced in RFC3542

// more new socket options introduced in RFC3542

// The following option is private; do not use it from user applications.
// It is deliberately defined to the same value as IP_MSFILTER.

// The following option deals with the 802.1Q Ethernet Priority Code Point
//      -1 use interface default

// to define items, should talk with KAME guys first, for *BSD compatibility

// Defaults and limits for options

// Limit for IPv6 multicast memberships

// Default resource limits for IPv6 multicast source filtering.
// These may be modified by sysctl.

// Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP.
type ipv6_mreq = struct {
	ipv6mr_multiaddr struct {
		__u6_addr struct {
			_          [0]uint32
			__u6_addr8 [16]uint8_t
		}
	}
	ipv6mr_interface uint32
} /* in6.h:545:1 */

// IPV6_PKTINFO: Packet information(RFC2292 sec 5)
type in6_pktinfo = struct {
	ipi6_addr struct {
		__u6_addr struct {
			_          [0]uint32
			__u6_addr8 [16]uint8_t
		}
	}
	ipi6_ifindex uint32
} /* in6.h:553:1 */

// Control structure for IPV6_RECVPATHMTU socket option.
type ip6_mtuinfo = struct {
	ip6m_addr struct {
		sin6_len      uint8_t
		sin6_family   sa_family_t
		sin6_port     in_port_t
		sin6_flowinfo uint32_t
		sin6_addr     struct {
			__u6_addr struct {
				_          [0]uint32
				__u6_addr8 [16]uint8_t
			}
		}
		sin6_scope_id uint32_t
	}
	ip6m_mtu uint32_t
} /* in6.h:561:1 */

//! \file
// -
// SPDX-License-Identifier: (BSD-3-Clause AND ISC)
//
// Copyright (c) 1980, 1983, 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// -
// Portions Copyright (c) 1993 by Digital Equipment Corporation.
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies, and that
// the name of Digital Equipment Corporation not be used in advertising or
// publicity pertaining to distribution of the document or software without
// specific, written prior permission.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
// WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
// CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
// DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
// PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
// ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
// SOFTWARE.
// -
// --Copyright--

//      @(#)netdb.h	8.1 (Berkeley) 6/2/93
//      From: Id: netdb.h,v 8.9 1996/11/19 08:39:29 vixie Exp $
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Structures returned by network data base library.  All addresses are
// supplied in host order, and returned in network order (suitable for
// use in system calls).
type hostent = struct {
	h_name      uintptr
	h_aliases   uintptr
	h_addrtype  int32
	h_length    int32
	h_addr_list uintptr
} /* netdb.h:106:1 */

type netent = struct {
	n_name     uintptr
	n_aliases  uintptr
	n_addrtype int32
	n_net      uint32_t
} /* netdb.h:115:1 */

type servent = struct {
	s_name    uintptr
	s_aliases uintptr
	s_port    int32
	_         [4]byte
	s_proto   uintptr
} /* netdb.h:122:1 */

type protoent = struct {
	p_name    uintptr
	p_aliases uintptr
	p_proto   int32
	_         [4]byte
} /* netdb.h:129:1 */

type addrinfo = struct {
	ai_flags     int32
	ai_family    int32
	ai_socktype  int32
	ai_protocol  int32
	ai_addrlen   socklen_t
	_            [4]byte
	ai_canonname uintptr
	ai_addr      uintptr
	ai_next      uintptr
} /* netdb.h:135:1 */

//---------------------------------------------------------------------------
// Darwin specifc configure overrides.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following macros and declarations represent the interface between
// generic and unix-specific parts of Tcl. Some of the macros may override
// functions declared in tclInt.h.
//---------------------------------------------------------------------------

// The default platform eol translation on Unix is TCL_TRANSLATE_LF.

//---------------------------------------------------------------------------
// The following macros have trivial definitions, allowing generic code to
// address platform-specific issues.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following defines wrap the system memory allocation routines.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following macros and declaration wrap the C runtime library functions.
//---------------------------------------------------------------------------

// FIXME - Hyper-enormous platform assumption!

//---------------------------------------------------------------------------
// Set of MT-safe implementations of some known-to-be-MT-unsafe library calls.
// Instead of returning pointers to the static storage, those return pointers
// to the TSD data.
//---------------------------------------------------------------------------

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)pwd.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)grp.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type group = struct {
	gr_name   uintptr
	gr_passwd uintptr
	gr_gid    gid_t
	_         [4]byte
	gr_mem    uintptr
} /* grp.h:58:1 */

type Tcl_StatBuf = stat /* tcl.h:485:25 */

//----------------------------------------------------------------------------
// Override definitions for libtommath.

type mp_int = mp_int1 /* tcl.h:2250:23 */

// Use inline functions if we are allowed to and the compiler supports them.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Paul Borman at Krystal Technologies.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)runetype.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// The lower 8 bits of runetype[] contain the digit value of the rune.
type _RuneEntry = struct {
	__min   int32
	__max   int32
	__map   int32
	_       [4]byte
	__types uintptr
} /* runetype.h:55:3 */

type _RuneRange = struct {
	__nranges int32
	_         [4]byte
	__ranges  uintptr
} /* runetype.h:60:3 */

type _RuneLocale = struct {
	__magic        [8]int8
	__encoding     [32]int8
	__sgetrune     uintptr
	__sputrune     uintptr
	__invalid_rune int32
	_              [4]byte
	__runetype     [256]uint64
	__maplower     [256]int32
	__mapupper     [256]int32
	__runetype_ext _RuneRange
	__maplower_ext _RuneRange
	__mapupper_ext _RuneRange
	__variable     uintptr
	__variable_len int32
	_              [4]byte
} /* runetype.h:85:3 */

func __getCurrentRuneLocale(tls *libc.TLS) uintptr { /* runetype.h:95:35: */

	if libc.X_ThreadRuneLocale != 0 {
		return libc.X_ThreadRuneLocale
	}
	return libc.X_CurrentRuneLocale
}

func __maskrune(tls *libc.TLS, _c int32, _f uint64) int32 { /* _ctype.h:100:1: */
	return int32(func() uint64 {
		if _c < 0 || _c >= int32(1)<<8 {
			return libc.X___runetype(tls, _c)
		}
		return *(*uint64)(unsafe.Pointer(__getCurrentRuneLocale(tls) + 64 + uintptr(_c)*8))
	}() & _f)
}

func __sbmaskrune(tls *libc.TLS, _c int32, _f uint64) int32 { /* _ctype.h:107:1: */
	if _c < 0 || _c >= libc.X__mb_sb_limit {
		return 0
	}
	return int32(*(*uint64)(unsafe.Pointer(__getCurrentRuneLocale(tls) + 64 + uintptr(_c)*8)) & _f)
}

func __sbmaskrune_l(tls *libc.TLS, __c int32, __f uint64, __loc locale_t) int32 { /* _ctype.h:104:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __limit int32 at bp, 4

	var runes uintptr = libc.X__runes_for_locale(tls, __loc, bp)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return 0
	}
	return int32(*(*uint64)(unsafe.Pointer(runes + 64 + uintptr(__c)*8)) & __f)
}

func __sbistype_l(tls *libc.TLS, __c int32, __f uint64, __loc locale_t) int32 { /* _ctype.h:113:1: */
	return libc.BoolInt32(!!(tcl.X__sbmaskrune_l(tls, __c, __f, __loc) != 0))
}

func isalnum_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:124:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_A|X_CTYPE_D|X_CTYPE_N), __l)
}

func isalpha_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:125:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_A), __l)
}

func isblank_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:126:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_B), __l)
}

func iscntrl_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:127:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_C), __l)
}

func isdigit_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:128:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_D), __l)
}

func isgraph_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:129:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_G), __l)
}

func ishexnumber_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:130:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_X), __l)
}

func isideogram_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:131:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_I), __l)
}

func islower_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:132:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_L), __l)
}

func isnumber_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:133:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_D|X_CTYPE_N), __l)
}

func isphonogram_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:134:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_Q), __l)
}

func isprint_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:135:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_R), __l)
}

func ispunct_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:136:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_P), __l)
}

func isrune_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:137:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(0xFFFFFF00), __l)
}

func isspace_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:138:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_S), __l)
}

func isspecial_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:139:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_T), __l)
}

func isupper_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:140:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_U), __l)
}

func isxdigit_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:141:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_X), __l)
}

func digittoint_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:186:21: */
	return tcl.X__sbmaskrune_l(tls, __c, uint64(0xFF), __l)
}

func tolower_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:189:21: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __limit int32 at bp, 4

	var __runes uintptr = libc.X__runes_for_locale(tls, __l, bp)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return __c
	}
	return *(*int32)(unsafe.Pointer(__runes + 2112 + uintptr(__c)*4))
}

func toupper_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:196:21: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __limit int32 at bp, 4

	var __runes uintptr = libc.X__runes_for_locale(tls, __l, bp)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return __c
	}
	return *(*int32)(unsafe.Pointer(__runes + 3136 + uintptr(__c)*4))
}

// POSIX.1-2001 specifies _tolower() and _toupper() to be macros equivalent to
// tolower() and toupper() respectively, minus extra checking to ensure that
// the argument is a lower or uppercase letter respectively.  We've chosen to
// implement these macros with the same error checking as tolower() and
// toupper() since this doesn't violate the specification itself, only its
// intent.  We purposely leave _tolower() and _toupper() undocumented to
// discourage their use.
//
// XXX isascii() and toascii() should similarly be undocumented.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2003 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type rune_t = int32 /* stdlib.h:46:18 */

type div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:66:3 */

type ldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:71:3 */

// Functions added in C99 which we make conditionally available in the
// BSD^C89 namespace if the compiler supports `long long'.
// The #if test is more complicated than it ought to be because
// __BSD_VISIBLE implies __ISO_C_VISIBLE == 1999 *even if* `long long'
// is not supported in the compilation environment (which therefore means
// that it can't really be ISO C99).
//
// (The only other extension made by C99 in thie header is _Exit().)
// LONGLONG
type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:142:3 */ // getsubopt(3) external variable

// K.3.6
type constraint_handler_t = uintptr /* stdlib.h:349:14 */

type max_align_t = struct {
	__max_align1 int64
	__max_align2 float64
} /* stddef.h:69:23 */

// ISO/IEC 9899:2011 K.3.3.2

// Ensure WORDS_BIGENDIAN is defined correctly:
// Needs to happen here in addition to configure to work with fat compiles on
// Darwin (where configure runs only once for multiple architectures).

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.6 (Berkeley) 2/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)param.h	8.3 (Berkeley) 4/4/95
// $FreeBSD$

// Used to tag functions that are only to be visible within the module being
// built and not outside it (where this is supported by the linker).

// Macros used to cast between pointers and integers (e.g. when storing an int
// in ClientData), on 64-bit architectures they avoid gcc warning about "cast
// to/from pointer from/to integer of different size".

// The following procedures allow namespaces to be customized to support
// special name resolution rules for commands/variables.

type Tcl_ResolvedVarInfo1 = struct {
	fetchProc  uintptr
	deleteProc uintptr
} /* tclInt.h:131:1 */

// The following structure encapsulates the routines needed to resolve a
// variable reference at runtime. Any variable specific state will typically
// be appended to this structure.

type Tcl_ResolvedVarInfo = Tcl_ResolvedVarInfo1 /* tclInt.h:147:3 */

type Tcl_ResolverInfo1 = struct {
	cmdResProc         uintptr
	varResProc         uintptr
	compiledVarResProc uintptr
} /* tclInt.h:159:9 */

type Tcl_ResolverInfo = Tcl_ResolverInfo1 /* tclInt.h:170:3 */
type NamespacePathEntry1 = struct {
	nsPtr        uintptr
	creatorNsPtr uintptr
	prevPtr      uintptr
	nextPtr      uintptr
} /* tclInt.h:194:9 */

type NamespacePathEntry = NamespacePathEntry1 /* tclInt.h:194:35 */

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type TclVarHashTable1 = struct {
	table Tcl_HashTable
	nsPtr uintptr
} /* tclInt.h:194:9 */

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type Namespace1 = struct {
	name                  uintptr
	fullName              uintptr
	clientData            ClientData
	deleteProc            uintptr
	parentPtr             uintptr
	childTable            Tcl_HashTable
	nsId                  int64
	interp                uintptr
	flags                 int32
	activationCount       int32
	refCount              int32
	_                     [4]byte
	cmdTable              Tcl_HashTable
	varTable              TclVarHashTable
	exportArrayPtr        uintptr
	numExportPatterns     int32
	maxExportPatterns     int32
	cmdRefEpoch           int32
	resolverEpoch         int32
	cmdResProc            uintptr
	varResProc            uintptr
	compiledVarResProc    uintptr
	exportLookupEpoch     int32
	_                     [4]byte
	ensembles             uintptr
	unknownHandlerPtr     uintptr
	commandPathLength     int32
	_                     [4]byte
	commandPathArray      uintptr
	commandPathSourceList uintptr
	earlyDeleteProc       uintptr
} /* tclInt.h:194:9 */

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type TclVarHashTable = TclVarHashTable1 /* tclInt.h:206:3 */

// This is for itcl - it likes to search our varTables directly :(

// Define this to reduce the amount of space that the average namespace
// consumes by only allocating the table of child namespaces when necessary.
// Defining it breaks compatibility for Tcl extensions (e.g., itcl) which
// reach directly into the Namespace structure.

// The structure below defines a namespace.
// Note: the first five fields must match exactly the fields in a
// Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
// the other.

type Namespace = Namespace1 /* tclInt.h:345:3 */

// Flags used to represent the status of a namespace:
//
// NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace but there are still active call frames on the Tcl
//		stack that refer to the namespace. When the last call frame
//		referring to it has been popped, it's variables and command
//		will be destroyed and it will be marked "dead" (NS_DEAD). The
//		namespace can no longer be looked up by name.
// NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace and no call frames still refer to it. Its variables
//		and command have already been destroyed. This bit allows the
//		namespace resolution code to recognize that the namespace is
//		"deleted". When the last namespaceName object in any byte code
//		unit that refers to the namespace has been freed (i.e., when
//		the namespace's refCount is 0), the namespace's storage will
//		be freed.
// NS_KILLED -	1 means that TclTeardownNamespace has already been called on
//		this namespace and it should not be called again [Bug 1355942]
// NS_SUPPRESS_COMPILATION -
//		Marks the commands in this namespace for not being compiled,
//		forcing them to be looked up every time.

// Flags passed to TclGetNamespaceForQualName:
//
// TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
// TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
// TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
// TCL_FIND_ONLY_NS		- The name sought is a namespace name.

// The client data for an ensemble command. This consists of the table of
// commands that are actually exported by the namespace, and an epoch counter
// that, combined with the exportLookupEpoch field of the namespace structure,
// defines whether the table contains valid data or will need to be recomputed
// next time the ensemble command is called.

type EnsembleConfig1 = struct {
	nsPtr              uintptr
	token              Tcl_Command
	epoch              int32
	_                  [4]byte
	subcommandArrayPtr uintptr
	subcommandTable    Tcl_HashTable
	next               uintptr
	flags              int32
	_                  [4]byte
	subcommandDict     uintptr
	subcmdList         uintptr
	unknownHandler     uintptr
	parameterList      uintptr
	numParameters      int32
	_                  [4]byte
} /* tclInt.h:415:9 */

// Flags used to represent the status of a namespace:
//
// NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace but there are still active call frames on the Tcl
//		stack that refer to the namespace. When the last call frame
//		referring to it has been popped, it's variables and command
//		will be destroyed and it will be marked "dead" (NS_DEAD). The
//		namespace can no longer be looked up by name.
// NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace and no call frames still refer to it. Its variables
//		and command have already been destroyed. This bit allows the
//		namespace resolution code to recognize that the namespace is
//		"deleted". When the last namespaceName object in any byte code
//		unit that refers to the namespace has been freed (i.e., when
//		the namespace's refCount is 0), the namespace's storage will
//		be freed.
// NS_KILLED -	1 means that TclTeardownNamespace has already been called on
//		this namespace and it should not be called again [Bug 1355942]
// NS_SUPPRESS_COMPILATION -
//		Marks the commands in this namespace for not being compiled,
//		forcing them to be looked up every time.

// Flags passed to TclGetNamespaceForQualName:
//
// TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
// TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
// TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
// TCL_FIND_ONLY_NS		- The name sought is a namespace name.

// The client data for an ensemble command. This consists of the table of
// commands that are actually exported by the namespace, and an epoch counter
// that, combined with the exportLookupEpoch field of the namespace structure,
// defines whether the table contains valid data or will need to be recomputed
// next time the ensemble command is called.

type EnsembleConfig = EnsembleConfig1 /* tclInt.h:483:3 */

// Various bits for the EnsembleConfig.flags field.

//----------------------------------------------------------------
// Data structures related to variables. These are used primarily in tclVar.c
//----------------------------------------------------------------

// The following structure defines a variable trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// variable.

type VarTrace1 = struct {
	traceProc  uintptr
	clientData ClientData
	flags      int32
	_          [4]byte
	nextPtr    uintptr
} /* tclInt.h:506:9 */

// Various bits for the EnsembleConfig.flags field.

//----------------------------------------------------------------
// Data structures related to variables. These are used primarily in tclVar.c
//----------------------------------------------------------------

// The following structure defines a variable trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// variable.

type VarTrace = VarTrace1 /* tclInt.h:516:3 */

// The following structure defines a command trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// command.

type CommandTrace1 = struct {
	traceProc  uintptr
	clientData ClientData
	flags      int32
	_          [4]byte
	nextPtr    uintptr
	refCount   int32
	_          [4]byte
} /* tclInt.h:524:9 */

// The following structure defines a command trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// command.

type CommandTrace = CommandTrace1 /* tclInt.h:539:3 */

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type ActiveCommandTrace1 = struct {
	cmdPtr       uintptr
	nextPtr      uintptr
	nextTracePtr uintptr
	reverseScan  int32
	_            [4]byte
} /* tclInt.h:548:9 */

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type Command1 = struct {
	hPtr          uintptr
	nsPtr         uintptr
	refCount      int32
	cmdEpoch      int32
	compileProc   uintptr
	objProc       uintptr
	objClientData ClientData
	proc          uintptr
	clientData    ClientData
	deleteProc    uintptr
	deleteData    ClientData
	flags         int32
	_             [4]byte
	importRefPtr  uintptr
	tracePtr      uintptr
	nreProc       uintptr
} /* tclInt.h:548:9 */

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type ActiveCommandTrace = ActiveCommandTrace1 /* tclInt.h:559:3 */

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveVarTrace1 = struct {
	varPtr       uintptr
	nextPtr      uintptr
	nextTracePtr uintptr
} /* tclInt.h:569:9 */

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type Var1 = struct {
	flags int32
	_     [4]byte
	value struct{ objPtr uintptr }
} /* tclInt.h:569:9 */

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveVarTrace = ActiveVarTrace1 /* tclInt.h:578:3 */

// The structure below defines a variable, which associates a string name with
// a Tcl_Obj value. These structures are kept in procedure call frames (for
// local variables recognized by the compiler) or in the heap (for global
// variables and any variable not known to the compiler). For each Var
// structure in the heap, a hash table entry holds the variable name and a
// pointer to the Var structure.

type Var = Var1 /* tclInt.h:604:3 */

type VarInHash1 = struct {
	__var    Var
	refCount int32
	_        [4]byte
	entry    Tcl_HashEntry
} /* tclInt.h:606:9 */

type VarInHash = VarInHash1 /* tclInt.h:621:3 */

// The variable-length structure below describes a local variable of a
// procedure that was recognized by the compiler. These variables have a name,
// an element in the array of compiler-assigned local variables in the
// procedure's call frame, and various other items of information. If the
// local variable is a formal argument, it may also have a default value. The
// compiler can't recognize local variables whose names are expressions (these
// names are only known at runtime when the expressions are evaluated) or
// local variables that are created as a result of an "upvar" or "uplevel"
// command. These other local variables are kept separately in a hash table in
// the call frame.

type CompiledLocal1 = struct {
	_           [0]uint64
	nextPtr     uintptr
	nameLength  int32
	frameIndex  int32
	flags       int32
	_           [4]byte
	defValuePtr uintptr
	resolveInfo uintptr
} /* tclInt.h:906:9 */

// The variable-length structure below describes a local variable of a
// procedure that was recognized by the compiler. These variables have a name,
// an element in the array of compiler-assigned local variables in the
// procedure's call frame, and various other items of information. If the
// local variable is a formal argument, it may also have a default value. The
// compiler can't recognize local variables whose names are expressions (these
// names are only known at runtime when the expressions are evaluated) or
// local variables that are created as a result of an "upvar" or "uplevel"
// command. These other local variables are kept separately in a hash table in
// the call frame.

type CompiledLocal = CompiledLocal1 /* tclInt.h:934:3 */

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Proc1 = struct {
	iPtr              uintptr
	refCount          int32
	_                 [4]byte
	cmdPtr            uintptr
	bodyPtr           uintptr
	numArgs           int32
	numCompiledLocals int32
	firstLocalPtr     uintptr
	lastLocalPtr      uintptr
} /* tclInt.h:942:9 */

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Interp1 = struct {
	result            uintptr
	freeProc          uintptr
	errorLine         int32
	_                 [4]byte
	stubTable         uintptr
	handle            TclHandle
	globalNsPtr       uintptr
	hiddenCmdTablePtr uintptr
	interpInfo        ClientData
	extra             struct {
		optimizer uintptr
		_         [80]byte
	}
	numLevels              int32
	maxNestingDepth        int32
	framePtr               uintptr
	varFramePtr            uintptr
	activeVarTracePtr      uintptr
	returnCode             int32
	_                      [4]byte
	rootFramePtr           uintptr
	lookupNsPtr            uintptr
	appendResult           uintptr
	appendAvl              int32
	appendUsed             int32
	packageTable           Tcl_HashTable
	packageUnknown         uintptr
	cmdCount               int32
	evalFlags              int32
	unused1                int32
	_                      [4]byte
	literalTable           LiteralTable
	compileEpoch           int32
	_                      [4]byte
	compiledProcPtr        uintptr
	resolverPtr            uintptr
	scriptFile             uintptr
	flags                  int32
	_                      [4]byte
	randSeed               int64
	tracePtr               uintptr
	assocData              uintptr
	execEnvPtr             uintptr
	emptyObjPtr            uintptr
	resultSpace            [201]int8
	_                      [7]byte
	objResultPtr           uintptr
	threadId               Tcl_ThreadId
	activeCmdTracePtr      uintptr
	activeInterpTracePtr   uintptr
	tracesForbiddingInline int32
	_                      [4]byte
	returnOpts             uintptr
	errorInfo              uintptr
	eiVar                  uintptr
	errorCode              uintptr
	ecVar                  uintptr
	returnLevel            int32
	_                      [4]byte
	limit                  struct {
		active            int32
		granularityTicker int32
		exceeded          int32
		cmdCount          int32
		cmdHandlers       uintptr
		cmdGranularity    int32
		_                 [4]byte
		time              Tcl_Time
		timeHandlers      uintptr
		timeGranularity   int32
		_                 [4]byte
		timeEvent         Tcl_TimerToken
		callbacks         Tcl_HashTable
	}
	ensembleRewrite struct {
		sourceObjs      uintptr
		numRemovedObjs  int32
		numInsertedObjs int32
	}
	chanMsg           uintptr
	cmdFramePtr       uintptr
	invokeCmdFramePtr uintptr
	invokeWord        int32
	_                 [4]byte
	linePBodyPtr      uintptr
	lineBCPtr         uintptr
	lineLABCPtr       uintptr
	lineLAPtr         uintptr
	scriptCLLocPtr    uintptr
	packagePrefer     int32
	_                 [4]byte
	varTraces         Tcl_HashTable
	varSearches       Tcl_HashTable
	allocCache        uintptr
	pendingObjDataPtr uintptr
	asyncReadyPtr     uintptr
	objectFoundation  uintptr
	deferredCallbacks uintptr
	asyncCancel       Tcl_AsyncHandler
	asyncCancelMsg    uintptr
	errorStack        uintptr
	upLiteral         uintptr
	callLiteral       uintptr
	innerLiteral      uintptr
	innerContext      uintptr
	resetErrorStack   int32
	_                 [4]byte
} /* tclInt.h:942:9 */

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Proc = Proc1 /* tclInt.h:969:3 */

// The structure below defines a command trace. This is used to allow Tcl
// clients to find out whenever a command is about to be executed.

type Trace1 = struct {
	level      int32
	_          [4]byte
	proc       uintptr
	clientData ClientData
	nextPtr    uintptr
	flags      int32
	_          [4]byte
	delProc    uintptr
} /* tclInt.h:942:9 */

// The structure below defines a command trace. This is used to allow Tcl
// clients to find out whenever a command is about to be executed.

type Trace = Trace1 /* tclInt.h:993:3 */

// When an interpreter trace is active (i.e. its associated procedure is
// executing), one of the following structures is linked into a list
// associated with the interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveInterpTrace1 = struct {
	nextPtr      uintptr
	nextTracePtr uintptr
	reverseScan  int32
	_            [4]byte
} /* tclInt.h:942:9 */

// When an interpreter trace is active (i.e. its associated procedure is
// executing), one of the following structures is linked into a list
// associated with the interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveInterpTrace = ActiveInterpTrace1 /* tclInt.h:1013:3 */

// Flag values designating types of execution traces. See tclTrace.c for
// related flag values.
//
// TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "enterstep" traces.
// TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "leavestep" traces.

// The structure below defines an entry in the assocData hash table which is
// associated with an interpreter. The entry contains a pointer to a function
// to call when the interpreter is deleted, and a pointer to a user-defined
// piece of data.

type AssocData1 = struct {
	proc       uintptr
	clientData ClientData
} /* tclInt.h:1037:9 */

// Flag values designating types of execution traces. See tclTrace.c for
// related flag values.
//
// TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "enterstep" traces.
// TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "leavestep" traces.

// The structure below defines an entry in the assocData hash table which is
// associated with an interpreter. The entry contains a pointer to a function
// to call when the interpreter is deleted, and a pointer to a user-defined
// piece of data.

type AssocData = AssocData1 /* tclInt.h:1040:3 */

// The structure below defines a call frame. A call frame defines a naming
// context for a procedure call: its local naming scope (for local variables)
// and its global naming scope (a namespace, perhaps the global :: namespace).
// A call frame can also define the naming context for a namespace eval or
// namespace inscope command: the namespace in which the command's code should
// execute. The Tcl_CallFrame structures exist only while procedures or
// namespace eval/inscope's are being executed, and provide a kind of Tcl call
// stack.
//
// WARNING!! The structure definition must be kept consistent with the
// Tcl_CallFrame structure in tcl.h. If you change one, change the other.

// Will be grown to contain: pointers to the varnames (allocated at the end),
// plus the init values for each variable (suitable to be memcopied on init)

type LocalCache1 = struct {
	refCount int32
	numVars  int32
	varName0 uintptr
} /* tclInt.h:942:9 */

// The structure below defines a call frame. A call frame defines a naming
// context for a procedure call: its local naming scope (for local variables)
// and its global naming scope (a namespace, perhaps the global :: namespace).
// A call frame can also define the naming context for a namespace eval or
// namespace inscope command: the namespace in which the command's code should
// execute. The Tcl_CallFrame structures exist only while procedures or
// namespace eval/inscope's are being executed, and provide a kind of Tcl call
// stack.
//
// WARNING!! The structure definition must be kept consistent with the
// Tcl_CallFrame structure in tcl.h. If you change one, change the other.

// Will be grown to contain: pointers to the varnames (allocated at the end),
// plus the init values for each variable (suitable to be memcopied on init)

type LocalCache = LocalCache1 /* tclInt.h:1065:3 */

type CallFrame1 = struct {
	nsPtr             uintptr
	isProcCallFrame   int32
	objc              int32
	objv              uintptr
	callerPtr         uintptr
	callerVarPtr      uintptr
	level             int32
	_                 [4]byte
	procPtr           uintptr
	varTablePtr       uintptr
	numCompiledLocals int32
	_                 [4]byte
	compiledLocals    uintptr
	clientData        ClientData
	localCachePtr     uintptr
	tailcallPtr       uintptr
} /* tclInt.h:942:9 */

type CallFrame = CallFrame1 /* tclInt.h:1129:3 */

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CmdFrame1 = struct {
	__type   int32
	level    int32
	line     uintptr
	nline    int32
	_        [4]byte
	framePtr uintptr
	nextPtr  uintptr
	data     struct {
		eval struct{ path uintptr }
		_    [8]byte
	}
	cmdObj uintptr
	cmd    uintptr
	len    int32
	_      [4]byte
	litarg uintptr
} /* tclInt.h:942:9 */

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CFWordBC1 = struct {
	framePtr uintptr
	pc       int32
	word     int32
	prevPtr  uintptr
	nextPtr  uintptr
	obj      uintptr
} /* tclInt.h:942:9 */

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CmdFrame = CmdFrame1 /* tclInt.h:1219:3 */

type CFWord1 = struct {
	framePtr uintptr
	word     int32
	refCount int32
} /* tclInt.h:1221:9 */

type CFWord = CFWord1 /* tclInt.h:1226:3 */

type CFWordBC = CFWordBC1 /* tclInt.h:1238:3 */

// Structure to record the locations of invisible continuation lines in
// literal scripts, as character offset from the beginning of the script. Both
// compiler and direct evaluator use this information to adjust their line
// counters when tracking through the script, because when it is invoked the
// continuation line marker as a whole has been removed already, meaning that
// the \n which was part of it is gone as well, breaking regular line
// tracking.
//
// These structures are allocated and filled by both the function
// TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
// file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
// file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
// TclCompileScript(), both found in the file "tclCompile.c". Their memory is
// released by the function TclFreeObj(), in the file "tclObj.c", and also by
// the function TclThreadFinalizeObjects(), in the same file.

type ContLineLoc1 = struct {
	_   [0]uint32
	num int32
} /* tclInt.h:942:9 */

// Structure to record the locations of invisible continuation lines in
// literal scripts, as character offset from the beginning of the script. Both
// compiler and direct evaluator use this information to adjust their line
// counters when tracking through the script, because when it is invoked the
// continuation line marker as a whole has been removed already, meaning that
// the \n which was part of it is gone as well, breaking regular line
// tracking.
//
// These structures are allocated and filled by both the function
// TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
// file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
// file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
// TclCompileScript(), both found in the file "tclCompile.c". Their memory is
// released by the function TclFreeObj(), in the file "tclObj.c", and also by
// the function TclThreadFinalizeObjects(), in the same file.

type ContLineLoc = ContLineLoc1 /* tclInt.h:1269:3 */
type ExtraFrameInfoField = struct {
	name       uintptr
	proc       uintptr
	clientData ClientData
} /* tclInt.h:1309:3 */
type ExtraFrameInfo = struct {
	length int32
	_      [4]byte
	fields [2]ExtraFrameInfoField
} /* tclInt.h:1315:3 */

//----------------------------------------------------------------
// Data structures and procedures related to TclHandles, which are a very
// lightweight method of preserving enough information to determine if an
// arbitrary malloc'd block has been deleted.
//----------------------------------------------------------------

type TclHandle = uintptr /* tclInt.h:1325:14 */

// The data structure for a (linked list of) execution stacks.

type ExecStack1 = struct {
	_         [0]uint64
	prevPtr   uintptr
	nextPtr   uintptr
	markerPtr uintptr
	endPtr    uintptr
	tosPtr    uintptr
} /* tclInt.h:942:9 */

// The data structure for a (linked list of) execution stacks.

type ExecStack = ExecStack1 /* tclInt.h:1413:3 */

// The data structure defining the execution environment for ByteCode's.
// There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
// stack that holds command operands and results. The stack grows towards
// increasing addresses. The member stackPtr points to the stackItems of the
// currently active execution stack.

type CorContext1 = struct {
	framePtr    uintptr
	varFramePtr uintptr
	cmdFramePtr uintptr
	lineLABCPtr uintptr
} /* tclInt.h:942:9 */

// The data structure defining the execution environment for ByteCode's.
// There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
// stack that holds command operands and results. The stack grows towards
// increasing addresses. The member stackPtr points to the stackItems of the
// currently active execution stack.

type CorContext = CorContext1 /* tclInt.h:1428:3 */

type CoroutineData1 = struct {
	cmdPtr       uintptr
	eePtr        uintptr
	callerEEPtr  uintptr
	caller       CorContext
	running      CorContext
	lineLABCPtr  uintptr
	stackLevel   uintptr
	auxNumLevels int32
	nargs        int32
} /* tclInt.h:942:9 */

type ExecEnv1 = struct {
	execStackPtr uintptr
	constants    [2]uintptr
	interp       uintptr
	callbackPtr  uintptr
	corPtr       uintptr
	rewind       int32
	_            [4]byte
} /* tclInt.h:942:9 */

type CoroutineData = CoroutineData1 /* tclInt.h:1449:3 */

type NRE_callback1 = struct {
	procPtr uintptr
	data    [4]ClientData
	nextPtr uintptr
} /* tclInt.h:942:9 */

type ExecEnv = ExecEnv1 /* tclInt.h:1460:3 */

// The definitions for the LiteralTable and LiteralEntry structures. Each
// interpreter contains a LiteralTable. It is used to reduce the storage
// needed for all the Tcl objects that hold the literals of scripts compiled
// by the interpreter. A literal's object is shared by all the ByteCodes that
// refer to the literal. Each distinct literal has one LiteralEntry entry in
// the LiteralTable. A literal table is a specialized hash table that is
// indexed by the literal's string representation, which may contain null
// characters.
//
// Note that we reduce the space needed for literals by sharing literal
// objects both within a ByteCode (each ByteCode contains a local
// LiteralTable) and across all an interpreter's ByteCodes (with the
// interpreter's global LiteralTable).

type LiteralEntry1 = struct {
	nextPtr  uintptr
	objPtr   uintptr
	refCount int32
	_        [4]byte
	nsPtr    uintptr
} /* tclInt.h:942:9 */

// The definitions for the LiteralTable and LiteralEntry structures. Each
// interpreter contains a LiteralTable. It is used to reduce the storage
// needed for all the Tcl objects that hold the literals of scripts compiled
// by the interpreter. A literal's object is shared by all the ByteCodes that
// refer to the literal. Each distinct literal has one LiteralEntry entry in
// the LiteralTable. A literal table is a specialized hash table that is
// indexed by the literal's string representation, which may contain null
// characters.
//
// Note that we reduce the space needed for literals by sharing literal
// objects both within a ByteCode (each ByteCode contains a local
// LiteralTable) and across all an interpreter's ByteCodes (with the
// interpreter's global LiteralTable).

type LiteralEntry = LiteralEntry1 /* tclInt.h:1496:3 */

type LiteralTable1 = struct {
	buckets       uintptr
	staticBuckets [4]uintptr
	numBuckets    int32
	numEntries    int32
	rebuildSize   int32
	mask          int32
} /* tclInt.h:942:9 */

type LiteralTable = LiteralTable1 /* tclInt.h:1512:3 */

// The following structure defines for each Tcl interpreter various
// statistics-related information about the bytecode compiler and
// interpreter's operation in that interpreter.

// Structure used in implementation of those core ensembles which are
// partially compiled. Used as an array of these, with a terminating field
// whose 'name' is NULL.

type EnsembleImplMap = struct {
	name        uintptr
	proc        uintptr
	compileProc uintptr
	nreProc     uintptr
	clientData  ClientData
	unsafe      int32
	_           [4]byte
} /* tclInt.h:1566:3 */

//----------------------------------------------------------------
// Data structures related to commands.
//----------------------------------------------------------------

// An imported command is created in an namespace when it imports a "real"
// command from another namespace. An imported command has a Command structure
// that points (via its ClientData value) to the "real" Command structure in
// the source namespace's command table. The real command records all the
// imported commands that refer to it in a list of ImportRef structures so
// that they can be deleted when the real command is deleted.

type ImportRef1 = struct {
	importedCmdPtr uintptr
	nextPtr        uintptr
} /* tclInt.h:548:9 */

//----------------------------------------------------------------
// Data structures related to commands.
//----------------------------------------------------------------

// An imported command is created in an namespace when it imports a "real"
// command from another namespace. An imported command has a Command structure
// that points (via its ClientData value) to the "real" Command structure in
// the source namespace's command table. The real command records all the
// imported commands that refer to it in a list of ImportRef structures so
// that they can be deleted when the real command is deleted.

type ImportRef = ImportRef1 /* tclInt.h:1594:3 */

// Data structure used as the ClientData of imported commands: commands
// created in an namespace when it imports a "real" command from another
// namespace.

type ImportedCmdData1 = struct {
	realCmdPtr uintptr
	selfPtr    uintptr
} /* tclInt.h:1602:9 */

// Data structure used as the ClientData of imported commands: commands
// created in an namespace when it imports a "real" command from another
// namespace.

type ImportedCmdData = ImportedCmdData1 /* tclInt.h:1609:3 */

// A Command structure exists for each command in a namespace. The Tcl_Command
// opaque type actually refers to these structures.

type Command = Command1 /* tclInt.h:1659:3 */

// Flag bits for commands.
//
// CMD_IS_DELETED -		Means that the command is in the process of
//				being deleted (its deleteProc is currently
//				executing). Other attempts to delete the
//				command should be ignored.
// CMD_TRACE_ACTIVE -		1 means that trace processing is currently
//				underway for a rename/delete change. See the
//				two flags below for which is currently being
//				processed.
// CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
//				execution trace (as opposed to simple
//				delete/rename traces) in its tracePtr list.
// CMD_COMPILES_EXPANDED -	1 means that this command has a compiler that
//				can handle expansion (provided it is not the
//				first word).
// TCL_TRACE_RENAME -		A rename trace is in progress. Further
//				recursive renames will not be traced.
// TCL_TRACE_DELETE -		A delete trace is in progress. Further
//				recursive deletes will not be traced.
// (these last two flags are defined in tcl.h)

//----------------------------------------------------------------
// Data structures related to name resolution procedures.
//----------------------------------------------------------------

// The interpreter keeps a linked list of name resolution schemes. The scheme
// for a namespace is consulted first, followed by the list of schemes in an
// interpreter, followed by the default name resolution in Tcl. Schemes are
// added/removed from the interpreter's list by calling Tcl_AddInterpResolver
// and Tcl_RemoveInterpResolver.

type ResolverScheme1 = struct {
	name               uintptr
	cmdResProc         uintptr
	varResProc         uintptr
	compiledVarResProc uintptr
	nextPtr            uintptr
} /* tclInt.h:942:9 */

// Flag bits for commands.
//
// CMD_IS_DELETED -		Means that the command is in the process of
//				being deleted (its deleteProc is currently
//				executing). Other attempts to delete the
//				command should be ignored.
// CMD_TRACE_ACTIVE -		1 means that trace processing is currently
//				underway for a rename/delete change. See the
//				two flags below for which is currently being
//				processed.
// CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
//				execution trace (as opposed to simple
//				delete/rename traces) in its tracePtr list.
// CMD_COMPILES_EXPANDED -	1 means that this command has a compiler that
//				can handle expansion (provided it is not the
//				first word).
// TCL_TRACE_RENAME -		A rename trace is in progress. Further
//				recursive renames will not be traced.
// TCL_TRACE_DELETE -		A delete trace is in progress. Further
//				recursive deletes will not be traced.
// (these last two flags are defined in tcl.h)

//----------------------------------------------------------------
// Data structures related to name resolution procedures.
//----------------------------------------------------------------

// The interpreter keeps a linked list of name resolution schemes. The scheme
// for a namespace is consulted first, followed by the list of schemes in an
// interpreter, followed by the default name resolution in Tcl. Schemes are
// added/removed from the interpreter's list by calling Tcl_AddInterpResolver
// and Tcl_RemoveInterpResolver.

type ResolverScheme = ResolverScheme1 /* tclInt.h:1723:3 */

//----------------------------------------------------------------
// This structure shadows the first few fields of the memory cache for the
// allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
// definition there.
// Some macros require knowledge of some fields in the struct in order to
// avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
// to the relevant fields is kept in the allocCache field in struct Interp.
//----------------------------------------------------------------

type AllocCache1 = struct {
	nextPtr     uintptr
	owner       Tcl_ThreadId
	firstObjPtr uintptr
	numObjects  int32
	_           [4]byte
} /* tclInt.h:942:9 */

//----------------------------------------------------------------
// This structure shadows the first few fields of the memory cache for the
// allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
// definition there.
// Some macros require knowledge of some fields in the struct in order to
// avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
// to the relevant fields is kept in the allocCache field in struct Interp.
//----------------------------------------------------------------

type AllocCache = AllocCache1 /* tclInt.h:1756:3 */

//----------------------------------------------------------------
// This structure defines an interpreter, which is a collection of commands
// plus other state information related to interpreting commands, such as
// variable storage. Primary responsibility for this data structure is in
// tclBasic.c, but almost every Tcl source file uses something in here.
//----------------------------------------------------------------

type Interp = Interp1 /* tclInt.h:2152:3 */

// Macros that use the TSD-ekeko.

// Macros for script cancellation support (TIP #285).

// Macros for splicing into and out of doubly linked lists. They assume
// existence of struct items 'prevPtr' and 'nextPtr'.
//
// a = element to add or remove.
// b = list head.
//
// TclSpliceIn adds to the head of the list.

// EvalFlag bits for Interp structures:
//
// TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
//			code other than TCL_OK or TCL_ERROR; 0 means codes
//			other than these should be turned into errors.

// Flag bits for Interp structures:
//
// DELETED:		Non-zero means the interpreter has been deleted:
//			don't process any more commands for it, and destroy
//			the structure as soon as all nested invocations of
//			Tcl_Eval are done.
// ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
//			iPtr->errorInfo for the current Tcl_Eval instance, so
//			Tcl_Eval needn't log it (used to implement the "error
//			message log" command).
// DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
//			not compile any commands into an inline sequence of
//			instructions. This is set 1, for example, when command
//			traces are requested.
// RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
//			has not be initialized. This is set 1 when we first
//			use the rand() or srand() functions.
// SAFE_INTERP:		Non zero means that the current interp is a safe
//			interp (i.e. it has only the safe commands installed,
//			less privilege than a regular interp).
// INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
//			debug/info mechanisms (e.g. info frame eval/uplevel
//			tracing) which are performance intensive.
// INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
//			active; so no further trace callbacks should be
//			invoked.
// INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
//			of the wrong-num-args string in Tcl_WrongNumArgs.
//			Makes it append instead of replacing and uses
//			different intermediate text.
// CANCELED:		Non-zero means that the script in progress should be
//			canceled as soon as possible. This can be checked by
//			extensions (and the core itself) by calling
//			Tcl_Canceled and checking if TCL_ERROR is returned.
//			This is a one-shot flag that is reset immediately upon
//			being detected; however, if the TCL_CANCEL_UNWIND flag
//			is set Tcl_Canceled will continue to report that the
//			script in progress has been canceled thereby allowing
//			the evaluation stack for the interp to be fully
//			unwound.
//
// WARNING: For the sake of some extensions that have made use of former
// internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
// or 8 (formerly ERROR_CODE_SET).

// Maximum number of levels of nesting permitted in Tcl commands (used to
// catch infinite recursion).

// The macro below is used to modify a "char" value (e.g. by casting it to an
// unsigned character) so that it can be used safely with macros such as
// isspace.

// This macro is used to properly align the memory allocated by Tcl, giving
// the same alignment as the native malloc.

// This macro is used to determine the offset needed to safely allocate any
// data structure in memory. Given a starting offset or size, it "rounds up"
// or "aligns" the offset to the next 8-byte boundary so that any data
// structure can be placed at the resulting offset without fear of an
// alignment error.
//
// WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
// wrong result on platforms that allocate addresses that are divisible by 4
// or 2. Only use it for offsets or sizes.
//
// This macro is only used by tclCompile.c in the core (Bug 926445). It
// however not be made file static, as extensions that touch bytecodes
// (notably tbcload) require it.

// The following enum values are used to specify the runtime platform setting
// of the tclPlatform variable.

type TclPlatformType = uint32 /* tclInt.h:2328:3 */

// The following enum values are used to indicate the translation of a Tcl
// channel. Declared here so that each platform can define
// TCL_PLATFORM_TRANSLATION to the native translation on that platform.

type TclEolTranslation = uint32 /* tclInt.h:2341:3 */

// Flags for TclInvoke:
//
// TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
//				an exposed command.
// TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
//				command to be invoked is not found. Only has
//				an effect if invoking an exposed command,
//				i.e. if TCL_INVOKE_HIDDEN is not also set.
// TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
//				invoked command returns an error. Used if the
//				caller plans on recording its own traceback
//				information.

// The structure used as the internal representation of Tcl list objects. This
// struct is grown (reallocated and copied) as necessary to hold all the
// list's element pointers. The struct might contain more slots than currently
// used to hold all element pointers. This is done to make append operations
// faster.

type List1 = struct {
	refCount      int32
	maxElemCount  int32
	elemCount     int32
	canonicalFlag int32
	elements      uintptr
} /* tclInt.h:2370:9 */

// Flags for TclInvoke:
//
// TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
//				an exposed command.
// TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
//				command to be invoked is not found. Only has
//				an effect if invoking an exposed command,
//				i.e. if TCL_INVOKE_HIDDEN is not also set.
// TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
//				invoked command returns an error. Used if the
//				caller plans on recording its own traceback
//				information.

// The structure used as the internal representation of Tcl list objects. This
// struct is grown (reallocated and copied) as necessary to hold all the
// list's element pointers. The struct might contain more slots than currently
// used to hold all element pointers. This is done to make append operations
// faster.

type List = List1 /* tclInt.h:2380:3 */

type TclFileAttrProcs1 = struct {
	getProc uintptr
	setProc uintptr
} /* tclInt.h:2550:9 */

type TclFileAttrProcs = TclFileAttrProcs1 /* tclInt.h:2553:3 */

// Opaque handle used in pipeline routines to encapsulate platform-dependent
// state.

type TclFile = uintptr /* tclInt.h:2560:25 */

// The "globParameters" argument of the function TclGlob is an or'ed
// combination of the following values:

type Tcl_PathPart = uint32 /* tclInt.h:2577:3 */

//----------------------------------------------------------------
// Data structures related to procedures
//----------------------------------------------------------------

type TclCmdProcType = uintptr    /* tclInt.h:2596:21 */
type TclObjCmdProcType = uintptr /* tclInt.h:2597:24 */

// A ProcessGlobalValue struct exists for each internal value in Tcl that is
// to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
// the value, and the gobal value is kept as a counted string, with epoch and
// mutex control. Each ProcessGlobalValue struct should be a static variable in
// some file.

type ProcessGlobalValue1 = struct {
	epoch    int32
	numBytes int32
	value    uintptr
	encoding Tcl_Encoding
	proc     uintptr
	mutex    Tcl_Mutex
	key      Tcl_ThreadDataKey
} /* tclInt.h:2616:9 */

// A ProcessGlobalValue struct exists for each internal value in Tcl that is
// to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
// the value, and the gobal value is kept as a counted string, with epoch and
// mutex control. Each ProcessGlobalValue struct should be a static variable in
// some file.

type ProcessGlobalValue = ProcessGlobalValue1 /* tclInt.h:2631:3 */

// This structure holds the data for the various iteration callbacks used to
// NRE the 'for' and 'while' commands. We need a separate structure because we
// have more than the 4 client data entries we can provide directly thorugh
// the callback API. It is the 'word' information which puts us over the
// limit. It is needed because the loop body is argument 4 of 'for' and
// argument 2 of 'while'. Not providing the correct index confuses the #280
// code. We TclSmallAlloc/Free this.

type ForIterData1 = struct {
	cond uintptr
	body uintptr
	next uintptr
	msg  uintptr
	word int32
	_    [4]byte
} /* tclInt.h:2801:9 */

// This structure holds the data for the various iteration callbacks used to
// NRE the 'for' and 'while' commands. We need a separate structure because we
// have more than the 4 client data entries we can provide directly thorugh
// the callback API. It is the 'word' information which puts us over the
// limit. It is needed because the loop body is argument 4 of 'for' and
// argument 2 of 'while'. Not providing the correct index confuses the #280
// code. We TclSmallAlloc/Free this.

type ForIterData = ForIterData1 /* tclInt.h:2807:3 */

type memCmpFn_t = uintptr /* tclInt.h:3166:13 */

//----------------------------------------------------------------
// Macro used by the Tcl core to check whether a pattern has any characters
// special to [string match]. The ANSI C "prototype" for this macro is:
//
// MODULE_SCOPE int	TclMatchIsTrivial(const char *pattern);
//----------------------------------------------------------------

//----------------------------------------------------------------
// Macros used by the Tcl core to set a Tcl_Obj's numeric representation
// avoiding the corresponding function calls in time critical parts of the
// core. They should only be called on unshared objects. The ANSI C
// "prototypes" for these macros are:
//
// MODULE_SCOPE void	TclSetIntObj(Tcl_Obj *objPtr, int intValue);
// MODULE_SCOPE void	TclSetLongObj(Tcl_Obj *objPtr, long longValue);
// MODULE_SCOPE void	TclSetBooleanObj(Tcl_Obj *objPtr, long boolValue);
// MODULE_SCOPE void	TclSetWideIntObj(Tcl_Obj *objPtr, Tcl_WideInt w);
// MODULE_SCOPE void	TclSetDoubleObj(Tcl_Obj *objPtr, double d);
//----------------------------------------------------------------

// NOTE: There is to be no such thing as a "pure" boolean. Boolean values set
// programmatically go straight to being "int" Tcl_Obj's, with value 0 or 1.
// The only "boolean" Tcl_Obj's shall be those holding the cached boolean
// value of strings like: "yes", "no", "true", "false", "on", "off".

//----------------------------------------------------------------
// Macros used by the Tcl core to create and initialise objects of standard
// types, avoiding the corresponding function calls in time critical parts of
// the core. The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE void	TclNewIntObj(Tcl_Obj *objPtr, int i);
// MODULE_SCOPE void	TclNewLongObj(Tcl_Obj *objPtr, long l);
// MODULE_SCOPE void	TclNewBooleanObj(Tcl_Obj *objPtr, int b);
// MODULE_SCOPE void	TclNewWideObj(Tcl_Obj *objPtr, Tcl_WideInt w);
// MODULE_SCOPE void	TclNewDoubleObj(Tcl_Obj *objPtr, double d);
// MODULE_SCOPE void	TclNewStringObj(Tcl_Obj *objPtr, char *s, int len);
// MODULE_SCOPE void	TclNewLiteralStringObj(Tcl_Obj*objPtr, char*sLiteral);
//
//----------------------------------------------------------------

// NOTE: There is to be no such thing as a "pure" boolean.
// See comment above TclSetBooleanObj macro above.

// The sLiteral argument *must* be a string literal; the incantation with
// sizeof(sLiteral "") will fail to compile otherwise.

//----------------------------------------------------------------
// Convenience macros for DStrings.
// The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE char * TclDStringAppendLiteral(Tcl_DString *dsPtr,
//			const char *sLiteral);
// MODULE_SCOPE void   TclDStringClear(Tcl_DString *dsPtr);

//----------------------------------------------------------------
// Macros used by the Tcl core to test for some special double values.
// The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE int	TclIsInfinite(double d);
// MODULE_SCOPE int	TclIsNaN(double d);

// ----------------------------------------------------------------------
// Macro to use to find the offset of a field in a structure. Computes number
// of bytes from beginning of structure to a given field.

//----------------------------------------------------------------
// Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace.

//----------------------------------------------------------------
// Inline version of TclCleanupCommand; still need the function as it is in
// the internal stubs, but the core can use the macro instead.

//----------------------------------------------------------------
// Inline versions of Tcl_LimitReady() and Tcl_LimitExceeded to limit number
// of calls out of the critical path. Note that this code isn't particularly
// readable; the non-inline version (in tclInterp.c) is much easier to
// understand. Note also that these macros takes different args (iPtr->limit)
// to the non-inline version.

// Compile-time assertions: these produce a compile time error if the
// expression is not known to be true at compile time. If the assertion is
// known to be false, the compiler (or optimizer?) will error out with
// "division by zero". If the assertion cannot be evaluated at compile time,
// the compiler will error out with "non-static initializer".
//
// Adapted with permission from
// http://www.pixelbeat.org/programming/gcc/static_assert.html

//----------------------------------------------------------------
// Allocator for small structs (<=sizeof(Tcl_Obj)) using the Tcl_Obj pool.
// Only checked at compile time.
//
// ONLY USE FOR CONSTANT nBytes.
//
// DO NOT LET THEM CROSS THREAD BOUNDARIES
//----------------------------------------------------------------

// Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>

//----------------------------------------------------------------
// Parameters, structs and macros for the non-recursive engine (NRE)
//----------------------------------------------------------------

// This is the main data struct for representing NR commands. It is designed
// to fit in sizeof(Tcl_Obj) in order to exploit the fastest memory allocator
// available.

type NRE_callback = NRE_callback1 /* tclInt.h:4934:3 */

type TclIntStubs = TclIntStubs1 /* tclIntDecls.h:916:3 */

type TclIntPlatStubs = TclIntPlatStubs1 /* tclIntPlatDecls.h:374:3 */

// Inline function declarations:

// Slot 20 is reserved
// Slot 21 is reserved
// Slot 23 is reserved
// Slot 24 is reserved
// Slot 25 is reserved
// Slot 26 is reserved
// Slot 27 is reserved
// Slot 28 is reserved

// !END!: Do not edit above this line.

//----------------------------------------------------------------------
//
// tclTomMathDecls.h --
//
//	This file contains the declarations for the 'libtommath'
//	functions that are exported by the Tcl library.
//
// Copyright (c) 2005 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution
// of this file, and for a DISCLAIMER OF ALL WARRANTIES.

// tcl.h --
//
//	This header file describes the externally-visible facilities of the
//	Tcl interpreter.
//
// Copyright (c) 1987-1994 The Regents of the University of California.
// Copyright (c) 1993-1996 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-2000 by Scriptics Corporation.
// Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// MS Visual C++ doesn't have a 128bit type for words, so fall back to 32bit MPI's (where words are 64bit)

// detect 64-bit mode if possible

// some default configurations.
//
// A "mp_digit" must be able to hold MP_DIGIT_BIT + 1 bits
// A "mp_word" must be able to hold 2*MP_DIGIT_BIT + 1 bits
//
// At the very least a mp_digit must be able to hold 7 bits
// [any size beyond that is ok provided it doesn't overflow the data type]

// this is the default case, 28-bit digits

// this is to make porting into LibTomCrypt easier :-)
type private_mp_word = uint64 /* tclTomMath.h:94:30 */

// default case is 28-bit digits, defines MP_28BIT as a handy macro to test

// otherwise the bits per digit is calculated automatically from the size of a mp_digit

// Primality generation flags

type mp_sign = int32   /* tclTomMath.h:163:13 */
type mp_ord = int32    /* tclTomMath.h:166:13 */
type mp_bool = int32   /* tclTomMath.h:170:13 */
type mp_err = int32    /* tclTomMath.h:173:13 */
type mp_order = int32  /* tclTomMath.h:181:13 */
type mp_endian = int32 /* tclTomMath.h:184:13 */

type TclTomMathStubs1 = struct {
	magic                       int32
	_                           [4]byte
	hooks                       uintptr
	tclBN_epoch                 uintptr
	tclBN_revision              uintptr
	tclBN_mp_add                uintptr
	tclBN_mp_add_d              uintptr
	tclBN_mp_and                uintptr
	tclBN_mp_clamp              uintptr
	tclBN_mp_clear              uintptr
	tclBN_mp_clear_multi        uintptr
	tclBN_mp_cmp                uintptr
	tclBN_mp_cmp_d              uintptr
	tclBN_mp_cmp_mag            uintptr
	tclBN_mp_copy               uintptr
	tclBN_mp_count_bits         uintptr
	tclBN_mp_div                uintptr
	tclBN_mp_div_d              uintptr
	tclBN_mp_div_2              uintptr
	tclBN_mp_div_2d             uintptr
	tclBN_mp_div_3              uintptr
	tclBN_mp_exch               uintptr
	tclBN_mp_expt_d             uintptr
	tclBN_mp_grow               uintptr
	tclBN_mp_init               uintptr
	tclBN_mp_init_copy          uintptr
	tclBN_mp_init_multi         uintptr
	tclBN_mp_init_set           uintptr
	tclBN_mp_init_size          uintptr
	tclBN_mp_lshd               uintptr
	tclBN_mp_mod                uintptr
	tclBN_mp_mod_2d             uintptr
	tclBN_mp_mul                uintptr
	tclBN_mp_mul_d              uintptr
	tclBN_mp_mul_2              uintptr
	tclBN_mp_mul_2d             uintptr
	tclBN_mp_neg                uintptr
	tclBN_mp_or                 uintptr
	tclBN_mp_radix_size         uintptr
	tclBN_mp_read_radix         uintptr
	tclBN_mp_rshd               uintptr
	tclBN_mp_shrink             uintptr
	tclBN_mp_set                uintptr
	tclBN_mp_sqr                uintptr
	tclBN_mp_sqrt               uintptr
	tclBN_mp_sub                uintptr
	tclBN_mp_sub_d              uintptr
	tclBN_mp_to_unsigned_bin    uintptr
	tclBN_mp_to_unsigned_bin_n  uintptr
	tclBN_mp_toradix_n          uintptr
	tclBN_mp_unsigned_bin_size  uintptr
	tclBN_mp_xor                uintptr
	tclBN_mp_zero               uintptr
	tclBN_reverse               uintptr
	tclBN_fast_s_mp_mul_digs    uintptr
	tclBN_fast_s_mp_sqr         uintptr
	tclBN_mp_karatsuba_mul      uintptr
	tclBN_mp_karatsuba_sqr      uintptr
	tclBN_mp_toom_mul           uintptr
	tclBN_mp_toom_sqr           uintptr
	tclBN_s_mp_add              uintptr
	tclBN_s_mp_mul_digs         uintptr
	tclBN_s_mp_sqr              uintptr
	tclBN_s_mp_sub              uintptr
	tclBN_mp_init_set_int       uintptr
	tclBN_mp_set_int            uintptr
	tclBN_mp_cnt_lsb            uintptr
	tclBNInitBignumFromLong     uintptr
	tclBNInitBignumFromWideInt  uintptr
	tclBNInitBignumFromWideUInt uintptr
	tclBN_mp_expt_d_ex          uintptr
	tclBN_mp_set_ull            uintptr
	tclBN_mp_get_mag_ull        uintptr
	tclBN_mp_set_ll             uintptr
	reserved71                  uintptr
	reserved72                  uintptr
	tclBN_mp_tc_and             uintptr
	tclBN_mp_tc_or              uintptr
	tclBN_mp_tc_xor             uintptr
	tclBN_mp_signed_rsh         uintptr
	reserved77                  uintptr
	tclBN_mp_to_ubin            uintptr
	tclBN_mp_div_ld             uintptr
	tclBN_mp_to_radix           uintptr
} /* tclTomMathDecls.h:357:9 */

type TclTomMathStubs = TclTomMathStubs1 /* tclTomMathDecls.h:442:3 */

// These are opaque types.

type Tcl_Class = uintptr         /* tclOO.h:52:27 */
type Tcl_Method = uintptr        /* tclOO.h:53:28 */
type Tcl_Object = uintptr        /* tclOO.h:54:28 */
type Tcl_ObjectContext = uintptr /* tclOO.h:55:35 */

// The type of a method implementation. This describes how to call the method
// implementation, how to delete it (when the object or class is deleted) and
// how to create a clone of it (when the object or class is copied).

type Tcl_MethodType = struct {
	version    int32
	_          [4]byte
	name       uintptr
	callProc   uintptr
	deleteProc uintptr
	cloneProc  uintptr
} /* tclOO.h:93:3 */

// The correct value for the version field of the Tcl_MethodType structure.
// This allows new versions of the structure to be introduced without breaking
// binary compatability.

// The type of some object (or class) metadata. This describes how to delete
// the metadata (when the object or class is deleted) and how to create a
// clone of it (when the object or class is copied).

type Tcl_ObjectMetadataType = struct {
	version    int32
	_          [4]byte
	name       uintptr
	deleteProc uintptr
	cloneProc  uintptr
} /* tclOO.h:120:3 */

type TclOOStubHooks = struct{ tclOOIntStubs uintptr } /* tclOODecls.h:126:3 */

type TclOOStubs1 = struct {
	magic                         int32
	_                             [4]byte
	hooks                         uintptr
	tcl_CopyObjectInstance        uintptr
	tcl_GetClassAsObject          uintptr
	tcl_GetObjectAsClass          uintptr
	tcl_GetObjectCommand          uintptr
	tcl_GetObjectFromObj          uintptr
	tcl_GetObjectNamespace        uintptr
	tcl_MethodDeclarerClass       uintptr
	tcl_MethodDeclarerObject      uintptr
	tcl_MethodIsPublic            uintptr
	tcl_MethodIsType              uintptr
	tcl_MethodName                uintptr
	tcl_NewInstanceMethod         uintptr
	tcl_NewMethod                 uintptr
	tcl_NewObjectInstance         uintptr
	tcl_ObjectDeleted             uintptr
	tcl_ObjectContextIsFiltering  uintptr
	tcl_ObjectContextMethod       uintptr
	tcl_ObjectContextObject       uintptr
	tcl_ObjectContextSkippedArgs  uintptr
	tcl_ClassGetMetadata          uintptr
	tcl_ClassSetMetadata          uintptr
	tcl_ObjectGetMetadata         uintptr
	tcl_ObjectSetMetadata         uintptr
	tcl_ObjectContextInvokeNext   uintptr
	tcl_ObjectGetMethodNameMapper uintptr
	tcl_ObjectSetMethodNameMapper uintptr
	tcl_ClassSetConstructor       uintptr
	tcl_ClassSetDestructor        uintptr
	tcl_GetObjectName             uintptr
	reserved29                    uintptr
	reserved30                    uintptr
	tclOOUnusedStubEntry          uintptr
} /* tclOODecls.h:128:9 */

type TclOOStubs = TclOOStubs1 /* tclOODecls.h:164:3 */

// Inline function declarations:

// Slot 29 is reserved
// Slot 30 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================

// from: @(#)fdlibm.h 5.1 93/09/24
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94
// $FreeBSD$

// ANSI/POSIX
type __infinity_un = struct {
	_    [0]uint64
	__uc [8]uint8
} /* math.h:27:14 */

type __nan_un = struct {
	_    [0]uint32
	__uc [4]uint8
} /* math.h:32:14 */

// Symbolic constants to classify floating point numbers.

type double_t = float64 /* math.h:136:20 */
type float_t = float32  /* math.h:137:19 */

// Required for Testregexp*Cmd
// tclRegexp.h --
//
//	This file contains definitions used internally by Henry Spencer's
//	regular expression code.
//
// Copyright (c) 1998 by Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// regular expressions
//
// Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
//
// Development of this software was funded, in part, by Cray Research Inc.,
// UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
// Corporation, none of whom are responsible for the results. The author
// thanks all of them.
//
// Redistribution and use in source and binary forms -- with or without
// modification -- are permitted for any purpose, provided that
// redistributions in source form retain this entire copyright notice and
// indicate the origin and nature of any modifications.
//
// I'd appreciate being given credit for this package in the documentation of
// software which uses it, but that is not a requirement.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
// HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//
// Prototypes etc. marked with "^" within comments get gathered up (and
// possibly edited) by the regfwd program and inserted near the bottom of this
// file.
//
// We offer the option of declaring one wide-character version of the RE
// functions as well as the char versions. To do that, define __REG_WIDE_T to
// the type of wide characters (unfortunately, there is no consensus that
// wchar_t is suitable) and __REG_WIDE_COMPILE and __REG_WIDE_EXEC to the
// names to be used for the compile and execute functions (suggestion:
// re_Xcomp and re_Xexec, where X is a letter suggestive of the wide type,
// e.g. re_ucomp and re_uexec for Unicode). For cranky old compilers, it may
// be necessary to do something like:
// #define	__REG_WIDE_COMPILE(a,b,c,d)	re_Xcomp(a,b,c,d)
// #define	__REG_WIDE_EXEC(a,b,c,d,e,f,g)	re_Xexec(a,b,c,d,e,f,g)
// rather than just #defining the names as parameterless macros.
//
// For some specialized purposes, it may be desirable to suppress the
// declarations of the "front end" functions, regcomp() and regexec(), or of
// the char versions of the compile and execute functions. To suppress the
// front-end functions, define __REG_NOFRONT. To suppress the char versions,
// define __REG_NOCHAR.
//
// The right place to do those defines (and some others you may want, see
// below) would be <sys/types.h>. If you don't have control of that file, the
// right place to add your own defines to this file is marked below. This is
// normally done automatically, by the makefile and regmkhdr, based on the
// contents of regcustom.h.

// voodoo for C++

// Add your own defines, if needed, here.

// Location where a chunk of regcustom.h is automatically spliced into this
// file (working from its prototype, regproto.h).

// --- begin ---
// ensure certain things don't sneak in from system headers
// interface types
// names and declarations
// --- end ---

// interface types etc.

// regoff_t has to be large enough to hold either off_t or ssize_t, and must
// be signed; it's only a guess that long is suitable, so we offer
// <sys/types.h> an override.
type regoff_t = int64 /* regex.h:123:24 */

// other interface types

// the biggie, a compiled RE (or rather, a front end to same)
type regex_t = struct {
	re_magic int32
	_        [4]byte
	re_nsub  size_t
	re_info  int64
	re_csize int32
	_        [4]byte
	re_endp  uintptr
	re_guts  uintptr
	re_fns   uintptr
} /* regex.h:156:3 */

// result reporting (may acquire more fields later)
type regmatch_t = struct {
	rm_so regoff_t
	rm_eo regoff_t
} /* regex.h:162:3 */

// supplementary control and reporting
type rm_detail_t = struct{ rm_extend regmatch_t } /* regex.h:167:3 */
// automatically gathered by fwd; do not hand-edit
// =====^!^===== end forwards =====^!^=====

// more C++ voodoo

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The TclRegexp structure encapsulates a compiled regex_t, the flags that
// were used to compile it, and an array of pointers that are used to indicate
// subexpressions after a call to Tcl_RegExpExec. Note that the string and
// objPtr are mutually exclusive. These values are needed by Tcl_RegExpRange
// in order to return pointers into the original string.

type TclRegexp1 = struct {
	flags      int32
	_          [4]byte
	re         regex_t
	string     uintptr
	objPtr     uintptr
	globObjPtr uintptr
	matches    uintptr
	details    rm_detail_t
	refCount   int32
	_          [4]byte
} /* tclRegexp.h:27:9 */

// automatically gathered by fwd; do not hand-edit
// =====^!^===== end forwards =====^!^=====

// more C++ voodoo

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The TclRegexp structure encapsulates a compiled regex_t, the flags that
// were used to compile it, and an array of pointers that are used to indicate
// subexpressions after a call to Tcl_RegExpExec. Note that the string and
// objPtr are mutually exclusive. These values are needed by Tcl_RegExpRange
// in order to return pointers into the original string.

type TclRegexp = TclRegexp1 /* tclRegexp.h:42:3 */

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Required for TestlocaleCmd
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)locale.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2003 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

type lconv = struct {
	decimal_point      uintptr
	thousands_sep      uintptr
	grouping           uintptr
	int_curr_symbol    uintptr
	currency_symbol    uintptr
	mon_decimal_point  uintptr
	mon_thousands_sep  uintptr
	mon_grouping       uintptr
	positive_sign      uintptr
	negative_sign      uintptr
	int_frac_digits    int8
	frac_digits        int8
	p_cs_precedes      int8
	p_sep_by_space     int8
	n_cs_precedes      int8
	n_sep_by_space     int8
	p_sign_posn        int8
	n_sign_posn        int8
	int_p_cs_precedes  int8
	int_n_cs_precedes  int8
	int_p_sep_by_space int8
	int_n_sep_by_space int8
	int_p_sign_posn    int8
	int_n_sign_posn    int8
	_                  [2]byte
} /* locale.h:40:1 */

// Required for the TestChannelCmd and TestChannelEventCmd
// tclIO.h --
//
//	This file provides the generic portions (those that are the same on
//	all platforms and for all channel types) of Tcl's IO facilities.
//
// Copyright (c) 1998-2000 Ajuba Solutions
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not
// compile on systems where neither is defined. We want both defined so that
// we can test safely for both. In the code we still have to test for both
// because there may be systems on which both are defined and have different
// values.

// struct ChannelBuffer:
//
// Buffers data being sent to or from a channel.

type ChannelBuffer1 = struct {
	_           [0]uint64
	refCount    int32
	nextAdded   int32
	nextRemoved int32
	bufLength   int32
	nextPtr     uintptr
} /* tclIO.h:38:9 */

// Required for the TestChannelCmd and TestChannelEventCmd
// tclIO.h --
//
//	This file provides the generic portions (those that are the same on
//	all platforms and for all channel types) of Tcl's IO facilities.
//
// Copyright (c) 1998-2000 Ajuba Solutions
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not
// compile on systems where neither is defined. We want both defined so that
// we can test safely for both. In the code we still have to test for both
// because there may be systems on which both are defined and have different
// values.

// struct ChannelBuffer:
//
// Buffers data being sent to or from a channel.

type ChannelBuffer = ChannelBuffer1 /* tclIO.h:51:3 */

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type EventScriptRecord1 = struct {
	chanPtr   uintptr
	scriptPtr uintptr
	interp    uintptr
	mask      int32
	_         [4]byte
	nextPtr   uintptr
} /* tclIO.h:75:9 */

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type Channel1 = struct {
	state        uintptr
	instanceData ClientData
	typePtr      uintptr
	downChanPtr  uintptr
	upChanPtr    uintptr
	inQueueHead  uintptr
	inQueueTail  uintptr
	refCount     int32
	_            [4]byte
} /* tclIO.h:75:9 */

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type EventScriptRecord = EventScriptRecord1 /* tclIO.h:86:3 */

// struct Channel:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type ChannelState1 = struct {
	channelName         uintptr
	flags               int32
	_                   [4]byte
	encoding            Tcl_Encoding
	inputEncodingState  Tcl_EncodingState
	inputEncodingFlags  int32
	_                   [4]byte
	outputEncodingState Tcl_EncodingState
	outputEncodingFlags int32
	inputTranslation    TclEolTranslation
	outputTranslation   TclEolTranslation
	inEofChar           int32
	outEofChar          int32
	unreportedError     int32
	refCount            int32
	_                   [4]byte
	closeCbPtr          uintptr
	outputStage         uintptr
	curOutPtr           uintptr
	outQueueHead        uintptr
	outQueueTail        uintptr
	saveInBufPtr        uintptr
	inQueueHead         uintptr
	inQueueTail         uintptr
	chPtr               uintptr
	interestMask        int32
	_                   [4]byte
	scriptRecordPtr     uintptr
	bufSize             int32
	_                   [4]byte
	timer               Tcl_TimerToken
	csPtrR              uintptr
	csPtrW              uintptr
	topChanPtr          uintptr
	bottomChanPtr       uintptr
	nextCSPtr           uintptr
	managingThread      Tcl_ThreadId
	chanMsg             uintptr
	unreportedMsg       uintptr
	epoch               int32
	_                   [4]byte
} /* tclIO.h:75:9 */

// struct Channel:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type Channel = Channel1 /* tclIO.h:117:3 */

// struct ChannelState:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type ChannelState = ChannelState1 /* tclIO.h:219:3 */

// Dynamic string shared by TestdcallCmd and DelCallbackProc; used to collect
// the results of the various deletion callbacks.

var delString Tcl_DString /* tclTest.c:61:20: */
var delInterp uintptr     /* tclTest.c:62:19: */

// One of the following structures exists for each asynchronous handler
// created by the "testasync" command".

type TestAsyncHandler1 = struct {
	id      int32
	_       [4]byte
	handler Tcl_AsyncHandler
	command uintptr
	nextPtr uintptr
} /* tclTest.c:69:9 */

// One of the following structures exists for each asynchronous handler
// created by the "testasync" command".

type TestAsyncHandler = TestAsyncHandler1 /* tclTest.c:76:3 */

var firstHandler uintptr = uintptr(0) /* tclTest.c:80:25 */

// The dynamic string below is used by the "testdstring" command to test the
// dynamic string facilities.

var dstring Tcl_DString /* tclTest.c:87:20: */

// The command trace below is used by the "testcmdtraceCmd" command to test
// the command tracing facilities.

var cmdTrace Tcl_Trace /* tclTest.c:94:18: */

// One of the following structures exists for each command created by
// TestdelCmd:

type DelCmd = struct {
	interp    uintptr
	deleteCmd uintptr
} /* tclTest.c:105:3 */

// The following is used to keep track of an encoding that invokes a Tcl
// command.

type TclEncoding = struct {
	interp     uintptr
	toUtfCmd   uintptr
	fromUtfCmd uintptr
} /* tclTest.c:116:3 */

// The counter below is used to determine if the TestsaveresultFree routine
// was called for a result.

var freeCount int32 /* tclTest.c:123:12: */

// Boolean flag used by the "testsetmainloop" and "testexitmainloop" commands.

var exitMainLoop int32 = 0 /* tclTest.c:129:12 */

// Event structure used in testing the event queue management procedures.

type TestEvent = struct {
	header  Tcl_Event
	interp  uintptr
	command uintptr
	tag     uintptr
} /* tclTest.c:140:3 */

// Simple detach/attach facility for testchannel cut|splice. Allow testing of
// channel transfer in core testsuite.

type TestChannel1 = struct {
	__chan  Tcl_Channel
	nextPtr uintptr
} /* tclTest.c:147:9 */

// Simple detach/attach facility for testchannel cut|splice. Allow testing of
// channel transfer in core testsuite.

type TestChannel = TestChannel1 /* tclTest.c:150:3 */

var firstDetached uintptr /* tclTest.c:152:20: */

var testReportingFilesystem = Tcl_Filesystem{
	typeName:             ts + 34,
	structureLength:      int32(unsafe.Sizeof(Tcl_Filesystem{})),
	version:              uintptr(0x1),
	pathInFilesystemProc: 0, // path in
	dupInternalRepProc:   0,
	freeInternalRepProc:  0, // convert to native
	normalizePathProc:    0, // separator
	statProc:             0,
	accessProc:           0,
	openFileChannelProc:  0,
	matchInDirectoryProc: 0,
	utimeProc:            0,
	linkProc:             0,
	fileAttrStringsProc:  0,
	fileAttrsGetProc:     0,
	fileAttrsSetProc:     0,
	createDirectoryProc:  0,
	removeDirectoryProc:  0,
	deleteFileProc:       0,
	copyFileProc:         0,
	renameFileProc:       0,
	copyDirectoryProc:    0,
	lstatProc:            0,
	loadFileProc:         0,
	chdirProc:            0,
} /* tclTest.c:333:29 */

var simpleFilesystem = Tcl_Filesystem{
	typeName:             ts + 44,
	structureLength:      int32(unsafe.Sizeof(Tcl_Filesystem{})),
	version:              uintptr(0x1),
	pathInFilesystemProc: 0,
	statProc:             0,
	accessProc:           0,
	openFileChannelProc:  0,
	matchInDirectoryProc: 0,
	listVolumesProc:      0,
} /* tclTest.c:367:29 */

//----------------------------------------------------------------------
//
// Tcltest_Init --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcltest_Init(tls *libc.TLS, interp uintptr) int32 { /* tclTest.c:435:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var t3ArgTypes [2]Tcl_ValueType at bp, 8

	// var objv uintptr at bp+16, 8

	var objPtr uintptr
	// var objc int32 at bp+8, 4

	// var index int32 at bp+24, 4

	if tcl.XTcl_InitStubs(tls, interp, ts+51, 0) == uintptr(0) {
		return TCL_ERROR
	}
	if tcl.XTclTomMathInitializeStubs(tls, interp, ts+51, TCLTOMMATH_EPOCH, TCLTOMMATH_REVISION) == uintptr(0) {
		return TCL_ERROR
	}
	if tcl.XTclOOInitializeStubs(tls, interp, ts+55) == uintptr(0) {
		return TCL_ERROR
	}
	// TIP #268: Full patchlevel instead of just major.minor

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PkgProvideEx})).f(tls, interp, ts, ts+61, uintptr(0)) == TCL_ERROR {
		return TCL_ERROR
	}

	// Create additional commands and math functions for testing Tcl.

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+68 /* "gettimes" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{GetTimesObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+77 /* "noop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{NoopCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+77 /* "noop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{NoopObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+82 /* "testpurebytesobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestpurebytesobjObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+99 /* "testsetbytearray..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetbytearraylengthObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+122 /* "testbytestring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbytestringObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+137 /* "teststringbytes" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TeststringbytesObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+153 /* "testwrongnumargs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestWrongNumArgsObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+170 /* "testfilesystem" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestFilesystemObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+185 /* "testsimplefilesy..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestSimpleFilesystemObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+206, /* "testgetindexfrom..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestGetIndexFromObjStructObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+232 /* "testasync" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestasyncCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+242, /* "testbumpinterpep..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestbumpinterpepochObjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+262 /* "testchannel" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestChannelCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+274 /* "testchannelevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestChannelEventCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+291 /* "testcmdtoken" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdtokenCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+304 /* "testcmdinfo" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdinfoCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+316 /* "testcmdtrace" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdtraceCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+329 /* "testconcatobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestconcatobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+343 /* "testcreatecomman..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcreatecommandCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+361 /* "testdcall" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdcallCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+371 /* "testdel" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdelCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+379 /* "testdelassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdelassocdataCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+396 /* "testdoubledigits" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdoubledigitsObjCmd})),
		uintptr(0), uintptr(0))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+413 /* "testdstring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdstringCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+425 /* "testencoding" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestencodingObjCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+438 /* "testevalex" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestevalexObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+449 /* "testevalobjv" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestevalobjvObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+462 /* "testevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TesteventObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+472 /* "testexithandler" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexithandlerCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+488 /* "testexprlong" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprlongCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+501 /* "testexprlongobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprlongobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+517 /* "testexprdouble" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprdoubleCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+532 /* "testexprdoubleob..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprdoubleobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+550 /* "testexprparser" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprparserObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+565 /* "testexprstring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprstringCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+580 /* "testfevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfeventCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+591 /* "testfilelink" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilelinkCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+604 /* "testfile" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfileCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+613, /* "testhashsystemha..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestHashSystemHashCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+632 /* "testgetassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetassocdataCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+649 /* "testgetint" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetintCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+660 /* "testgetplatform" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetplatformCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+676, /* "testgetvarfullna..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestgetvarfullnameCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+695 /* "testinterpdelete" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestinterpdeleteCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+712 /* "testlink" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlinkCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+721 /* "testlocale" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlocaleCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+732 /* "testpanic" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestpanicCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+742 /* "testparseargs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparseargsCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+756 /* "testparser" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparserObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+767 /* "testparsevar" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparsevarObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+780 /* "testparsevarname" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparsevarnameObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+797 /* "testregexp" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestregexpObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+808 /* "testreturn" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestreturnObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+819 /* "testsaveresult" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsaveresultCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+834 /* "testservicemode" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestServiceModeCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+850 /* "testsetassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetassocdataCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+867 /* "testsetnoerr" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+880 /* "testseterr" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetCmd})),
		ClientData(TCL_LEAVE_ERR_MSG), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+891 /* "testset2" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{Testset2Cmd})),
		ClientData(TCL_LEAVE_ERR_MSG), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+900 /* "testseterrorcode" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestseterrorcodeCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+917, /* "testsetobjerrorc..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestsetobjerrorcodeCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+937, /* "testutfnext" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestUtfNextCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+949, /* "testutfprev" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestUtfPrevCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+961, /* "testnumutfchars" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestNumUtfCharsCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+977, /* "testfindfirst" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestFindFirstCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+991, /* "testfindlast" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestFindLastCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1004 /* "testsetplatform" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetplatformCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1020 /* "teststaticpkg" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TeststaticpkgCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1034, /* "testtranslatefil..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TesttranslatefilenameCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1056 /* "testupvar" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestupvarCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateMathFunc})).f(tls, interp, ts+1066 /* "T1" */, 0, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc})), uintptr(123))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateMathFunc})).f(tls, interp, ts+1069 /* "T2" */, 0, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc})), uintptr(345))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1072 /* "testmainthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestmainthreadCmd})), uintptr(0),
		uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1087 /* "testsetmainloop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetmainloopCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1103 /* "testexitmainloop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexitmainloopCmd})),
		uintptr(0), uintptr(0))
	*(*Tcl_ValueType)(unsafe.Pointer(bp)) = TCL_EITHER
	*(*Tcl_ValueType)(unsafe.Pointer(bp + 1*4)) = TCL_EITHER
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateMathFunc})).f(tls, interp, ts+1120 /* "T3" */, 2, bp /* &t3ArgTypes[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc2})),
		uintptr(0))

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+1123 /* "testnreunwind" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestNREUnwind})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+1137 /* "testnrelevels" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestNRELevels})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+1151 /* "testinterpresolv..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestInterpResolverCmd})),
		uintptr(0), uintptr(0))

	if TclObjTest_Init(tls, interp) != TCL_OK {
		return TCL_ERROR
	}
	if Procbodytest_Init(tls, interp) != TCL_OK {
		return TCL_ERROR
	}

	// Check for special options used in ../tests/main.test

	objPtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2Ex})).f(tls, interp, ts+1170 /* "argv" */, uintptr(0), TCL_GLOBAL_ONLY)
	if objPtr != uintptr(0) {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjGetElements})).f(tls, interp, objPtr, bp+8, bp+16) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 8)) != 0 && (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))), uintptr(unsafe.Pointer(&specialOptions)), int32(unsafe.Sizeof(uintptr(0))), uintptr(0), TCL_EXACT, bp+24) == TCL_OK {
			switch *(*int32)(unsafe.Pointer(bp + 24 /* index */)) {
			case 0:
				return TCL_ERROR
				fallthrough
			case 1:
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, interp)
				return TCL_ERROR
				fallthrough
			case 2:
				{
					// var mode int32 at bp+28, 4

					(*struct {
						f func(*libc.TLS, uintptr, Tcl_Channel) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnregisterChannel})).f(tls, interp,
						(*struct {
							f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
						})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, ts+1175 /* "stderr" */, bp+28 /* &mode */))
					return TCL_ERROR

				}
				fallthrough
			case 3:
				if *(*int32)(unsafe.Pointer(bp + 8))-1 != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2Ex})).f(tls, interp, ts+8 /* "tcl_rcFileName" */, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* objv */)) + 1*8)),
						TCL_GLOBAL_ONLY)
				}
				return TCL_ERROR
			}
		}
	}

	// And finally add any platform specific test commands.

	return TclplatformtestInit(tls, interp)
}

var specialOptions = [5]uintptr{
	ts + 1182, ts + 1200,
	ts + 1225, ts + 1249, uintptr(0),
} /* tclTest.c:442:23 */

//----------------------------------------------------------------------
//
// Tcltest_SafeInit --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcltest_SafeInit(tls *libc.TLS, interp uintptr) int32 { /* tclTest.c:691:1: */
	if tcl.XTcl_InitStubs(tls, interp, ts+51, 0) == uintptr(0) {
		return TCL_ERROR
	}
	return Procbodytest_SafeInit(tls, interp)
}

//----------------------------------------------------------------------
//
// TestasyncCmd --
//
//	This procedure implements the "testasync" command.  It is used
//	to test the asynchronous handler facilities of Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes, and invokes handlers.
//
//----------------------------------------------------------------------

func TestasyncCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:718:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var asyncPtr uintptr
	var prevPtr uintptr
	// var id int32 at bp+48, 4

	// var code int32 at bp+52, 4

	_ = dummy

	if !(argc < 2) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1271 /* "wrong # args" */, uintptr(0)))
	return TCL_ERROR
__1:
	;
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0) {
		goto __2
	}
	if !(argc != 3) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	asyncPtr = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TestAsyncHandler{})))
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))+uint64(1)))
	libc.Xstrcpy(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command, *(*uintptr)(unsafe.Pointer(argv + 2*8)))

	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id = nextId
	nextId++
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler = (*struct {
		f func(*libc.TLS, uintptr, ClientData) Tcl_AsyncHandler
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncCreate})).f(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32) int32
	}{AsyncHandlerProc})),
		uintptr(intptr_t((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id)))
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr = firstHandler
	firstHandler = asyncPtr

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id))
	goto __3
__2:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1291) == 0) {
		goto __5
	}
	if !(argc == 2) {
		goto __7
	}

__8:
	if !(firstHandler != uintptr(0)) {
		goto __9
	}
	asyncPtr = firstHandler
	firstHandler = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	(*struct {
		f func(*libc.TLS, Tcl_AsyncHandler)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncDelete})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, asyncPtr)
	goto __8
__9:
	;

	return TCL_OK
__7:
	;
	if !(argc != 3) {
		goto __10
	}
	goto wrongNumArgs
__10:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+48) != TCL_OK) {
		goto __11
	}
	return TCL_ERROR
__11:
	;

	prevPtr = uintptr(0)
	asyncPtr = firstHandler
__12:
	if !(asyncPtr != uintptr(0)) {
		goto __14
	}
	if !((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id != *(*int32)(unsafe.Pointer(bp + 48))) {
		goto __15
	}
	goto __13
__15:
	;
	if !(prevPtr == uintptr(0)) {
		goto __16
	}
	firstHandler = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __17
__16:
	(*TestAsyncHandler)(unsafe.Pointer(prevPtr)).nextPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
__17:
	;
	(*struct {
		f func(*libc.TLS, Tcl_AsyncHandler)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncDelete})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, asyncPtr)
	goto __14
	goto __13
__13:
	prevPtr = asyncPtr
	asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __12
	goto __14
__14:
	;

	goto __6
__5:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1298) == 0) {
		goto __18
	}
	if !(argc != 5) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+48) != TCL_OK ||
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+52) != TCL_OK) {
		goto __21
	}
	return TCL_ERROR
__21:
	;

	asyncPtr = firstHandler
__22:
	if !(asyncPtr != uintptr(0)) {
		goto __24
	}
	if !((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == *(*int32)(unsafe.Pointer(bp + 48))) {
		goto __25
	}
	(*struct {
		f func(*libc.TLS, Tcl_AsyncHandler)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AsyncMark})).f(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	goto __24
__25:
	;
	goto __23
__23:
	asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __22
	goto __24
__24:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), -1))

	return *(*int32)(unsafe.Pointer(bp + 52 /* code */))
	goto __19
__18:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
		ts+1316, uintptr(0)))
	return TCL_ERROR
__19:
	;
__6:
	;
__3:
	;
	return TCL_OK
}

var nextId int32 = 1 /* tclTest.c:726:16 */

func AsyncHandlerProc(tls *libc.TLS, clientData ClientData, interp uintptr, code int32) int32 { /* tclTest.c:844:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var asyncPtr uintptr
	var id int32 = int32(clientData)
	// var listArgv [4]uintptr at bp+24, 32

	var cmd uintptr
	// var string [24]int8 at bp, 24

	for asyncPtr = firstHandler; asyncPtr != uintptr(0); asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr {
		if (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == id {
			break
		}
	}

	if !(asyncPtr != 0) {
		// Woops - this one was deleted between the AsyncMark and now
		return TCL_OK
	}

	(*struct {
		f func(*libc.TLS, uintptr, int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp /* &string[0] */, int64(code))
	*(*uintptr)(unsafe.Pointer(bp + 24)) = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command
	*(*uintptr)(unsafe.Pointer(bp + 24 + 1*8)) = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp))
	*(*uintptr)(unsafe.Pointer(bp + 24 + 2*8)) = bp /* &string[0] */
	*(*uintptr)(unsafe.Pointer(bp + 24 + 3*8)) = uintptr(0)
	cmd = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Merge})).f(tls, 3, bp+24 /* &listArgv[0] */)
	if interp != uintptr(0) {
		code = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, cmd, -1, 0)
	} else {
		// this should not happen, but by definition of how async handlers are
		// invoked, it's possible.  Better error checking is needed here.
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, cmd)
	return code
}

//----------------------------------------------------------------------
//
// AsyncThreadProc --
//
//	Delivers an asynchronous event to a handler in another thread.
//
// Results:
//	None.
//
// Side effects:
//	Invokes Tcl_AsyncMark on the handler
//
//----------------------------------------------------------------------

func TestbumpinterpepochObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:929:1: */
	var iPtr uintptr = interp

	if objc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+1356 /* "" */)
		return TCL_ERROR
	}
	(*Interp)(unsafe.Pointer(iPtr)).compileEpoch++
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestcmdinfoCmd --
//
//	This procedure implements the "testcmdinfo" command.  It is used to
//	test Tcl_GetCommandInfo, Tcl_SetCommandInfo, and command creation and
//	deletion.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various commands and modifies their data.
//
//----------------------------------------------------------------------

func TestcmdinfoCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:964:1: */
	bp := tls.Alloc(360)
	defer tls.Free(360)

	// var info Tcl_CmdInfo at bp+296, 64

	_ = dummy

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1383, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})), ts+1400, /* "original" */
			*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc1})))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1291) == 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteCommand})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringResult})).f(tls, interp, uintptr(unsafe.Pointer(&delString)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1409) == 0 {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandInfo})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+296) == 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1413 /* "??" */, uintptr(0)))
			return TCL_OK
		}
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+296)).proc == *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, ts+1416 /* "CmdProc1" */, ts+1425, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+296 /* &info */)).clientData, uintptr(0)))
		} else if (*Tcl_CmdInfo)(unsafe.Pointer(bp+296)).proc == *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc2})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+80, ts+1427 /* "CmdProc2" */, ts+1425, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+296 /* &info */)).clientData, uintptr(0)))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+112, ts+1436 /* "unknown" */, uintptr(0)))
		}
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+296)).deleteProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc1})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+1444 /* " CmdDelProc1" */, ts+1425, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+296 /* &info */)).deleteData, uintptr(0)))
		} else if (*Tcl_CmdInfo)(unsafe.Pointer(bp+296)).deleteProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc2})) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+160, ts+1457 /* " CmdDelProc2" */, ts+1425, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+296 /* &info */)).deleteData, uintptr(0)))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+1470 /* " unknown" */, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+208, ts+1425 /* " " */, (*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+296 /* &info */)).namespacePtr)).fullName, uintptr(0)))
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+296)).isNativeObjectProc != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+232, ts+1479 /* " nativeObjectPro..." */, uintptr(0)))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+248, ts+1497 /* " stringProc" */, uintptr(0)))
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1509) == 0 {
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 296 /* &info */)).proc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc2}))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 296 /* &info */)).clientData = ts + 1516 /* "new_command_data" */
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 296 /* &info */)).objProc = uintptr(0)
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 296 /* &info */)).objClientData = uintptr(0)
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 296 /* &info */)).deleteProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{CmdDelProc2}))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 296 /* &info */)).deleteData = ts + 1533 /* "new_delete_data" */
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetCommandInfo})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+296) == 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, 0))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, 1))
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+264, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1549, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

func CmdProc1(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1035:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1591 /* "CmdProc1 " */, clientData, uintptr(0)))
	return TCL_OK
}

func CmdProc2(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1046:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1601 /* "CmdProc2 " */, clientData, uintptr(0)))
	return TCL_OK
}

func CmdDelProc1(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1057:1: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), ts+1611 /* "CmdDelProc1 " */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), clientData, -1)
}

func CmdDelProc2(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1066:1: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), ts+1624 /* "CmdDelProc2 " */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&delString)), clientData, -1)
}

//----------------------------------------------------------------------
//
// TestcmdtokenCmd --
//
//	This procedure implements the "testcmdtoken" command. It is used to
//	test Tcl_Command tokens and procedures such as Tcl_GetCommandFullName.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various commands and modifies their data.
//
//----------------------------------------------------------------------

func TestcmdtokenCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1092:1: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var token Tcl_Command
	// var l uintptr at bp+144, 8

	// var buf [30]int8 at bp+112, 30

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1637, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0 {
		token = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})),
			ts+1400, uintptr(0))
		libc.Xsprintf(tls, bp+112, ts+1650, libc.VaList(bp+32, token))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, bp+112 /* &buf[0] */, uintptr(1))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1653) == 0 {
		var objPtr uintptr

		if libc.Xsscanf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+1650, libc.VaList(bp+40, bp+144)) != 1 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, ts+1658 /* "bad command toke..." */, *(*uintptr)(unsafe.Pointer(argv + 2*8)),
				ts+1678, uintptr(0)))
			return TCL_ERROR
		}

		objPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Command, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_GetCommandFullName})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 144 /* l */)), objPtr)

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp,
			(*struct {
				f func(*libc.TLS, uintptr, Tcl_Command) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandName})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 144 /* l */))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, objPtr))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = objPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+80, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1680, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestcmdtraceCmd --
//
//	This procedure implements the "testcmdtrace" command. It is used
//	to test Tcl_CreateTrace and Tcl_DeleteTrace.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes a command trace, and tests the invocation of
//	a procedure by the command trace.
//
//----------------------------------------------------------------------

func TestcmdtraceCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1155:1: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	// var buffer Tcl_DString at bp+112, 216

	var result int32

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1706, uintptr(0)))
		return TCL_ERROR
	}

	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1722) == 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp+112 /* &buffer */)
		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, 0)
		if result == TCL_OK {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, (*Tcl_DString)(unsafe.Pointer(bp+112 /* &buffer */)).string, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+112 /* &buffer */)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1732) == 0 {
		// Create a command trace then eval a script to check whether it is
		// called. Note that this trace procedure removes itself as a further
		// check of the robustness of the trace proc calling code in
		// TclNRExecuteByteCode.

		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceDeleteProc})), uintptr(0))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, 0)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1743) == 0 {
		var iPtr uintptr = interp
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp+112 /* &buffer */)
		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, (*Interp)(unsafe.Pointer(iPtr)).numLevels+4, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})),
			bp+112)
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, 0)
		if result == TCL_OK {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, (*Tcl_DString)(unsafe.Pointer(bp+112 /* &buffer */)).string, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+112 /* &buffer */)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1753) == 0 {

		deleteCalled = 0
		cmdTrace = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, uintptr, ClientData, uintptr) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjTrace})).f(tls, interp, 50000,
			TCL_ALLOW_INLINE_COMPILATION, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, uintptr, Tcl_Command, int32, uintptr) int32
			}{ObjTraceProc})),
			uintptr(unsafe.Pointer(&deleteCalled)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ObjTraceDeleteProc})))
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
		if !(deleteCalled != 0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1764 /* "Delete wasn't ca..." */, uintptr(0))
			return TCL_ERROR
		} else {
			return result
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1785) == 0 {
		var t1 Tcl_Trace
		var t2 Tcl_Trace

		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp+112 /* &buffer */)
		t1 = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 1, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		t2 = (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateTrace})).f(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		if result == TCL_OK {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, (*Tcl_DString)(unsafe.Pointer(bp+112 /* &buffer */)).string, uintptr(0)))
		}
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, t2)
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Trace)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, t1)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+112 /* &buffer */)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+80, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1796, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

var deleteCalled int32 /* tclTest.c:1207:13: */

func CmdTraceProc(tls *libc.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, cmdProc uintptr, cmdClientData ClientData, argc int32, argv uintptr) { /* tclTest.c:1244:1: */
	var bufPtr uintptr = clientData
	var i int32

	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bufPtr, command)

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringStartSublist})).f(tls, bufPtr)
	for i = 0; i < argc; i++ {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bufPtr, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringEndSublist})).f(tls, bufPtr)
}

func CmdTraceDeleteProc(tls *libc.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, cmdProc uintptr, cmdClientData ClientData, argc int32, argv uintptr) { /* tclTest.c:1271:1: */
	// Remove ourselves to test whether calling Tcl_DeleteTrace within a trace
	// callback causes the for loop in TclNRExecuteByteCode that calls traces to
	// reference freed memory.

	(*struct {
		f func(*libc.TLS, uintptr, Tcl_Trace)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteTrace})).f(tls, interp, cmdTrace)
}

func ObjTraceProc(tls *libc.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, token Tcl_Command, objc int32, objv uintptr) int32 { /* tclTest.c:1293:1: */
	var word uintptr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv)))

	if !(libc.Xstrcmp(tls, word, ts+1855) != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, command, -1))
		return TCL_ERROR
	} else if !(libc.Xstrcmp(tls, word, ts+1861) != 0) {
		return TCL_BREAK
	} else if !(libc.Xstrcmp(tls, word, ts+1867) != 0) {
		return TCL_CONTINUE
	} else if !(libc.Xstrcmp(tls, word, ts+1876) != 0) {
		return TCL_RETURN
	} else if !(libc.Xstrcmp(tls, word, ts+1883) != 0) {
		return 6
	} else {
		return TCL_OK
	}
	return int32(0)
}

func ObjTraceDeleteProc(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1321:1: */
	var intPtr uintptr = clientData
	*(*int32)(unsafe.Pointer(intPtr)) = 1 // Record that the trace was deleted
}

//----------------------------------------------------------------------
//
// TestcreatecommandCmd --
//
//	This procedure implements the "testcreatecommand" command. It is used
//	to test that the Tcl_CreateCommand creates a new command in the
//	namespace specified as part of its name, if any. It also checks that
//	the namespace code ignore single ":"s in the middle or end of a
//	command name.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes two commands ("test_ns_basic::createdcommand"
//	and "value:at:").
//
//----------------------------------------------------------------------

func TestcreatecommandCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1350:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+1895, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1904, /* "test_ns_basic::c..." */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
			}{CreatedCommandProc})), uintptr(0), uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1291) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteCommand})).f(tls, interp, ts+1904 /* "test_ns_basic::c..." */)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1934) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+1942, /* "value:at:" */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
			}{CreatedCommandProc2})), uintptr(0), uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1952) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteCommand})).f(tls, interp, ts+1942 /* "value:at:" */)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+1960, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

func CreatedCommandProc(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1380:1: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var info Tcl_CmdInfo at bp+40, 64

	var found int32

	found = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandInfo})).f(tls, interp, ts+1904, /* "test_ns_basic::c..." */
		bp+40)
	if !(found != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2007, /* "CreatedCommandPr..." */
			uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+2087, /* "CreatedCommandPr..." */
		(*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+40 /* &info */)).namespacePtr)).fullName, uintptr(0)))
	return TCL_OK
}

func CreatedCommandProc2(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1402:1: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var info Tcl_CmdInfo at bp+40, 64

	var found int32

	found = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandInfo})).f(tls, interp, ts+1942 /* "value:at:" */, bp+40 /* &info */)
	if !(found != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2110, /* "CreatedCommandPr..." */
			uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+2191, /* "CreatedCommandPr..." */
		(*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+40 /* &info */)).namespacePtr)).fullName, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestdcallCmd --
//
//	This procedure implements the "testdcall" command.  It is used
//	to test Tcl_CallWhenDeleted.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes interpreters.
//
//----------------------------------------------------------------------

func TestdcallCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1440:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	// var id int32 at bp, 4

	delInterp = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateInterp})).f(tls)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, uintptr(unsafe.Pointer(&delString)))
	for i = 1; i < argc; i++ {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp)) < 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DontCallWhenDeleted})).f(tls, delInterp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr)
			}{DelCallbackProc})),
				uintptr(intptr_t(-*(*int32)(unsafe.Pointer(bp)))))
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CallWhenDeleted})).f(tls, delInterp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr)
			}{DelCallbackProc})),
				uintptr(intptr_t(*(*int32)(unsafe.Pointer(bp /* id */)))))
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, delInterp)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringResult})).f(tls, interp, uintptr(unsafe.Pointer(&delString)))
	return TCL_OK
}

// The deletion callback used by TestdcallCmd:

func DelCallbackProc(tls *libc.TLS, clientData ClientData, interp uintptr) { /* tclTest.c:1472:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var id int32 = int32(clientData)
	// var buffer [24]int8 at bp, 24

	(*struct {
		f func(*libc.TLS, uintptr, int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp /* &buffer[0] */, int64(id))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, uintptr(unsafe.Pointer(&delString)), bp /* &buffer[0] */)
	if interp != delInterp {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, uintptr(unsafe.Pointer(&delString)), ts+2215 /* "bogus interprete..." */)
	}
}

//----------------------------------------------------------------------
//
// TestdelCmd --
//
//	This procedure implements the "testdel" command.  It is used
//	to test calling of command deletion callbacks.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates a command.
//
//----------------------------------------------------------------------

func TestdelCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1504:1: */
	var dPtr uintptr
	var child uintptr

	if argc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1271 /* "wrong # args" */, uintptr(0))
		return TCL_ERROR
	}

	child = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetSlave})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if child == uintptr(0) {
		return TCL_ERROR
	}

	dPtr = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(DelCmd{})))
	(*DelCmd)(unsafe.Pointer(dPtr)).interp = interp
	(*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))+uint64(1)))
	libc.Xstrcpy(tls, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd, *(*uintptr)(unsafe.Pointer(argv + 3*8)))

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, child, *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{DelCmdProc})), dPtr,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{DelDeleteProc})))
	return TCL_OK
}

func DelCmdProc(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1534:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var dPtr uintptr = clientData

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd, uintptr(0)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, dPtr)
	return TCL_OK
}

func DelDeleteProc(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1549:1: */
	var dPtr uintptr = clientData

	(*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).interp, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).interp)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, dPtr)
}

//----------------------------------------------------------------------
//
// TestdelassocdataCmd --
//
//	This procedure implements the "testdelassocdata" command. It is used
//	to test Tcl_DeleteAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Deletes an association between a key and associated data from an
//	interpreter.
//
//----------------------------------------------------------------------

func TestdelassocdataCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1579:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+2274, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	return TCL_OK
}

//-----------------------------------------------------------------------------
//
// TestdoubledigitsCmd --
//
//	This procedure implements the 'testdoubledigits' command. It is
//	used to test the low-level floating-point formatting primitives
//	in Tcl.
//
// Usage:
//	testdoubledigits fpval ndigits type ?shorten"
//
// Parameters:
//	fpval - Floating-point value to format.
//	ndigits - Digit count to request from Tcl_DoubleDigits
//	type - One of 'shortest', 'Steele', 'e', 'f'
//	shorten - Indicates that the 'shorten' flag should be passed in.
//
//-----------------------------------------------------------------------------

func TestdoubledigitsObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1616:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var doubleType uintptr
	// var d float64 at bp+8, 8

	var status int32
	// var ndigits int32 at bp+16, 4

	// var type1 int32 at bp+20, 4

	// var decpt int32 at bp+24, 4

	// var signum int32 at bp+28, 4

	var str uintptr
	// var endPtr uintptr at bp+32, 8

	// var strObj uintptr at bp+40, 8

	var retval uintptr

	if objc < 4 || objc > 5 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+2285 /* "fpval ndigits ty..." */)
		return TCL_ERROR
	}
	status = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDoubleFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8 /* &d */)
	if status != TCL_OK {
		doubleType = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, ts+2314 /* "double" */)
		if (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)))).typePtr == doubleType ||
			*(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)) + 32)) != *(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)) + 32)) {
			status = TCL_OK
			libc.Xmemcpy(tls, bp+8, *(*uintptr)(unsafe.Pointer(objv + 1*8))+32, uint64(unsafe.Sizeof(float64(0))))
		}
	}
	if status != TCL_OK ||
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+16) != TCL_OK ||
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), uintptr(unsafe.Pointer(&options)), int32(unsafe.Sizeof(uintptr(0))), ts+2321, TCL_EXACT, bp+20) != TCL_OK {
		libc.Xfprintf(tls, libc.X__stderrp, ts+2337, libc.VaList(bp, *(*float64)(unsafe.Pointer(bp + 8 /* d */))))
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 20 /* type1 */)) = types1[*(*int32)(unsafe.Pointer(bp + 20 /* type1 */))]
	if objc > 4 {
		if libc.Xstrcmp(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8))), ts+2352) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+2360 /* "bad flag" */, -1))
			return TCL_ERROR
		}
		*(*int32)(unsafe.Pointer(bp + 20 /* type1 */)) |= TCL_DD_SHORTEN_FLAG
	}
	str = (*struct {
		f func(*libc.TLS, float64, int32, int32, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclDoubleDigits})).f(tls, *(*float64)(unsafe.Pointer(bp + 8 /* d */)), *(*int32)(unsafe.Pointer(bp + 16 /* ndigits */)), *(*int32)(unsafe.Pointer(bp + 20 /* type1 */)), bp+24 /* &decpt */, bp+28 /* &signum */, bp+32 /* &endPtr */)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)) = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, str, int32((int64(*(*uintptr)(unsafe.Pointer(bp + 32 /* endPtr */)))-int64(str))/1))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, str)
	retval = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 1, bp+40 /* &strObj */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), retval, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 24 /* decpt */))))
	*(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)) = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 28)) != 0 {
			return ts + 2369 /* "-" */
		}
		return ts + 2371 /* "+" */
	}(), 1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), retval, *(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, retval)
	return TCL_OK
}

var options = [5]uintptr{
	ts + 2373,
	ts + 2382,
	ts + 2389,
	ts + 2391,
	uintptr(0),
} /* tclTest.c:1625:22 */
var types1 = [4]int32{
	TCL_DD_SHORTEST,
	TCL_DD_STEELE,
	TCL_DD_E_FORMAT,
	TCL_DD_F_FORMAT,
} /* tclTest.c:1632:22 */

//----------------------------------------------------------------------
//
// TestdstringCmd --
//
//	This procedure implements the "testdstring" command.  It is used
//	to test the dynamic string facilities of Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes, and invokes handlers.
//
//----------------------------------------------------------------------

func TestdstringCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1708:1: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var count int32 at bp+64, 4

	var s uintptr
	var s1 uintptr

	if !(argc < 2) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1271 /* "wrong # args" */, uintptr(0))
	return TCL_ERROR
__1:
	;
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2393) == 0) {
		goto __2
	}
	if !(argc != 4) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+64) != TCL_OK) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, uintptr(unsafe.Pointer(&dstring)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*int32)(unsafe.Pointer(bp + 64 /* count */)))
	goto __3
__2:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2400) == 0) {
		goto __6
	}
	if !(argc != 3) {
		goto __8
	}
	goto wrongNumArgs
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, uintptr(unsafe.Pointer(&dstring)), *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	goto __7
__6:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2408) == 0) {
		goto __9
	}
	if !(argc != 2) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringEndSublist})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __10
__9:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2412) == 0) {
		goto __12
	}
	if !(argc != 2) {
		goto __14
	}
	goto wrongNumArgs
__14:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __13
__12:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1409) == 0) {
		goto __15
	}
	if !(argc != 2) {
		goto __17
	}
	goto wrongNumArgs
__17:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, (*Tcl_DString)(unsafe.Pointer(uintptr(unsafe.Pointer(&dstring)))).string, uintptr(1))
	goto __16
__15:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+2417) == 0) {
		goto __18
	}
	if !(argc != 3) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+2425) == 0) {
		goto __21
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+2437 /* "short" */, uintptr(0))
	goto __22
__21:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+2443) == 0) {
		goto __23
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+2455 /* "first0 first1 fi..." */, uintptr(0))
	goto __24
__23:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+2412) == 0) {
		goto __25
	}
	s = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(100))
	libc.Xstrcpy(tls, s, ts+2986)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, s, uintptr(3))
	goto __26
__25:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+3013) == 0) {
		goto __27
	}
	s1 = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(100)) + uintptr(16)
	libc.Xstrcpy(tls, s1, ts+3021)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, s1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{SpecialFree})))
	goto __28
__27:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+3058 /* "bad gresult opti..." */, *(*uintptr)(unsafe.Pointer(argv + 2*8)),
		ts+3079,
		uintptr(0)))
	return TCL_ERROR
__28:
	;
__26:
	;
__24:
	;
__22:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringGetResult})).f(tls, interp, uintptr(unsafe.Pointer(&dstring)))
	goto __19
__18:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3133) == 0) {
		goto __29
	}

	if !(argc != 2) {
		goto __31
	}
	goto wrongNumArgs
__31:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_DString)(unsafe.Pointer(uintptr(unsafe.Pointer(&dstring)))).length))
	goto __30
__29:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3140) == 0) {
		goto __32
	}
	if !(argc != 2) {
		goto __34
	}
	goto wrongNumArgs
__34:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringResult})).f(tls, interp, uintptr(unsafe.Pointer(&dstring)))
	goto __33
__32:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3147) == 0) {
		goto __35
	}
	if !(argc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+64) != TCL_OK) {
		goto __38
	}
	return TCL_ERROR
__38:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringSetLength})).f(tls, uintptr(unsafe.Pointer(&dstring)), *(*int32)(unsafe.Pointer(bp + 64 /* count */)))
	goto __36
__35:
	if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3153) == 0) {
		goto __39
	}
	if !(argc != 2) {
		goto __41
	}
	goto wrongNumArgs
__41:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringStartSublist})).f(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __40
__39:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

		ts+3159, uintptr(0)))
	return TCL_ERROR
__40:
	;
__36:
	;
__33:
	;
__30:
	;
__19:
	;
__16:
	;
__13:
	;
__10:
	;
__7:
	;
__3:
	;
	return TCL_OK
}

// The procedure below is used as a special freeProc to test how well
// Tcl_DStringGetResult handles freeProc's other than free.

func SpecialFree(tls *libc.TLS, blockPtr uintptr) { /* tclTest.c:1810:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, blockPtr-uintptr(16))
}

//----------------------------------------------------------------------
//
// TestencodingCmd --
//
//	This procedure implements the "testencoding" command.  It is used
//	to test the encoding package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Load encodings.
//
//----------------------------------------------------------------------

func TestencodingObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1834:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var encoding Tcl_Encoding
	// var index int32 at bp, 4

	// var length int32 at bp+4, 4

	var string uintptr
	var encodingPtr uintptr

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&optionStrings)), int32(unsafe.Sizeof(uintptr(0))), ts+3235, 0, bp) != TCL_OK {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp /* index */))) {
	case uint32(0) /* ENC_CREATE */ :
		{
			// var type1 Tcl_EncodingType at bp+8, 48

			if objc != 5 {
				return TCL_ERROR
			}
			encodingPtr = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TclEncoding{})))
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).interp = interp

			string = (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+4 /* &length */)
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(*(*int32)(unsafe.Pointer(bp + 4))+1))
			libc.Xmemcpy(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd, string, uint64(*(*int32)(unsafe.Pointer(bp + 4))+1))

			string = (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+4 /* &length */)
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(*(*int32)(unsafe.Pointer(bp + 4))+1))
			libc.Xmemcpy(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd, string, uint64(*(*int32)(unsafe.Pointer(bp + 4))+1))

			string = (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &length */)

			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).encodingName = string
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).toUtfProc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, int32, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32
			}{EncodingToUtfProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).fromUtfProc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, ClientData, uintptr, int32, int32, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32
			}{EncodingFromUtfProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).freeProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{EncodingFreeProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).clientData = encodingPtr
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).nullSize = 1

			(*struct {
				f func(*libc.TLS, uintptr) Tcl_Encoding
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateEncoding})).f(tls, bp+8 /* &type1 */)
			break

		}
	case uint32(1) /* ENC_DELETE */ :
		if objc != 3 {
			return TCL_ERROR
		}
		encoding = (*struct {
			f func(*libc.TLS, uintptr, uintptr) Tcl_Encoding
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetEncoding})).f(tls, uintptr(0), (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
		(*struct{ f func(*libc.TLS, Tcl_Encoding) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeEncoding})).f(tls, encoding)
		(*struct{ f func(*libc.TLS, Tcl_Encoding) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeEncoding})).f(tls, encoding)
		break
	}
	return TCL_OK
}

var optionStrings = [3]uintptr{
	ts + 1284, ts + 1291, uintptr(0),
} /* tclTest.c:1844:23 */

func EncodingToUtfProc(tls *libc.TLS, clientData ClientData, src uintptr, srcLen int32, flags int32, statePtr uintptr, dst uintptr, dstLen int32, srcReadPtr uintptr, dstWrotePtr uintptr, dstCharsPtr uintptr) int32 { /* tclTest.c:1899:1: */
	var len int32
	var encodingPtr uintptr

	encodingPtr = clientData
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd, -1, TCL_EVAL_GLOBAL)

	len = int32(libc.Xstrlen(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)))
	if len > dstLen {
		len = dstLen
	}
	libc.Xmemcpy(tls, dst, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp), uint64(len))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)

	*(*int32)(unsafe.Pointer(srcReadPtr)) = srcLen
	*(*int32)(unsafe.Pointer(dstWrotePtr)) = len
	*(*int32)(unsafe.Pointer(dstCharsPtr)) = len
	return TCL_OK
}

func EncodingFromUtfProc(tls *libc.TLS, clientData ClientData, src uintptr, srcLen int32, flags int32, statePtr uintptr, dst uintptr, dstLen int32, srcReadPtr uintptr, dstWrotePtr uintptr, dstCharsPtr uintptr) int32 { /* tclTest.c:1931:1: */
	var len int32
	var encodingPtr uintptr

	encodingPtr = clientData
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd, -1, TCL_EVAL_GLOBAL)

	len = int32(libc.Xstrlen(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)))
	if len > dstLen {
		len = dstLen
	}
	libc.Xmemcpy(tls, dst, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp), uint64(len))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)

	*(*int32)(unsafe.Pointer(srcReadPtr)) = srcLen
	*(*int32)(unsafe.Pointer(dstWrotePtr)) = len
	*(*int32)(unsafe.Pointer(dstCharsPtr)) = len
	return TCL_OK
}

func EncodingFreeProc(tls *libc.TLS, clientData ClientData) { /* tclTest.c:1963:1: */
	var encodingPtr uintptr = clientData

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, encodingPtr)
}

//----------------------------------------------------------------------
//
// TestevalexObjCmd --
//
//	This procedure implements the "testevalex" command.  It is
//	used to test Tcl_EvalEx.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestevalexObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1991:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var length int32 at bp+32, 4

	var flags int32
	var script uintptr

	flags = 0
	if objc == 3 {
		var global uintptr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
		if libc.Xstrcmp(tls, global, ts+3242) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+3249 /* "bad value \"" */, global,
				ts+3261, uintptr(0)))
			return TCL_ERROR
		}
		flags = TCL_EVAL_GLOBAL
	} else if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3279 /* "script ?global?" */)
		return TCL_ERROR
	}

	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+32 /* &length */)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 32 /* length */)), flags)
}

//----------------------------------------------------------------------
//
// TestevalobjvObjCmd --
//
//	This procedure implements the "testevalobjv" command.  It is
//	used to test Tcl_EvalObjv.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestevalobjvObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2036:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var evalGlobal int32 at bp, 4

	if objc < 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3295 /* "global word ?wor..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != TCL_OK {
		return TCL_ERROR
	}
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalObjv})).f(tls, interp, objc-2, objv+uintptr(2)*8,
		func() int32 {
			if *(*int32)(unsafe.Pointer(bp)) != 0 {
				return TCL_EVAL_GLOBAL
			}
			return 0
		}())
}

//----------------------------------------------------------------------
//
// TesteventObjCmd --
//
//	This procedure implements a 'testevent' command.  The command
//	is used to test event queue management.
//
// The command takes two forms:
//	- testevent queue name position script
//		Queues an event at the given position in the queue, and
//		associates a given name with it (the same name may be
//		associated with multiple events). When the event comes
//		to the head of the queue, executes the given script at
//		global level in the current interp. The position may be
//		one of 'head', 'tail' or 'mark'.
//	- testevent delete name
//		Deletes any events associated with the given name from
//		the queue.
//
// Return value:
//	Returns a standard Tcl result.
//
// Side effects:
//	Manipulates the event queue as directed.
//
//----------------------------------------------------------------------

func TesteventObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2085:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var subCmdIndex int32 at bp, 4

	// var posIndex int32 at bp+4, 4

	var ev uintptr // Event to be queued

	if objc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3318 /* "subcommand ?arg ..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&subcommands)), int32(unsafe.Sizeof(uintptr(0))), ts+3339, TCL_EXACT, bp) != TCL_OK {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp /* subCmdIndex */)) {
	case 0: // queue
		if objc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+3350 /* "name position sc..." */)
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), uintptr(unsafe.Pointer(&positions)), int32(unsafe.Sizeof(uintptr(0))), ts+3371, TCL_EXACT, bp+4) != TCL_OK {
			return TCL_ERROR
		}
		ev = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TestEvent{})))
		(*TestEvent)(unsafe.Pointer(ev)).header.proc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{TesteventProc}))
		(*TestEvent)(unsafe.Pointer(ev)).header.nextPtr = uintptr(0)
		(*TestEvent)(unsafe.Pointer(ev)).interp = interp
		(*TestEvent)(unsafe.Pointer(ev)).command = *(*uintptr)(unsafe.Pointer(objv + 4*8))
		(*Tcl_Obj)(unsafe.Pointer((*TestEvent)(unsafe.Pointer(ev)).command)).refCount++
		(*TestEvent)(unsafe.Pointer(ev)).tag = *(*uintptr)(unsafe.Pointer(objv + 2*8))
		(*Tcl_Obj)(unsafe.Pointer((*TestEvent)(unsafe.Pointer(ev)).tag)).refCount++
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_QueuePosition)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_QueueEvent})).f(tls, ev, posNum[*(*int32)(unsafe.Pointer(bp + 4 /* posIndex */))])
		break

	case 1: // delete
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+1653 /* "name" */)
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteEvents})).f(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, ClientData) int32
		}{TesteventDeleteProc})), *(*uintptr)(unsafe.Pointer(objv + 2*8)))
		break
	}

	return TCL_OK
}

var subcommands = [3]uintptr{ // Possible subcommands
	ts + 3390, ts + 1291, uintptr(0),
}                           /* tclTest.c:2091:23 */
var positions = [4]uintptr{ // Possible queue positions
	ts + 3396, ts + 3401, ts + 1298, uintptr(0),
} /* tclTest.c:2095:23 */
var posNum = [3]Tcl_QueuePosition{
	// Interpretation of the chosen position
	TCL_QUEUE_HEAD,
	TCL_QUEUE_TAIL,
	TCL_QUEUE_MARK,
} /* tclTest.c:2099:36 */

//----------------------------------------------------------------------
//
// TesteventProc --
//
//	Delivers a test event to the Tcl interpreter as part of event
//	queue testing.
//
// Results:
//	Returns 1 if the event has been serviced, 0 otherwise.
//
// Side effects:
//	Evaluates the event's callback script, so has whatever side effects
//	the callback has.  The return value of the callback script becomes the
//	return value of this function.  If the callback script reports an
//	error, it is reported as a background error.
//
//----------------------------------------------------------------------

func TesteventProc(tls *libc.TLS, event uintptr, flags int32) int32 { /* tclTest.c:2169:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var ev uintptr = event
	var interp uintptr = (*TestEvent)(unsafe.Pointer(ev)).interp
	var command uintptr = (*TestEvent)(unsafe.Pointer(ev)).command
	var result int32 = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalObjEx})).f(tls, interp, command,
		TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT)
	// var retval int32 at bp, 4

	if result != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp,
			ts+3406)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_BackgroundError})).f(tls, interp)
		return 1 // Avoid looping on errors
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		bp) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp,
			ts+3450)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_BackgroundError})).f(tls, interp)
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp)) != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).tag
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).command
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* retval */))
}

//----------------------------------------------------------------------
//
// TesteventDeleteProc --
//
//	Removes some set of events from the queue.
//
// This procedure is used as part of testing event queue management.
//
// Results:
//	Returns 1 if a given event should be deleted, 0 otherwise.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TesteventDeleteProc(tls *libc.TLS, event uintptr, clientData ClientData) int32 { /* tclTest.c:2220:1: */
	var ev uintptr // Event to examine
	var evNameStr uintptr
	var targetName uintptr // Name of the event(s) to delete
	var targetNameStr uintptr

	if (*Tcl_Event)(unsafe.Pointer(event)).proc != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{TesteventProc})) {
		return 0
	}
	targetName = clientData
	targetNameStr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, targetName)
	ev = event
	evNameStr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, (*TestEvent)(unsafe.Pointer(ev)).tag)
	if libc.Xstrcmp(tls, evNameStr, targetNameStr) == 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).tag
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*TestEvent)(unsafe.Pointer(ev)).command
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		return 1
	} else {
		return 0
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestexithandlerCmd --
//
//	This procedure implements the "testexithandler" command. It is
//	used to test Tcl_CreateExitHandler and Tcl_DeleteExitHandler.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexithandlerCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2264:1: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var value int32 at bp+64, 4

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3495, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+64) != TCL_OK {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateExitHandler})).f(tls, func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 64))&1 != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcOdd}))
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcEven}))
		}(),
			uintptr(intptr_t(*(*int32)(unsafe.Pointer(bp + 64)))))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1291) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteExitHandler})).f(tls, func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 64))&1 != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcOdd}))
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{ExitProcEven}))
		}(),
			uintptr(intptr_t(*(*int32)(unsafe.Pointer(bp + 64)))))
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+3517, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

func ExitProcOdd(tls *libc.TLS, clientData ClientData) { /* tclTest.c:2295:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var buf [40]int8 at bp+8, 40

	var len int32

	libc.Xsprintf(tls, bp+8, ts+3545, libc.VaList(bp, int32(clientData)))
	len = int32(libc.Xstrlen(tls, bp+8))
	if len != int32(libc.Xwrite(tls, 1, bp+8, uint64(len))) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+3553 /* "ExitProcOdd: una..." */, 0)
	}
}

func ExitProcEven(tls *libc.TLS, clientData ClientData) { /* tclTest.c:2309:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var buf [40]int8 at bp+8, 40

	var len int32

	libc.Xsprintf(tls, bp+8, ts+3592, libc.VaList(bp, int32(clientData)))
	len = int32(libc.Xstrlen(tls, bp+8))
	if len != int32(libc.Xwrite(tls, 1, bp+8, uint64(len))) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+3601 /* "ExitProcEven: un..." */, 0)
	}
}

//----------------------------------------------------------------------
//
// TestexprlongCmd --
//
//	This procedure verifies that Tcl_ExprLong does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprlongCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2340:1: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	// var exprResult int64 at bp+56, 8

	// var buf [28]int8 at bp+64, 28

	var result int32

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3641, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3654 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprLong})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+56 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xsprintf(tls, bp+64, ts+3671, libc.VaList(bp+32, *(*int64)(unsafe.Pointer(bp + 56 /* exprResult */))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+40, bp+64 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprlongobjCmd --
//
//	This procedure verifies that Tcl_ExprLongObj does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprlongobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2383:1: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	// var exprResult int64 at bp+24, 8

	// var buf [28]int8 at bp+32, 28

	var result int32

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3677 /* "expression" */)
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3654 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprLongObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+24 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xsprintf(tls, bp+32, ts+3671, libc.VaList(bp, *(*int64)(unsafe.Pointer(bp + 24 /* exprResult */))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+8, bp+32 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprdoubleCmd --
//
//	This procedure verifies that Tcl_ExprDouble does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprdoubleCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2425:1: */
	bp := tls.Alloc(87)
	defer tls.Free(87)

	// var exprResult float64 at bp+48, 8

	// var buf [31]int8 at bp+56, 31

	var result int32

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3641, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3654 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xstrcpy(tls, bp+56, ts+3688)
	(*struct {
		f func(*libc.TLS, uintptr, float64, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, interp, *(*float64)(unsafe.Pointer(bp + 48 /* exprResult */)), bp+56 /* &buf[0] */ +uintptr(2))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, bp+56 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprdoubleobjCmd --
//
//	This procedure verifies that Tcl_ExprLongObj does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprdoubleobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2469:1: */
	bp := tls.Alloc(55)
	defer tls.Free(55)

	// var exprResult float64 at bp+16, 8

	// var buf [31]int8 at bp+24, 31

	var result int32

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3677 /* "expression" */)
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+3654 /* "This is a result" */, uintptr(0))
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprDoubleObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16 /* &exprResult */)
	if result != TCL_OK {
		return result
	}
	libc.Xstrcpy(tls, bp+24, ts+3688)
	(*struct {
		f func(*libc.TLS, uintptr, float64, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, interp, *(*float64)(unsafe.Pointer(bp + 16 /* exprResult */)), bp+24 /* &buf[0] */ +uintptr(2))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, bp+24 /* &buf[0] */, uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprstringCmd --
//
//	This procedure tests the basic operation of Tcl_ExprString.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprstringCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2511:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3641, uintptr(0)))
		return TCL_ERROR
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ExprString})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
}

//----------------------------------------------------------------------
//
// TestfilelinkCmd --
//
//	This procedure implements the "testfilelink" command.  It is used to
//	test the effects of creating and manipulating filesystem links in Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	May create a link on disk.
//
//----------------------------------------------------------------------

func TestfilelinkCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2543:1: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var contents uintptr

	if objc < 2 || objc > 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+3691 /* "source ?target?" */)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSConvertToPathType})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8))) != TCL_OK {
		return TCL_ERROR
	}

	if objc == 3 {
		// Create link from source to target
		contents = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLink})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), *(*uintptr)(unsafe.Pointer(objv + 2*8)),
			TCL_CREATE_SYMBOLIC_LINK|TCL_CREATE_HARD_LINK)
		if contents == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+3707, /* "could not create..." */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), ts+3736, /* "\" to \"" */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), ts+3743, /* "\": " */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
			return TCL_ERROR
		}
	} else {
		// Read link
		contents = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLink})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(0), 0)
		if contents == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+56, ts+3747, /* "could not read l..." */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), ts+3743, /* "\": " */
				(*struct {
					f func(*libc.TLS, uintptr) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
			return TCL_ERROR
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, contents)
	if objc == 2 {
		// If we are creating a link, this will actually just
		// be objv[3], and we don't own it
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = contents
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetassocdataCmd --
//
//	This procedure implements the "testgetassocdata" command. It is
//	used to test Tcl_GetAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetassocdataCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2610:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var res uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+2274, uintptr(0)))
		return TCL_ERROR
	}
	res = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0))
	if res != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, res, uintptr(0)))
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetplatformCmd --
//
//	This procedure implements the "testgetplatform" command. It is
//	used to retrievel the value of the tclPlatform global variable.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetplatformCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2648:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var platform uintptr

	platform = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetPlatform})).f(tls)

	if argc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			uintptr(0)))
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+24, platformStrings[*(*TclPlatformType)(unsafe.Pointer(platform))], uintptr(0)))
	return TCL_OK
}

var platformStrings = [3]uintptr{ts + 3769, ts + 3774, ts + 3778} /* tclTest.c:2654:23 */

//----------------------------------------------------------------------
//
// TestinterpdeleteCmd --
//
//	This procedure tests the code in tclInterp.c that deals with
//	interpreter deletion. It deletes a user-specified interpreter
//	from the hierarchy, and subsequent code checks integrity.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Deletes one or more interpreters.
//
//----------------------------------------------------------------------

func TestinterpdeleteCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2688:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var childToDelete uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+3786, uintptr(0)))
		return TCL_ERROR
	}
	childToDelete = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetSlave})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if childToDelete == uintptr(0) {
		return TCL_ERROR
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, childToDelete)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestlinkCmd --
//
//	This procedure implements the "testlink" command.  It is used
//	to test Tcl_LinkVar and related library procedures.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various variable links, plus returns
//	values of the linked variables.
//
//----------------------------------------------------------------------

func TestlinkCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2728:1: */
	bp := tls.Alloc(312)
	defer tls.Free(312)

	// var buffer [54]int8 at bp+212, 54

	// var writable int32 at bp+208, 4

	var flag int32
	var tmp uintptr

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),

			ts+3793, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0 {
		if argc != 16 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1357, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+1425, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

				ts+3860, uintptr(0)))
			return TCL_ERROR
		}
		if created != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3968 /* "int" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3972 /* "real" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3977 /* "bool" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3982 /* "string" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3989 /* "wide" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3994 /* "char" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3999 /* "uchar" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+2437 /* "short" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4005 /* "ushort" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4012 /* "uint" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4017 /* "long" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4022 /* "ulong" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4028 /* "float" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4034 /* "uwide" */)
		}
		created = 1
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3968, uintptr(unsafe.Pointer(&intVar)),
			TCL_LINK_INT|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3972, uintptr(unsafe.Pointer(&realVar)),
			TCL_LINK_DOUBLE|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3977, uintptr(unsafe.Pointer(&boolVar)),
			TCL_LINK_BOOLEAN|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 5*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3982, uintptr(unsafe.Pointer(&stringVar)),
			TCL_LINK_STRING|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 6*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3989, uintptr(unsafe.Pointer(&wideVar)),
			TCL_LINK_WIDE_INT|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 7*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3994, uintptr(unsafe.Pointer(&charVar)),
			TCL_LINK_CHAR|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 8*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+3999, uintptr(unsafe.Pointer(&ucharVar)),
			TCL_LINK_UCHAR|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 9*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+2437, uintptr(unsafe.Pointer(&shortVar)),
			TCL_LINK_SHORT|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 10*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+4005, uintptr(unsafe.Pointer(&ushortVar)),
			TCL_LINK_USHORT|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 11*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+4012, uintptr(unsafe.Pointer(&uintVar)),
			TCL_LINK_UINT|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 12*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+4017, uintptr(unsafe.Pointer(&longVar)),
			TCL_LINK_LONG|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 13*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+4022, uintptr(unsafe.Pointer(&ulongVar)),
			TCL_LINK_ULONG|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 14*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+4028, uintptr(unsafe.Pointer(&floatVar)),
			TCL_LINK_FLOAT|flag) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBoolean})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 15*8)), bp+208) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 208)) != 0 {
			flag = 0
		} else {
			flag = TCL_LINK_READ_ONLY
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_LinkVar})).f(tls, interp, ts+4034, uintptr(unsafe.Pointer(&uwideVar)),
			TCL_LINK_WIDE_UINT|flag) != TCL_OK {
			return TCL_ERROR
		}

	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1291) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3968 /* "int" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3972 /* "real" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3977 /* "bool" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3982 /* "string" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3989 /* "wide" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3994 /* "char" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+3999 /* "uchar" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+2437 /* "short" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4005 /* "ushort" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4012 /* "uint" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4017 /* "long" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4022 /* "ulong" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4028 /* "float" */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnlinkVar})).f(tls, interp, ts+4034 /* "uwide" */)
		created = 0
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1409) == 0 {
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(intVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, float64, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, uintptr(0), realVar, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(boolVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
			if stringVar == uintptr(0) {
				return ts + 2369 /* "-" */
			}
			return stringVar
		}())
		// Wide ints only have an object-based interface.
		tmp = (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, wideVar)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(charVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(ucharVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(shortVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(ushortVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+212 /* &buffer[0] */, int64(int32(uintVar)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		tmp = (*struct {
			f func(*libc.TLS, int64) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, longVar)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		tmp = (*struct {
			f func(*libc.TLS, int64) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(ulongVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		(*struct {
			f func(*libc.TLS, uintptr, float64, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PrintDouble})).f(tls, uintptr(0), float64(floatVar), bp+212 /* &buffer[0] */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+212 /* &buffer[0] */)
		tmp = (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt(uwideVar))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, tmp))
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = tmp
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4040) == 0 {
		// var v int32 at bp+268, 4

		if argc != 16 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+80, ts+1357, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+1425, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

				ts+4044, uintptr(0)))
			return TCL_ERROR
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 2*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(unsafe.Pointer(&intVar))) != TCL_OK {
				return TCL_ERROR
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 3*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), uintptr(unsafe.Pointer(&realVar))) != TCL_OK {
				return TCL_ERROR
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 4*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), uintptr(unsafe.Pointer(&boolVar))) != TCL_OK {
				return TCL_ERROR
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 5*8))))) != 0 {
			if stringVar != uintptr(0) {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, stringVar)
			}
			if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+2369) == 0 {
				stringVar = uintptr(0)
			} else {
				stringVar = (*struct {
					f func(*libc.TLS, uint32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)))+uint64(1)))
				libc.Xstrcpy(tls, stringVar, *(*uintptr)(unsafe.Pointer(argv + 5*8)))
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 6*8))))) != 0 {
			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 6*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, uintptr(unsafe.Pointer(&wideVar))) != TCL_OK {
				for ok4 := true; ok4; ok4 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok5 := true; ok5; ok5 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 7*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 7*8)), bp+268) != TCL_OK {
				return TCL_ERROR
			}
			charVar = int8(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 8*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 8*8)), bp+268) != TCL_OK {
				return TCL_ERROR
			}
			ucharVar = uint8(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 9*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 9*8)), bp+268) != TCL_OK {
				return TCL_ERROR
			}
			shortVar = int16(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 10*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 10*8)), bp+268) != TCL_OK {
				return TCL_ERROR
			}
			ushortVar = uint16(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 11*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 11*8)), bp+268) != TCL_OK {
				return TCL_ERROR
			}
			uintVar = uint32(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 12*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 12*8)), bp+268) != TCL_OK {
				return TCL_ERROR
			}
			longVar = int64(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 13*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 13*8)), bp+268) != TCL_OK {
				return TCL_ERROR
			}
			ulongVar = uint64(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 14*8)))) != 0 {
			// var d float64 at bp+272, 8

			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 14*8)), bp+272) != TCL_OK {
				return TCL_ERROR
			}
			floatVar = float32(*(*float64)(unsafe.Pointer(bp + 272 /* d */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 15*8)))) != 0 {
			// var w Tcl_WideInt at bp+280, 8

			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 15*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, bp+280) != TCL_OK {
				for ok6 := true; ok6; ok6 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok7 := true; ok7; ok7 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			uwideVar = Tcl_WideUInt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 280 /* w */)))
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4194) == 0 {
		// var v int32 at bp+288, 4

		if argc != 16 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+1357, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+1425, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

				ts+4044, uintptr(0)))
			return TCL_ERROR
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 2*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(unsafe.Pointer(&intVar))) != TCL_OK {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3968 /* "int" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 3*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), uintptr(unsafe.Pointer(&realVar))) != TCL_OK {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3972 /* "real" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 4*8))))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), uintptr(unsafe.Pointer(&boolVar))) != TCL_OK {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3977 /* "bool" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 5*8))))) != 0 {
			if stringVar != uintptr(0) {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, stringVar)
			}
			if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+2369) == 0 {
				stringVar = uintptr(0)
			} else {
				stringVar = (*struct {
					f func(*libc.TLS, uint32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)))+uint64(1)))
				libc.Xstrcpy(tls, stringVar, *(*uintptr)(unsafe.Pointer(argv + 5*8)))
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3982 /* "string" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 6*8))))) != 0 {
			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 6*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, uintptr(unsafe.Pointer(&wideVar))) != TCL_OK {
				for ok8 := true; ok8; ok8 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok9 := true; ok9; ok9 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3989 /* "wide" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 7*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 7*8)), bp+288) != TCL_OK {
				return TCL_ERROR
			}
			charVar = int8(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3994 /* "char" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 8*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 8*8)), bp+288) != TCL_OK {
				return TCL_ERROR
			}
			ucharVar = uint8(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+3999 /* "uchar" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 9*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 9*8)), bp+288) != TCL_OK {
				return TCL_ERROR
			}
			shortVar = int16(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+2437 /* "short" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 10*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 10*8)), bp+288) != TCL_OK {
				return TCL_ERROR
			}
			ushortVar = uint16(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+4005 /* "ushort" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 11*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 11*8)), bp+288) != TCL_OK {
				return TCL_ERROR
			}
			uintVar = uint32(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+4012 /* "uint" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 12*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 12*8)), bp+288) != TCL_OK {
				return TCL_ERROR
			}
			longVar = int64(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+4017 /* "long" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 13*8)))) != 0 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 13*8)), bp+288) != TCL_OK {
				return TCL_ERROR
			}
			ulongVar = uint64(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+4022 /* "ulong" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 14*8)))) != 0 {
			// var d float64 at bp+296, 8

			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 14*8)), bp+296) != TCL_OK {
				return TCL_ERROR
			}
			floatVar = float32(*(*float64)(unsafe.Pointer(bp + 296 /* d */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+4028 /* "float" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 15*8)))) != 0 {
			// var w Tcl_WideInt at bp+304, 8

			tmp = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 15*8)), -1)
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetWideIntFromObj})).f(tls, interp, tmp, bp+304) != TCL_OK {
				for ok10 := true; ok10; ok10 = 0 != 0 {
					var _objPtr uintptr = tmp
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
						(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
					}
				}
				return TCL_ERROR
			}
			for ok11 := true; ok11; ok11 = 0 != 0 {
				var _objPtr uintptr = tmp
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			uwideVar = Tcl_WideUInt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 304 /* w */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpdateLinkedVar})).f(tls, interp, ts+4034 /* "uwide" */)
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+176, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+4201, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

var intVar int32 = 43                                /* tclTest.c:2734:16 */
var boolVar int32 = 4                                /* tclTest.c:2735:16 */
var realVar float64 = 1.23                           /* tclTest.c:2736:19 */
var wideVar Tcl_WideInt = int64(79)                  /* tclTest.c:2737:24 */
var stringVar uintptr = uintptr(0)                   /* tclTest.c:2738:17 */
var charVar int8 = int8('@')                         /* tclTest.c:2739:17 */
var ucharVar uint8 = uint8(130)                      /* tclTest.c:2740:26 */
var shortVar int16 = int16(3000)                     /* tclTest.c:2741:18 */
var ushortVar uint16 = uint16(60000)                 /* tclTest.c:2742:27 */
var uintVar uint32 = 0xBEEFFEED                      /* tclTest.c:2743:25 */
var longVar int64 = 123456789                        /* tclTest.c:2744:17 */
var ulongVar uint64 = 3456789012                     /* tclTest.c:2745:26 */
var floatVar float32 = 4.5                           /* tclTest.c:2746:18 */
var uwideVar Tcl_WideUInt = Tcl_WideUInt(int64(123)) /* tclTest.c:2747:25 */
var created int32 = 0                                /* tclTest.c:2748:16 */

//----------------------------------------------------------------------
//
// TestlocaleCmd --
//
//	This procedure implements the "testlocale" command.  It is used
//	to test the effects of setting different locales in Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Modifies the current C locale.
//
//----------------------------------------------------------------------

func TestlocaleCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3196:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var index int32 at bp, 4

	var locale uintptr

	// LC_CTYPE, etc. correspond to the indices for the strings.

	if objc < 2 || objc > 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4250 /* "category ?locale..." */)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&optionStrings1)), int32(unsafe.Sizeof(uintptr(0))), ts+3235, 0, bp) != TCL_OK {
		return TCL_ERROR
	}

	if objc == 3 {
		locale = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	} else {
		locale = uintptr(0)
	}
	locale = libc.Xsetlocale(tls, lcTypes[*(*int32)(unsafe.Pointer(bp /* index */))], locale)
	if locale != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetStringObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), locale, -1)
	}
	return TCL_OK
}

var optionStrings1 = [7]uintptr{
	ts + 4268, ts + 4274, ts + 4282, ts + 4287, ts + 4295,
	ts + 4304, uintptr(0),
} /* tclTest.c:3205:23 */
var lcTypes = [6]int32{
	LC_CTYPE, LC_NUMERIC, LC_TIME, LC_COLLATE, LC_MONETARY,
	LC_ALL,
} /* tclTest.c:3209:22 */

//----------------------------------------------------------------------
//
// TestMathFunc --
//
//	This is a user-defined math procedure to test out math procedures
//	with no arguments.
//
// Results:
//	A normal Tcl completion code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestMathFunc(tls *libc.TLS, clientData ClientData, interp uintptr, args uintptr, resultPtr uintptr) int32 { /* tclTest.c:3258:1: */
	(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_INT
	(*Tcl_Value)(unsafe.Pointer(resultPtr)).intValue = int64(int32(clientData))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestMathFunc2 --
//
//	This is a user-defined math procedure to test out math procedures
//	that do have arguments, in this case 2.
//
// Results:
//	A normal Tcl completion code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestMathFunc2(tls *libc.TLS, clientData ClientData, interp uintptr, args uintptr, resultPtr uintptr) int32 { /* tclTest.c:3287:1: */
	var result int32 = TCL_OK

	// Return the maximum of the two arguments with the correct type.

	if (*Tcl_Value)(unsafe.Pointer(args)).__type == TCL_INT {
		var i0 int32 = int32((*Tcl_Value)(unsafe.Pointer(args)).intValue)

		if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_INT {
			var i1 int32 = int32((*Tcl_Value)(unsafe.Pointer(args + 1*32)).intValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).intValue = func() int64 {
				if i0 > i1 {
					return int64(i0)
				}
				return int64(i1)
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_DOUBLE {
			var d0 float64 = float64(i0)
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_WIDE_INT {
			var w0 Tcl_WideInt = int64(i0)
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).wideValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_WIDE_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}()
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4308 /* "T3: wrong type f..." */, uintptr(0))
			result = TCL_ERROR
		}
	} else if (*Tcl_Value)(unsafe.Pointer(args)).__type == TCL_DOUBLE {
		var d0 float64 = (*Tcl_Value)(unsafe.Pointer(args)).doubleValue

		if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_INT {
			var d1 float64 = float64((*Tcl_Value)(unsafe.Pointer(args + 1*32)).intValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_DOUBLE {
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_WIDE_INT {
			var d1 float64 = float64((*Tcl_Value)(unsafe.Pointer(args + 1*32)).wideValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4308 /* "T3: wrong type f..." */, uintptr(0))
			result = TCL_ERROR
		}
	} else if (*Tcl_Value)(unsafe.Pointer(args)).__type == TCL_WIDE_INT {
		var w0 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args)).wideValue

		if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_INT {
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).intValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_WIDE_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_DOUBLE {
			var d0 float64 = float64(w0)
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_DOUBLE
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}()
		} else if (*Tcl_Value)(unsafe.Pointer(args+1*32)).__type == TCL_WIDE_INT {
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + 1*32)).wideValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = TCL_WIDE_INT
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}()
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4308 /* "T3: wrong type f..." */, uintptr(0))
			result = TCL_ERROR
		}
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4333 /* "T3: wrong type f..." */, uintptr(0))
		result = TCL_ERROR
	}
	return result
}

//----------------------------------------------------------------------
//
// CleanupTestSetassocdataTests --
//
//	This function is called when an interpreter is deleted to clean
//	up any data left over from running the testsetassocdata command.
//
// Results:
//	None.
//
// Side effects:
//	Releases storage.
//
//----------------------------------------------------------------------
func CleanupTestSetassocdataTests(tls *libc.TLS, clientData ClientData, interp uintptr) { /* tclTest.c:3393:1: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, clientData)
}

//----------------------------------------------------------------------
//
// TestparserObjCmd --
//
//	This procedure implements the "testparser" command.  It is
//	used for testing the new Tcl script parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparserObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3418:1: */
	bp := tls.Alloc(584)
	defer tls.Free(584)

	var script uintptr
	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+8, 576

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4358 /* "script length" */)
		return TCL_ERROR
	}
	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &dummy */)
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseCommand})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4)), 0, bp+8) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4372 /* "\n    (remainder ..." */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+8 /* &parse */)).term)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4401 /* "\")" */)
		return TCL_ERROR
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	PrintParse(tls, interp, bp+8)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeParse})).f(tls, bp+8 /* &parse */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexprparserObjCmd --
//
//	This procedure implements the "testexprparser" command.  It is
//	used for testing the new Tcl expression parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprparserObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3474:1: */
	bp := tls.Alloc(584)
	defer tls.Free(584)

	var script uintptr
	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+8, 576

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4404 /* "expr length" */)
		return TCL_ERROR
	}
	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &dummy */)
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commentStart = uintptr(0)
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commentSize = 0
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commandStart = uintptr(0)
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commandSize = 0
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseExpr})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4)), bp+8) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4416 /* "\n    (remainder ..." */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+8 /* &parse */)).term)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4401 /* "\")" */)
		return TCL_ERROR
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	PrintParse(tls, interp, bp+8)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeParse})).f(tls, bp+8 /* &parse */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// PrintParse --
//
//	This procedure prints out the contents of a Tcl_Parse structure
//	in the result of an interpreter.
//
// Results:
//	Interp's result is set to a prettily formatted version of the
//	contents of parsePtr.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func PrintParse(tls *libc.TLS, interp uintptr, parsePtr uintptr) { /* tclTest.c:3535:1: */
	var objPtr uintptr
	var typeString uintptr
	var tokenPtr uintptr
	var i int32

	objPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)
	if (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentSize > 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentStart,
				(*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentSize))
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+2369 /* "-" */, 1))
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
		(*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandStart, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandSize))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
		(*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).numWords))
	for i = 0; i < (*Tcl_Parse)(unsafe.Pointer(parsePtr)).numTokens; i++ {
		tokenPtr = (*Tcl_Parse)(unsafe.Pointer(parsePtr)).tokenPtr + uintptr(i)*24
		switch (*Tcl_Token)(unsafe.Pointer(tokenPtr)).__type {
		case TCL_TOKEN_EXPAND_WORD:
			typeString = ts + 4443 /* "expand" */
			break
		case TCL_TOKEN_WORD:
			typeString = ts + 4450 /* "word" */
			break
		case TCL_TOKEN_SIMPLE_WORD:
			typeString = ts + 44 /* "simple" */
			break
		case TCL_TOKEN_TEXT:
			typeString = ts + 4455 /* "text" */
			break
		case TCL_TOKEN_BS:
			typeString = ts + 4460 /* "backslash" */
			break
		case TCL_TOKEN_COMMAND:
			typeString = ts + 4470 /* "command" */
			break
		case TCL_TOKEN_VARIABLE:
			typeString = ts + 4478 /* "variable" */
			break
		case TCL_TOKEN_SUB_EXPR:
			typeString = ts + 4487 /* "subexpr" */
			break
		case TCL_TOKEN_OPERATOR:
			typeString = ts + 4495 /* "operator" */
			break
		default:
			typeString = ts + 1413 /* "??" */
			break
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, typeString, -1))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).start, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).size))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
			(*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).numComponents))
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), objPtr,
		(*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandStart+uintptr((*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandSize),
			-1))
}

//----------------------------------------------------------------------
//
// TestparsevarObjCmd --
//
//	This procedure implements the "testparsevar" command.  It is
//	used for testing Tcl_ParseVar.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparsevarObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3621:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var value uintptr
	var name uintptr
	// var termPtr uintptr at bp, 8

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4504 /* "varName" */)
		return TCL_ERROR
	}
	name = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	value = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseVar})).f(tls, interp, name, bp /* &termPtr */)
	if value == uintptr(0) {
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp /* termPtr */)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestparsevarnameObjCmd --
//
//	This procedure implements the "testparsevarname" command.  It is
//	used for testing the new Tcl script parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparsevarnameObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3662:1: */
	bp := tls.Alloc(592)
	defer tls.Free(592)

	var script uintptr
	// var append int32 at bp+8, 4

	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+16, 576

	if objc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+4512 /* "script length ap..." */)
		return TCL_ERROR
	}
	script = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &dummy */)
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseVarName})).f(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4)), bp+16, *(*int32)(unsafe.Pointer(bp + 8))) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4372 /* "\n    (remainder ..." */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+16 /* &parse */)).term)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AddErrorInfo})).f(tls, interp, ts+4401 /* "\")" */)
		return TCL_ERROR
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commentSize = 0
	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commandStart = script + uintptr((*Tcl_Token)(unsafe.Pointer((*Tcl_Parse)(unsafe.Pointer(bp+16)).tokenPtr)).size)
	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commandSize = 0
	PrintParse(tls, interp, bp+16)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FreeParse})).f(tls, bp+16 /* &parse */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestregexpObjCmd --
//
//	This procedure implements the "testregexp" command. It is used to give
//	a direct interface for regexp flags. It's identical to
//	Tcl_RegexpObjCmd except for the -xflags option, and the consequences
//	thereof (including the REG_EXPECT kludge).
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	See the user documentation.
//
//----------------------------------------------------------------------

func TestregexpObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3726:1: */
	bp := tls.Alloc(264)
	defer tls.Free(264)

	var i int32
	var ii int32
	var indices int32
	// var stringLength int32 at bp+92, 4

	var match int32
	var about int32
	var hasxflags int32
	// var cflags int32 at bp+96, 4

	// var eflags int32 at bp+100, 4

	var regExpr Tcl_RegExp
	var string uintptr
	var objPtr uintptr
	// var info Tcl_RegExpInfo at bp+160, 32

	var name uintptr
	// var index int32 at bp+88, 4

	var varName uintptr
	var value uintptr
	// var start int32 at bp+104, 4

	// var end int32 at bp+108, 4

	// var resinfo [48]int8 at bp+112, 48

	var varName1 uintptr
	var value1 uintptr
	// var resinfo1 [48]int8 at bp+192, 48

	// var objs [2]uintptr at bp+248, 16

	// var start1 int32 at bp+240, 4

	// var end1 int32 at bp+244, 4

	var newPtr uintptr
	var varPtr uintptr
	var valuePtr uintptr

	indices = 0
	about = 0
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) = REG_ADVANCED
	*(*int32)(unsafe.Pointer(bp + 100 /* eflags */)) = 0
	hasxflags = 0

	i = 1
__1:
	if !(i < objc) {
		goto __3
	}

	name = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	if !(int32(*(*int8)(unsafe.Pointer(name))) != '-') {
		goto __4
	}
	goto __3
__4:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), uintptr(unsafe.Pointer(&options1)), int32(unsafe.Sizeof(uintptr(0))), ts+4533, TCL_EXACT, bp+88) != TCL_OK) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 88 /* index */))) {
	case uint32(0) /* REGEXP_INDICES */ :
		goto __7
	case uint32(1) /* REGEXP_NOCASE */ :
		goto __8
	case uint32(2) /* REGEXP_ABOUT */ :
		goto __9
	case uint32(3) /* REGEXP_EXPANDED */ :
		goto __10
	case uint32(4) /* REGEXP_MULTI */ :
		goto __11
	case uint32(5) /* REGEXP_NOCROSS */ :
		goto __12
	case uint32(6) /* REGEXP_NEWL */ :
		goto __13
	case uint32(7) /* REGEXP_XFLAGS */ :
		goto __14
	case uint32(8) /* REGEXP_LAST */ :
		goto __15
	}
	goto __6
__7:
	indices = 1
	goto __6
__8:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_ICASE
	goto __6
__9:
	about = 1
	goto __6
__10:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_EXPANDED
	goto __6
__11:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_NEWLINE
	goto __6
__12:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_NLSTOP
	goto __6
__13:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= REG_NLANCH
	goto __6
__14:
	hasxflags = 1
	goto __6
__15:
	i++
	goto endOfForLoop
__6:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;

endOfForLoop:
	if !(objc-i < hasxflags+2-about) {
		goto __16
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv,
		ts+4540)
	return TCL_ERROR
__16:
	;
	objc = objc - i
	objv += 8 * uintptr(i)

	if !(hasxflags != 0) {
		goto __17
	}
	string = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv)), bp+92 /* &stringLength */)
	TestregexpXflags(tls, string, *(*int32)(unsafe.Pointer(bp + 92 /* stringLength */)), bp+96, bp+100)
	objc--
	objv += 8
__17:
	;

	regExpr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) Tcl_RegExp
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetRegExpFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv)), *(*int32)(unsafe.Pointer(bp + 96 /* cflags */)))
	if !(regExpr == uintptr(0)) {
		goto __18
	}
	return TCL_ERROR
__18:
	;

	if !(about != 0) {
		goto __19
	}
	if !((*struct {
		f func(*libc.TLS, uintptr, Tcl_RegExp) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegAbout})).f(tls, interp, regExpr) < 0) {
		goto __20
	}
	return TCL_ERROR
__20:
	;
	return TCL_OK
__19:
	;

	objPtr = *(*uintptr)(unsafe.Pointer(objv + 1*8))
	match = (*struct {
		f func(*libc.TLS, uintptr, Tcl_RegExp, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegExpExecObj})).f(tls, interp, regExpr, objPtr, 0,
		objc-2, *(*int32)(unsafe.Pointer(bp + 100 /* eflags */)))

	if !(match < 0) {
		goto __21
	}
	return TCL_ERROR
__21:
	;
	if !(match == 0) {
		goto __22
	}
	// Set the interpreter's object result to an integer object w/
	// value 0.

	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), 0)
	if !(objc > 2 && *(*int32)(unsafe.Pointer(bp + 96))&REG_EXPECT != 0 && indices != 0) {
		goto __23
	}

	varName = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	(*struct {
		f func(*libc.TLS, Tcl_RegExp, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegExpRangeUniChar})).f(tls, regExpr, -1, bp+104 /* &start */, bp+108 /* &end */)
	libc.Xsprintf(tls, bp+112, ts+4594, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 104 /* start */)), *(*int32)(unsafe.Pointer(bp + 108))-1))
	value = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, varName, uintptr(0), bp+112 /* &resinfo[0] */, 0)
	if !(value == uintptr(0)) {
		goto __25
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+4600, /* "couldn't set var..." */
		varName, ts+1678, uintptr(0)))
	return TCL_ERROR
__25:
	;
	goto __24
__23:
	if !(*(*int32)(unsafe.Pointer(bp + 96))&TCL_REG_CANMATCH != 0) {
		goto __26
	}

	(*struct {
		f func(*libc.TLS, Tcl_RegExp, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegExpGetInfo})).f(tls, regExpr, bp+160 /* &info */)
	varName1 = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	libc.Xsprintf(tls, bp+192, ts+4624, libc.VaList(bp+48, (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).extendStart))
	value1 = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, varName1, uintptr(0), bp+192 /* &resinfo1[0] */, 0)
	if !(value1 == uintptr(0)) {
		goto __27
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+56, ts+4600, /* "couldn't set var..." */
		varName1, ts+1678, uintptr(0)))
	return TCL_ERROR
__27:
	;
__26:
	;
__24:
	;
	return TCL_OK
__22:
	;

	// If additional variable names have been specified, return
	// index information in those variables.

	objc = objc - 2
	objv += 8 * uintptr(2)

	(*struct {
		f func(*libc.TLS, Tcl_RegExp, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegExpGetInfo})).f(tls, regExpr, bp+160 /* &info */)
	i = 0
__28:
	if !(i < objc) {
		goto __30
	}

	varPtr = *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))
	if *(*int32)(unsafe.Pointer(bp + 96))&REG_EXPECT != 0 && i == objc-1 {
		ii = -1
	} else {
		ii = i
	}
	if !(indices != 0) {
		goto __31
	}

	if !(ii == -1) {
		goto __33
	}
	(*struct {
		f func(*libc.TLS, Tcl_RegExp, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegExpRangeUniChar})).f(tls, regExpr, ii, bp+240 /* &start1 */, bp+244 /* &end1 */)
	goto __34
__33:
	if !(ii > (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160)).nsubs) {
		goto __35
	}
	*(*int32)(unsafe.Pointer(bp + 240 /* start1 */)) = -1
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) = -1
	goto __36
__35:
	*(*int32)(unsafe.Pointer(bp + 240 /* start1 */)) = int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches + uintptr(ii)*16)).start)
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) = int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches + uintptr(ii)*16)).end)
__36:
	;
__34:
	;

	// Adjust index so it refers to the last character in the match
	// instead of the first character after the match.

	if !(*(*int32)(unsafe.Pointer(bp + 244)) >= 0) {
		goto __37
	}
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */))--
__37:
	;

	*(*uintptr)(unsafe.Pointer(bp + 248)) = (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(*(*int32)(unsafe.Pointer(bp + 240 /* start1 */))))
	*(*uintptr)(unsafe.Pointer(bp + 248 + 1*8)) = (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(*(*int32)(unsafe.Pointer(bp + 244 /* end1 */))))

	newPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 2, bp+248 /* &objs[0] */)
	goto __32
__31:
	if !(ii == -1) {
		goto __38
	}
	(*struct {
		f func(*libc.TLS, Tcl_RegExp, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclRegExpRangeUniChar})).f(tls, regExpr, ii, bp+240 /* &start1 */, bp+244 /* &end1 */)
	newPtr = (*struct {
		f func(*libc.TLS, uintptr, int32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetRange})).f(tls, objPtr, *(*int32)(unsafe.Pointer(bp + 240 /* start1 */)), *(*int32)(unsafe.Pointer(bp + 244 /* end1 */)))
	goto __39
__38:
	if !(ii > (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160)).nsubs) {
		goto __40
	}
	newPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	goto __41
__40:
	newPtr = (*struct {
		f func(*libc.TLS, uintptr, int32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetRange})).f(tls, objPtr, int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches+uintptr(ii)*16)).start),
		int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160)).matches+uintptr(ii)*16)).end-int64(1)))
__41:
	;
__39:
	;
__32:
	;
	valuePtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ObjSetVar2})).f(tls, interp, varPtr, uintptr(0), newPtr, TCL_LEAVE_ERR_MSG)
	if !(valuePtr == uintptr(0)) {
		goto __42
	}
	return TCL_ERROR
__42:
	;
	goto __29
__29:
	i++
	goto __28
	goto __30
__30:
	;

	// Set the interpreter's object result to an integer object w/ value 1.

	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), 1)
	return TCL_OK
}

var options1 = [10]uintptr{
	ts + 4628, ts + 4637, ts + 4645, ts + 4652,
	ts + 4662, ts + 4668, ts + 4678,
	ts + 4690,
	ts + 4698, uintptr(0),
} /* tclTest.c:3738:23 */

//---------------------------------------------------------------------------
//
// TestregexpXflags --
//
//	Parse a string of extended regexp flag letters, for testing.
//
// Results:
//	No return value (you're on your own for errors here).
//
// Side effects:
//	Modifies *cflagsPtr, a regcomp flags word, and *eflagsPtr, a
//	regexec flags word, as appropriate.
//
//----------------------------------------------------------------------

func TestregexpXflags(tls *libc.TLS, string uintptr, length int32, cflagsPtr uintptr, eflagsPtr uintptr) { /* tclTest.c:3959:1: */
	var i int32
	var cflags int32
	var eflags int32

	cflags = *(*int32)(unsafe.Pointer(cflagsPtr))
	eflags = *(*int32)(unsafe.Pointer(eflagsPtr))
	for i = 0; i < length; i++ {
		switch int32(*(*int8)(unsafe.Pointer(string + uintptr(i)))) {
		case 'a':
			cflags = cflags | REG_ADVF
			break
		case 'b':
			cflags = cflags & libc.CplInt32(REG_ADVANCED)
			break
		case 'c':
			cflags = cflags | TCL_REG_CANMATCH
			break
		case 'e':
			cflags = cflags & libc.CplInt32(REG_ADVANCED)
			cflags = cflags | REG_EXTENDED
			break
		case 'q':
			cflags = cflags & libc.CplInt32(REG_ADVANCED)
			cflags = cflags | REG_QUOTE
			break
		case 'o': // o for opaque
			cflags = cflags | REG_NOSUB
			break
		case 's': // s for start
			cflags = cflags | REG_BOSONLY
			break
		case '+':
			cflags = cflags | REG_FAKE
			break
		case ',':
			cflags = cflags | REG_PROGRESS
			break
		case '.':
			cflags = cflags | REG_DUMP
			break
		case ':':
			eflags = eflags | REG_MTRACE
			break
		case ';':
			eflags = eflags | REG_FTRACE
			break
		case '^':
			eflags = eflags | REG_NOTBOL
			break
		case '$':
			eflags = eflags | REG_NOTEOL
			break
		case 't':
			cflags = cflags | REG_EXPECT
			break
		case '%':
			eflags = eflags | REG_SMALL
			break
		}
	}

	*(*int32)(unsafe.Pointer(cflagsPtr)) = cflags
	*(*int32)(unsafe.Pointer(eflagsPtr)) = eflags
}

//----------------------------------------------------------------------
//
// TestreturnObjCmd --
//
//	This procedure implements the "testreturn" command. It is
//	used to verify that a
//		return TCL_RETURN;
//	has same behavior as
//		return Tcl_SetReturnOptions(interp, Tcl_NewObj());
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	See the user documentation.
//
//----------------------------------------------------------------------

func TestreturnObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4049:1: */
	return TCL_RETURN
}

//----------------------------------------------------------------------
//
// TestsetassocdataCmd --
//
//	This procedure implements the "testsetassocdata" command. It is used
//	to test Tcl_SetAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Modifies or creates an association between a key and associated
//	data for this interpreter.
//
//----------------------------------------------------------------------

func TestsetassocdataCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4077:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var buf uintptr
	var oldData uintptr
	// var procPtr uintptr at bp+32, 8

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+4701, uintptr(0)))
		return TCL_ERROR
	}

	buf = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))+uint64(1)))
	libc.Xstrcpy(tls, buf, *(*uintptr)(unsafe.Pointer(argv + 2*8)))

	// If we previously associated a malloced value with the variable,
	// free it before associating a new value.

	oldData = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32 /* &procPtr */)
	if oldData != uintptr(0) && *(*uintptr)(unsafe.Pointer(bp + 32)) == *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr)
	}{CleanupTestSetassocdataTests})) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, oldData)
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetAssocData})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr)
	}{CleanupTestSetassocdataTests})),
		buf)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestsetplatformCmd --
//
//	This procedure implements the "testsetplatform" command. It is
//	used to change the tclPlatform global variable so all file
//	name conversions can be tested on a single platform.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Sets the tclPlatform global variable.
//
//----------------------------------------------------------------------

func TestsetplatformCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4129:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var length size_t
	var platform uintptr

	platform = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetPlatform})).f(tls)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+4722, uintptr(0)))
		return TCL_ERROR
	}

	length = libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3769, length) == 0 {
		*(*TclPlatformType)(unsafe.Pointer(platform)) = TCL_PLATFORM_UNIX
	} else if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+3778, length) == 0 {
		*(*TclPlatformType)(unsafe.Pointer(platform)) = TCL_PLATFORM_WINDOWS
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+32, ts+4733, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TeststaticpkgCmd --
//
//	This procedure implements the "teststaticpkg" command.
//	It is used to test the procedure Tcl_StaticPackage.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	When the packge given by argv[1] is loaded into an interpeter,
//	variable "x" in that interpreter is set to "loaded".
//
//----------------------------------------------------------------------

func TeststaticpkgCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4178:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var safe int32 at bp+32, 4

	// var loaded int32 at bp+36, 4

	if argc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+4789, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+32) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+36) != TCL_OK {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_StaticPackage})).f(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 36)) != 0 {
			return interp
		}
		return uintptr(0)
	}(), *(*uintptr)(unsafe.Pointer(argv + 1*8)),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{StaticInitProc})), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 32)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr) int32
				}{StaticInitProc}))
			}
			return uintptr(0)
		}())
	return TCL_OK
}

func StaticInitProc(tls *libc.TLS, interp uintptr) int32 { /* tclTest.c:4203:1: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, ts+4810 /* "x" */, uintptr(0), ts+4812 /* "loaded" */, TCL_GLOBAL_ONLY)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TesttranslatefilenameCmd --
//
//	This procedure implements the "testtranslatefilename" command.
//	It is used to test the Tcl_TranslateFileName command.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TesttranslatefilenameCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4229:1: */
	bp := tls.Alloc(264)
	defer tls.Free(264)

	// var buffer Tcl_DString at bp+48, 216

	var result uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+3786, uintptr(0)))
		return TCL_ERROR
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_TranslateFileName})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48 /* &buffer */)
	if result == uintptr(0) {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, result, uintptr(0)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+48 /* &buffer */)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestupvarCmd --
//
//	This procedure implements the "testupvar" command.  It is used
//	to test Tcl_UpVar and Tcl_UpVar2.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates or modifies an "upvar" reference.
//
//----------------------------------------------------------------------

func TestupvarCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4270:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = 0

	if argc != 5 && argc != 6 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+4819, uintptr(0)))
		return TCL_ERROR
	}

	if argc == 5 {
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+3242) == 0 {
			flags = TCL_GLOBAL_ONLY
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+4852) == 0 {
			flags = TCL_NAMESPACE_ONLY
		}
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0), *(*uintptr)(unsafe.Pointer(argv + 3*8)), flags)
	} else {
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+3242) == 0 {
			flags = TCL_GLOBAL_ONLY
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)), ts+4852) == 0 {
			flags = TCL_NAMESPACE_ONLY
		}
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UpVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)),
			func() uintptr {
				if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 3*8))))) == 0 {
					return uintptr(0)
				}
				return *(*uintptr)(unsafe.Pointer(argv + 3*8))
			}(), *(*uintptr)(unsafe.Pointer(argv + 4*8)),
			flags)
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestseterrorcodeCmd --
//
//	This procedure implements the "testseterrorcodeCmd".  This tests up to
//	five elements passed to the Tcl_SetErrorCode command.
//
// Results:
//	A standard Tcl result. Always returns TCL_ERROR so that
//	the error code can be tested.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestseterrorcodeCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4322:1: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	if argc > 6 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+4862 /* "too many args" */, uintptr(0))
		return TCL_ERROR
	}
	switch argc {
	case 1:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp, ts+4876 /* "NONE" */, uintptr(0)))
		break
	case 2:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0)))
		break
	case 3:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0)))
		break
	case 4:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), uintptr(0)))
		break
	case 5:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+88, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), *(*uintptr)(unsafe.Pointer(argv + 4*8)), uintptr(0)))
		break
	case 6:
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetErrorCode})).f(tls, interp, libc.VaList(bp+128, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), *(*uintptr)(unsafe.Pointer(argv + 4*8)),
			*(*uintptr)(unsafe.Pointer(argv + 5*8)), uintptr(0)))
	}
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestsetobjerrorcodeCmd --
//
//	This procedure implements the "testsetobjerrorcodeCmd".
//	This tests the Tcl_SetObjErrorCode function.
//
// Results:
//	A standard Tcl result. Always returns TCL_ERROR so that
//	the error code can be tested.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetobjerrorcodeCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4374:1: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjErrorCode})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, objc-1, objv+uintptr(1)*8))
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestfeventCmd --
//
//	This procedure implements the "testfevent" command.  It is
//	used for testing the "fileevent" command.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes interpreters.
//
//----------------------------------------------------------------------

func TestfeventCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4402:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var code int32
	var chan1 Tcl_Channel

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+4881, uintptr(0)))
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4899) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+4903, uintptr(0)))
			return TCL_ERROR
		}
		if interp2 != uintptr(0) {
			code = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp2, *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, TCL_EVAL_GLOBAL)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp2))
			return code
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
				libc.VaList(bp+64, ts+4915,
					uintptr(0)))
			return TCL_ERROR
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0 {
		if interp2 != uintptr(0) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, interp2)
		}
		interp2 = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateInterp})).f(tls)
		return (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Init})).f(tls, interp2)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1291) == 0 {
		if interp2 != uintptr(0) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteInterp})).f(tls, interp2)
		}
		interp2 = uintptr(0)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4967) == 0 {
		if interp2 != uintptr(0) {
			chan1 = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0))
			if chan1 == uintptr(0) {
				return TCL_ERROR
			}
			(*struct {
				f func(*libc.TLS, uintptr, Tcl_Channel)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegisterChannel})).f(tls, interp2, chan1)
		}
	}

	return TCL_OK
}

var interp2 uintptr = uintptr(0) /* tclTest.c:4408:23 */

//----------------------------------------------------------------------
//
// TestpanicCmd --
//
//	Calls the panic routine.
//
// Results:
//	Always returns TCL_OK.
//
// Side effects:
//	May exit application.
//
//----------------------------------------------------------------------

func TestpanicCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4474:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var argString uintptr

	//  Put the arguments into a var args structure
	//  Append all of the arguments together separated by spaces

	argString = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Merge})).f(tls, argc-1, argv+uintptr(1)*8)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+4973 /* "%s" */, libc.VaList(bp, argString))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, argString)

	return TCL_OK
}

func TestfileCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4495:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var force int32
	var i int32
	var j int32
	var result int32
	// var error uintptr at bp+40, 8

	var subcmd uintptr
	var _objPtr uintptr
	*(*uintptr)(unsafe.Pointer(bp + 40 /* error */)) = uintptr(0)

	if !(argc < 3) {
		goto __1
	}
	return TCL_ERROR
__1:
	;

	force = 0
	i = 2
	if !(libc.Xstrcmp(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))), ts+4976) == 0) {
		goto __2
	}
	force = 1
	i = 3
__2:
	;

	if !(argc-i > 2) {
		goto __3
	}
	return TCL_ERROR
__3:
	;

	j = i
__4:
	if !(j < argc) {
		goto __6
	}
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSGetNormalizedPath})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(j)*8))) == uintptr(0)) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	goto __5
__5:
	j++
	goto __4
	goto __6
__6:
	;

	subcmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))

	if !(libc.Xstrcmp(tls, subcmd, ts+4983) == 0) {
		goto __8
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjRenameFile})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(i+1)*8)))
	goto __9
__8:
	if !(libc.Xstrcmp(tls, subcmd, ts+4986) == 0) {
		goto __10
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjCopyFile})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(i+1)*8)))
	goto __11
__10:
	if !(libc.Xstrcmp(tls, subcmd, ts+4989) == 0) {
		goto __12
	}
	result = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjDeleteFile})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	goto __13
__12:
	if !(libc.Xstrcmp(tls, subcmd, ts+4992) == 0) {
		goto __14
	}
	result = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjCreateDirectory})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	goto __15
__14:
	if !(libc.Xstrcmp(tls, subcmd, ts+4998) == 0) {
		goto __16
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjCopyDirectory})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(i+1)*8)), bp+40 /* &error */)
	goto __17
__16:
	if !(libc.Xstrcmp(tls, subcmd, ts+5004) == 0) {
		goto __18
	}
	result = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpObjRemoveDirectory})).f(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), force, bp+40 /* &error */)
	goto __19
__18:
	result = TCL_ERROR
	goto end
__19:
	;
__17:
	;
__15:
	;
__13:
	;
__11:
	;
__9:
	;

	if !(result != TCL_OK) {
		goto __20
	}
	if !(*(*uintptr)(unsafe.Pointer(bp + 40)) != uintptr(0)) {
		goto __21
	}
	if !(int32(*(*int8)(unsafe.Pointer((*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 40)))))) != 0) {
		goto __22
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* error */))), ts+1425 /* " " */, uintptr(0)))
__22:
	;
__23:
	_objPtr = *(*uintptr)(unsafe.Pointer(bp + 40))
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1) {
		goto __26
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
__26:
	;
	goto __24
__24:
	if 0 != 0 {
		goto __23
	}
	goto __25
__25:
	;
__21:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+24, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ErrnoId})).f(tls), uintptr(0)))
__20:
	;

end:
	return result
}

//----------------------------------------------------------------------
//
// TestgetvarfullnameCmd --
//
//	Implements the "testgetvarfullname" cmd that is used when testing
//	the Tcl_GetVariableFullName procedure.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetvarfullnameCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4577:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var name uintptr
	var arg uintptr
	var flags int32 = 0
	var namespacePtr uintptr
	// var framePtr uintptr at bp, 8

	var variable Tcl_Var

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5010 /* "name scope" */)
		return TCL_ERROR
	}

	name = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))

	arg = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if libc.Xstrcmp(tls, arg, ts+3242) == 0 {
		flags = TCL_GLOBAL_ONLY
	} else if libc.Xstrcmp(tls, arg, ts+4852) == 0 {
		flags = TCL_NAMESPACE_ONLY
	}

	// This command, like any other created with Tcl_Create[Obj]Command, runs
	// in the global namespace. As a "namespace-aware" command that needs to
	// run in a particular namespace, it must activate that namespace itself.

	if flags == TCL_NAMESPACE_ONLY {
		namespacePtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindNamespace})).f(tls, interp, ts+5021 /* "::test_ns_var" */, uintptr(0),
			TCL_LEAVE_ERR_MSG)
		if namespacePtr == uintptr(0) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclPushStackFrame})).f(tls, interp, bp /* &framePtr */, namespacePtr,
			/*isProcCallFrame*/ 0)
	}

	variable = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Var
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindNamespaceVar})).f(tls, interp, name, uintptr(0),
		flags|TCL_LEAVE_ERR_MSG)

	if flags == TCL_NAMESPACE_ONLY {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclPopStackFrame})).f(tls, interp)
	}
	if variable == uintptr(0) {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, Tcl_Var, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_GetVariableFullName})).f(tls, interp, variable, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// GetTimesObjCmd --
//
//	This procedure implements the "gettimes" command.  It is used for
//	computing the time needed for various basic operations such as reading
//	variables, allocating memory, sprintf, converting variables, etc.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Allocates and frees memory, sets a variable "a" in the interpreter.
//
//----------------------------------------------------------------------

func GetTimesObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, dummy uintptr) int32 { /* tclTest.c:4651:1: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var iPtr uintptr = interp
	var i int32
	// var n int32 at bp+136, 4

	var timePer float64
	// var start Tcl_Time at bp+104, 16

	// var stop Tcl_Time at bp+120, 16

	var objPtr uintptr
	var objv uintptr
	var s uintptr
	// var newString [24]int8 at bp+140, 24

	_ = objc
	_ = dummy

	// alloc & free 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5035, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		objPtr = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(Tcl_Obj{})))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, objPtr)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5069, libc.VaList(bp, timePer/float64(100000)))

	// alloc 5000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5098, 0)
	objv = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(uint64(5000)*uint64(unsafe.Sizeof(uintptr(0)))))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		*(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)) = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(Tcl_Obj{})))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5123, libc.VaList(bp+8, timePer/float64(5000)))

	// free 5000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5147, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5171, libc.VaList(bp+16, timePer/float64(5000)))

	// Tcl_NewObj 5000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5194, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		*(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)) = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5217, libc.VaList(bp+24, timePer/float64(5000)))

	// Tcl_DecrRefCount 5000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5246, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		objPtr = *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = objPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5275, libc.VaList(bp+32, timePer/float64(5000)))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, objv)

	// TclGetString 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5310, 0)
	objPtr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+5355 /* "12345" */, -1)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if !((*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes != 0) {
			(*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, objPtr)
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5361,
		libc.VaList(bp+40, timePer/float64(100000)))

	// Tcl_GetIntFromObj 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5410, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, objPtr, bp+136) != TCL_OK {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5453,
		libc.VaList(bp+48, timePer/float64(100000)))
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = objPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	// Tcl_GetInt 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5500, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, ts+5355, bp+136) != TCL_OK {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5536,
		libc.VaList(bp+56, timePer/float64(100000)))

	// sprintf 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5576, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		libc.Xsprintf(tls, bp+140, ts+5607, libc.VaList(bp+64, 12345))
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5610,
		libc.VaList(bp+72, timePer/float64(100000)))

	// hashtable lookup 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5645, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 160 /* &.cmdTable */)).findProc})).f(tls, (*Interp)(unsafe.Pointer(iPtr)).globalNsPtr+160 /* &.cmdTable */, ts+68 /* "gettimes" */)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5690,
		libc.VaList(bp+80, timePer/float64(100000)))

	// Tcl_SetVar 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5739, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		s = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, ts+5775 /* "a" */, uintptr(0), ts+5355 /* "12345" */, TCL_LEAVE_ERR_MSG)
		if s == uintptr(0) {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5777,
		libc.VaList(bp+88, timePer/float64(100000)))

	// Tcl_GetVar 100000 times
	libc.Xfprintf(tls, libc.X__stderrp, ts+5822, 0)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		s = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, ts+5775 /* "a" */, uintptr(0), TCL_LEAVE_ERR_MSG)
		if s == uintptr(0) {
			return TCL_ERROR
		}
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetTime})).f(tls, bp+120 /* &stop */)
	timePer = float64(((*Tcl_Time)(unsafe.Pointer(bp+120)).sec-(*Tcl_Time)(unsafe.Pointer(bp+104)).sec)*int64(1000000) + ((*Tcl_Time)(unsafe.Pointer(bp+120)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104)).usec))
	libc.Xfprintf(tls, libc.X__stderrp, ts+5861,
		libc.VaList(bp+96, timePer/float64(100000)))

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// NoopCmd --
//
//	This procedure is just used to time the overhead involved in
//	parsing and invoking a command.
//
// Results:
//	None.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func NoopCmd(tls *libc.TLS, unused ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4832:1: */
	return TCL_OK
}

//----------------------------------------------------------------------
//
// NoopObjCmd --
//
//	This object-based procedure is just used to time the overhead
//	involved in parsing and invoking a command.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func NoopObjCmd(tls *libc.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4859:1: */
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TeststringbytesObjCmd --
//	Returns bytearray value of the bytes in argument string rep
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TeststringbytesObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4884:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var n int32 at bp, 4

	var p uintptr
	_ = dummy

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5904 /* "value" */)
		return TCL_ERROR
	}
	p = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &n */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewByteArrayObj})).f(tls, p, *(*int32)(unsafe.Pointer(bp /* n */))))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestpurebytesobjObjCmd --
//
//	This object-based procedure constructs a pure bytes object
//	without type and with internal representation containing NULL's.
//
//	If no argument supplied it returns empty object with tclEmptyStringRep,
//	otherwise it returns this as pure bytes object with bytes value equal
//	string.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestpurebytesobjObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4925:1: */
	var objPtr uintptr
	_ = dummy

	if objc > 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5910 /* "?string?" */)
		return TCL_ERROR
	}
	objPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	//
	//     objPtr->internalRep.twoPtrValue.ptr1 = NULL;
	//     objPtr->internalRep.twoPtrValue.ptr2 = NULL;
	//
	libc.Xmemset(tls, objPtr+32, 0, uint64(unsafe.Sizeof(struct {
		longValue int64
		_         [8]byte
	}{})))
	if objc == 2 {
		var s uintptr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).length = (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)))).length
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32((*Tcl_Obj)(unsafe.Pointer(objPtr)).length+1))
		libc.Xmemcpy(tls, (*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes, s, uint64((*Tcl_Obj)(unsafe.Pointer(objPtr)).length))
		*(*int8)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes + uintptr((*Tcl_Obj)(unsafe.Pointer(objPtr)).length))) = int8(0)
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, objPtr)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestsetbytearraylengthObjCmd --
//
//	Testing command 'testsetbytearraylength` used to test the public
//	interface routine Tcl_SetByteArrayLength().
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetbytearraylengthObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4973:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var n int32 at bp, 4

	var obj uintptr = uintptr(0)
	_ = dummy

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5919 /* "value length" */)
		return TCL_ERROR
	}
	if TCL_OK != (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) {
		return TCL_ERROR
	}
	if (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)))).refCount > 1 {
		obj = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	} else {
		obj = *(*uintptr)(unsafe.Pointer(objv + 1*8))
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetByteArrayLength})).f(tls, obj, *(*int32)(unsafe.Pointer(bp /* n */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, obj)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestbytestringObjCmd --
//
//	This object-based procedure constructs a string which can
//	possibly contain invalid UTF-8 bytes.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestbytestringObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5018:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* n */)) = 0
	var p uintptr
	_ = dummy

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+5932 /* "bytearray" */)
		return TCL_ERROR
	}

	p = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetByteArrayFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &n */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, p, *(*int32)(unsafe.Pointer(bp /* n */))))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestsetCmd --
//
//	Implements the "testset{err,noerr}" cmds that are used when testing
//	Tcl_Set/GetVar C Api with/without TCL_LEAVE_ERR_MSG flag
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//     Variables may be set.
//
//----------------------------------------------------------------------

func TestsetCmd(tls *libc.TLS, data ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5056:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = int32(data)
	var value uintptr

	if argc == 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5942 /* "before get" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0), flags)
		if value == uintptr(0) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else if argc == 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5953 /* "before set" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0), *(*uintptr)(unsafe.Pointer(argv + 2*8)), flags)
		if value == uintptr(0) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357, /* "wrong # args: sh..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+5964, uintptr(0)))
		return TCL_ERROR
	}
	return int32(0)
}

func Testset2Cmd(tls *libc.TLS, data ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5088:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = int32(data)
	var value uintptr

	if argc == 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5942 /* "before get" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), flags)
		if value == uintptr(0) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else if argc == 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+5953 /* "before set" */, uintptr(0))
		value = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetVar2})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), flags)
		if value == uintptr(0) {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, value)
		return TCL_OK
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357, /* "wrong # args: sh..." */
			*(*uintptr)(unsafe.Pointer(argv)), ts+5985, uintptr(0)))
		return TCL_ERROR
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestsaveresultCmd --
//
//	Implements the "testsaveresult" cmd that is used when testing the
//	Tcl_SaveResult, Tcl_RestoreResult, and Tcl_DiscardResult interfaces.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsaveresultCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5138:1: */
	bp := tls.Alloc(272)
	defer tls.Free(272)

	var iPtr uintptr = interp
	// var discard int32 at bp+20, 4

	var result int32
	// var index int32 at bp+16, 4

	// var state Tcl_SavedResult at bp+24, 248

	var objPtr uintptr

	// Parse arguments

	if objc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+6015 /* "type script disc..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&optionStrings2)), int32(unsafe.Sizeof(uintptr(0))), ts+3235, 0, bp+16) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+20) != TCL_OK {
		return TCL_ERROR
	}

	objPtr = uintptr(0) // Lint.
	switch uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))) {
	case uint32(4) /* RESULT_SMALL */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+6035 /* "small result" */, uintptr(1))
		break
	case uint32(0) /* RESULT_APPEND */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+6048 /* "append result" */, uintptr(0)))
		break
	case uint32(2) /* RESULT_FREE */ :
		{
			var buf uintptr = (*struct {
				f func(*libc.TLS, uint32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(200))

			libc.Xstrcpy(tls, buf, ts+6062)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, buf, uintptr(3))
			break

		}
	case uint32(1) /* RESULT_DYNAMIC */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+6074 /* "dynamic result" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{TestsaveresultFree})))
		break
	case uint32(3) /* RESULT_OBJECT */ :
		objPtr = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+6089 /* "object result" */, -1)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, objPtr)
		break
	}

	freeCount = 0
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SaveResult})).f(tls, interp, bp+24 /* &state */)

	if int32(uint32(*(*int32)(unsafe.Pointer(bp + 16)))) == 3 {
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalObjEx})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), 0)
	} else {
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
	}

	if *(*int32)(unsafe.Pointer(bp + 20)) != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DiscardResult})).f(tls, bp+24 /* &state */)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RestoreResult})).f(tls, interp, bp+24 /* &state */)
		result = TCL_OK
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))) {
	case uint32(1) /* RESULT_DYNAMIC */ :
		{
			var present int32 = libc.Bool32((*Interp)(unsafe.Pointer(iPtr)).freeProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{TestsaveresultFree})))
			var called int32 = freeCount

			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
				if called != 0 {
					return ts + 6103 /* "called" */
				}
				return ts + 6110 /* "notCalled" */
			}())
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
				if present != 0 {
					return ts + 6120 /* "present" */
				}
				return ts + 6128 /* "missing" */
			}())
			break

		}
	case uint32(3) /* RESULT_OBJECT */ :
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
			if (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp) == objPtr {
				return ts + 6136 /* "same" */
			}
			return ts + 6141 /* "different" */
		}())
		break
	default:
		break
	}
	return result
}

var optionStrings2 = [6]uintptr{
	ts + 2393, ts + 6151, ts + 2412, ts + 6159, ts + 6166, uintptr(0),
} /* tclTest.c:5148:23 */

//----------------------------------------------------------------------
//
// TestsaveresultFree --
//
//	Special purpose freeProc used by TestsaveresultCmd.
//
// Results:
//	None.
//
// Side effects:
//	Increments the freeCount.
//
//----------------------------------------------------------------------

func TestsaveresultFree(tls *libc.TLS, blockPtr uintptr) { /* tclTest.c:5247:1: */
	freeCount++
}

//----------------------------------------------------------------------
//
// TestmainthreadCmd  --
//
//	Implements the "testmainthread" cmd that is used to test the
//	'Tcl_GetCurrentThread' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestmainthreadCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5271:1: */
	if argc == 1 {
		var idObj uintptr = (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls, Tcl_WideInt((*struct{ f func(*libc.TLS) Tcl_ThreadId })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCurrentThread})).f(tls)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, idObj)
		return TCL_OK
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1271 /* "wrong # args" */, uintptr(0))
		return TCL_ERROR
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// MainLoop --
//
//	A main loop set by TestsetmainloopCmd below.
//
// Results:
//	None.
//
// Side effects:
//	Event handlers could do anything.
//
//----------------------------------------------------------------------

func MainLoop(tls *libc.TLS) { /* tclTest.c:5305:1: */
	for !(exitMainLoop != 0) {
		(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, 0)
	}
	libc.Xfprintf(tls, libc.X__stdoutp, ts+6172, 0)
	libc.Xfflush(tls, libc.X__stdoutp)
}

//----------------------------------------------------------------------
//
// TestsetmainloopCmd  --
//
//	Implements the "testsetmainloop" cmd that is used to test the
//	'Tcl_SetMainLoop' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetmainloopCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5332:1: */
	exitMainLoop = 0
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetMainLoop})).f(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{MainLoop})))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestexitmainloopCmd  --
//
//	Implements the "testexitmainloop" cmd that is used to test the
//	'Tcl_SetMainLoop' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexitmainloopCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5361:1: */
	exitMainLoop = 1
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestChannelCmd --
//
//	Implements the Tcl "testchannel" debugging command and its
//	subcommands. This is part of the testing environment.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestChannelCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5389:1: */
	bp := tls.Alloc(632)
	defer tls.Free(632)

	var cmdName uintptr // Sub command.
	var hTblPtr uintptr // Hash table of channels.
	// var hSearch Tcl_HashSearch at bp+608, 24
	// Search variable.
	var hPtr uintptr      // Search variable.
	var chanPtr uintptr   // The actual channel.
	var statePtr uintptr  // state info for channel
	var chan1 Tcl_Channel // The opaque type.
	var len size_t        // Length of subcommand string.
	var IOQueued int32    // How much IO is queued inside channel?
	// var buf [24]int8 at bp+584, 24
	// For sprintf.
	// var mode int32 at bp+560, 4
	// rw mode of the channel

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+6187, uintptr(0)))
		return TCL_ERROR
	}
	cmdName = *(*uintptr)(unsafe.Pointer(argv + 1*8))
	len = libc.Xstrlen(tls, cmdName)

	chanPtr = uintptr(0)

	if argc > 2 {
		if int32(*(*int8)(unsafe.Pointer(cmdName))) == 's' && libc.Xstrncmp(tls, cmdName, ts+6220, len) == 0 {
			// For splice access the pool of detached channels.
			// Locate channel, remove from the list.

			var nextPtrPtr uintptr
			var curPtr uintptr

			chan1 = uintptr(0)
			nextPtrPtr = uintptr(unsafe.Pointer(&firstDetached))
			curPtr = firstDetached
		__1:
			if !(curPtr != uintptr(0)) {
				goto __3
			}
			{

				if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), (*struct {
					f func(*libc.TLS, Tcl_Channel) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelName})).f(tls, (*TestChannel)(unsafe.Pointer(curPtr)).__chan)) == 0 {
					*(*uintptr)(unsafe.Pointer(nextPtrPtr)) = (*TestChannel)(unsafe.Pointer(curPtr)).nextPtr
					(*TestChannel)(unsafe.Pointer(curPtr)).nextPtr = uintptr(0)
					chan1 = (*TestChannel)(unsafe.Pointer(curPtr)).__chan
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, curPtr)
					goto __3
				}

			}
			goto __2
		__2:
			nextPtrPtr = curPtr + 8
			curPtr = (*TestChannel)(unsafe.Pointer(curPtr)).nextPtr
			goto __1
			goto __3
		__3:
		} else {
			chan1 = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+560 /* &mode */)
		}
		if chan1 == uintptr(0) {
			return TCL_ERROR
		}
		chanPtr = chan1
		statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
		chanPtr = (*ChannelState)(unsafe.Pointer(statePtr)).topChanPtr
		chan1 = chanPtr
	} else {
		statePtr = uintptr(0)
		chan1 = uintptr(0)
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 's' && libc.Xstrncmp(tls, cmdName, ts+6227, len) == 0 {

		*(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)) = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), -1)

		(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 568)))).refCount++
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetChannelError})).f(tls, chan1, *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 568))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}

		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelError})).f(tls, chan1, bp+568 /* &msg */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 568))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		return TCL_OK
	}
	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 's' && libc.Xstrncmp(tls, cmdName, ts+6243, len) == 0 {

		*(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)) = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), -1)

		(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 576)))).refCount++
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetChannelErrorInterp})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 576))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelErrorInterp})).f(tls, interp, bp+576 /* &msg */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(bp + 576))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		return TCL_OK
	}

	// "cut" is actually more a simplified detach facility as provided by the
	// Thread package. Without the safeguards of a regular command (no
	// checking that the command is truly cut'able, no mutexes for
	// thread-safety). Its complementary command is "splice", see below.

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'c' && libc.Xstrncmp(tls, cmdName, ts+6265, len) == 0 {
		var det uintptr

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6269, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegisterChannel})).f(tls, uintptr(0), chan1) // prevent closing
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnregisterChannel})).f(tls, interp, chan1)

		(*struct{ f func(*libc.TLS, Tcl_Channel) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CutChannel})).f(tls, chan1)

		// Remember the channel in the pool of detached channels

		det = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(TestChannel{})))
		(*TestChannel)(unsafe.Pointer(det)).__chan = chan1
		(*TestChannel)(unsafe.Pointer(det)).nextPtr = firstDetached
		firstDetached = det

		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'c' && libc.Xstrncmp(tls, cmdName, ts+6287, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6308, uintptr(0)))
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, Tcl_Channel) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ClearChannelHandlers})).f(tls, chan1)
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i' && libc.Xstrncmp(tls, cmdName, ts+6343, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+96, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6348, uintptr(0)))
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ChannelName})).f(tls, (*Channel)(unsafe.Pointer(chanPtr)).typePtr))
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<1) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6367 /* "read" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<2) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6372 /* "write" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<3) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6378 /* "nonblocking" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6390 /* "blocking" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<4) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6399 /* "line" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<5) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6404 /* "none" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6409 /* "full" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<7) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6414 /* "async_flush" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<9) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6426 /* "eof" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<11) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6430 /* "blocked" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6438 /* "unblocked" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_AUTO {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6448 /* "auto" */)
			if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<12) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6453 /* "saw_cr" */)
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
			}
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_LF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6460 /* "lf" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_CR {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6463 /* "cr" */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TCL_TRANSLATE_CRLF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6466 /* "crlf" */)
			if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<12) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6471 /* "queued_cr" */)
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
			}
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_AUTO {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6448 /* "auto" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_LF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6460 /* "lf" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_CR {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6463 /* "cr" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TCL_TRANSLATE_CRLF {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6466 /* "crlf" */)
		}
		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_OutputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(int32((*struct {
			f func(*libc.TLS, Tcl_Channel) Tcl_WideInt
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Tell})).f(tls, chan1))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*ChannelState)(unsafe.Pointer(statePtr)).refCount))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, bp+584 /* &buf[0] */)

		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i' && libc.Xstrncmp(tls, cmdName, ts+6481, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}
		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+144, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i' && libc.Xstrncmp(tls, cmdName, ts+6517, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+160, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_IsChannelShared})).f(tls, chan1)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+176, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'i' && libc.Xstrncmp(tls, cmdName, ts+6526, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_IsStandardChannel})).f(tls, chan1)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+208, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'm' && libc.Xstrncmp(tls, cmdName, ts+6537, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<1) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6367 /* "read" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<2) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6372 /* "write" */)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+1356 /* "" */)
		}
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'm' && libc.Xstrncmp(tls, cmdName, ts+6542, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+240, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, Tcl_WideInt) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewWideIntObj})).f(tls,
			Tcl_WideInt((*struct {
				f func(*libc.TLS, Tcl_Channel) Tcl_ThreadId
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelThread})).f(tls, chan1))))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'n' && libc.Xstrncmp(tls, cmdName, ts+1653, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+256, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+272, (*ChannelState)(unsafe.Pointer(statePtr)).channelName, uintptr(0)))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'o' && libc.Xstrncmp(tls, cmdName, ts+6550, len) == 0 {
		hTblPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+6555 /* "tclIO" */, uintptr(0))
		if hTblPtr == uintptr(0) {
			return TCL_OK
		}
		for hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FirstHashEntry})).f(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != uintptr(0); hPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NextHashEntry})).f(tls, bp+608 /* &hSearch */) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
				if (*Tcl_HashTable)(unsafe.Pointer(hTblPtr)).keyType == 1 || (*Tcl_HashTable)(unsafe.Pointer(hTblPtr)).keyType == -1 {
					return *(*uintptr)(unsafe.Pointer(hPtr + 32))
				}
				return hPtr + 32 /* &.key */
			}())
		}
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'o' && libc.Xstrncmp(tls, cmdName, ts+6561, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		IOQueued = (*struct {
			f func(*libc.TLS, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_OutputBuffered})).f(tls, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64(IOQueued))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+304, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'q' && libc.Xstrncmp(tls, cmdName, ts+6576, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+336, func() uintptr {
				if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<12) != 0 {
					return ts + 6585 /* "1" */
				}
				return ts + 6587 /* "0" */
			}(), uintptr(0)))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'r' && libc.Xstrncmp(tls, cmdName, ts+6589, len) == 0 {
		hTblPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+6555 /* "tclIO" */, uintptr(0))
		if hTblPtr == uintptr(0) {
			return TCL_OK
		}
		for hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FirstHashEntry})).f(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != uintptr(0); hPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NextHashEntry})).f(tls, bp+608 /* &hSearch */) {
			chanPtr = (*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData
			statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
			if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<1) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
					if (*Tcl_HashTable)(unsafe.Pointer(hTblPtr)).keyType == 1 || (*Tcl_HashTable)(unsafe.Pointer(hTblPtr)).keyType == -1 {
						return *(*uintptr)(unsafe.Pointer(hPtr + 32))
					}
					return hPtr + 32
				}())
			}
		}
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'r' && libc.Xstrncmp(tls, cmdName, ts+6598, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+352, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+584 /* &buf[0] */, int64((*ChannelState)(unsafe.Pointer(statePtr)).refCount))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+368, bp+584 /* &buf[0] */, uintptr(0)))
		return TCL_OK
	}

	// "splice" is actually more a simplified attach facility as provided by
	// the Thread package. Without the safeguards of a regular command (no
	// checking that the command is truly cut'able, no mutexes for
	// thread-safety). Its complementary command is "cut", see above.

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 's' && libc.Xstrncmp(tls, cmdName, ts+6220, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}

		(*struct{ f func(*libc.TLS, Tcl_Channel) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SpliceChannel})).f(tls, chan1)

		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_RegisterChannel})).f(tls, interp, chan1)
		(*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnregisterChannel})).f(tls, uintptr(0), chan1)

		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 't' && libc.Xstrncmp(tls, cmdName, ts+6607, len) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+400, ts+6495 /* "channel name req..." */, uintptr(0)))
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+416, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ChannelName})).f(tls, (*Channel)(unsafe.Pointer(chanPtr)).typePtr), uintptr(0)))
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'w' && libc.Xstrncmp(tls, cmdName, ts+6612, len) == 0 {
		hTblPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+6555 /* "tclIO" */, uintptr(0))
		if hTblPtr == uintptr(0) {
			return TCL_OK
		}
		for hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FirstHashEntry})).f(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != uintptr(0); hPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NextHashEntry})).f(tls, bp+608 /* &hSearch */) {
			chanPtr = (*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData
			statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
			if (*ChannelState)(unsafe.Pointer(statePtr)).flags&(int32(1)<<2) != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, func() uintptr {
					if (*Tcl_HashTable)(unsafe.Pointer(hTblPtr)).keyType == 1 || (*Tcl_HashTable)(unsafe.Pointer(hTblPtr)).keyType == -1 {
						return *(*uintptr)(unsafe.Pointer(hPtr + 32))
					}
					return hPtr + 32
				}())
			}
		}
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 't' && libc.Xstrncmp(tls, cmdName, ts+6621, len) == 0 {
		// Syntax: transform channel -command command

		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+432, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6631, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6666) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+464, ts+6675 /* "bad argument \"" */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+6690, uintptr(0)))
			return TCL_ERROR
		}

		return (*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelTransform})).f(tls, interp, chan1,
			(*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), -1))
	}

	if int32(*(*int8)(unsafe.Pointer(cmdName))) == 'u' && libc.Xstrncmp(tls, cmdName, ts+6714, len) == 0 {
		// Syntax: unstack channel

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+496, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6722, uintptr(0)))
			return TCL_ERROR
		}
		return (*struct {
			f func(*libc.TLS, uintptr, Tcl_Channel) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UnstackChannel})).f(tls, interp, chan1)
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+528, ts+1303 /* "bad option \"" */, cmdName,

		ts+6740, uintptr(0)))
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestChannelEventCmd --
//
//	This procedure implements the "testchannelevent" command. It is used
//	to test the Tcl channel event mechanism.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes and returns channel event handlers.
//
//----------------------------------------------------------------------

func TestChannelEventCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5856:1: */
	bp := tls.Alloc(420)
	defer tls.Free(420)

	var resultListPtr uintptr
	var chanPtr uintptr
	var statePtr uintptr // state info for channel
	var esPtr uintptr
	var prevEsPtr uintptr
	var nextEsPtr uintptr
	var cmd uintptr
	// var index int32 at bp+416, 4

	var i int32
	var mask int32
	var len int32

	if argc < 3 || argc > 5 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+6855, uintptr(0)))
		return TCL_ERROR
	}
	chanPtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0))
	if chanPtr == uintptr(0) {
		return TCL_ERROR
	}
	statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state

	cmd = *(*uintptr)(unsafe.Pointer(argv + 2*8))
	len = int32(libc.Xstrlen(tls, cmd))
	if int32(*(*int8)(unsafe.Pointer(cmd))) == 'a' && libc.Xstrncmp(tls, cmd, ts+6887, uint64(len)) == 0 {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6891, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6589) == 0 {
			mask = int32(1) << 1
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6612) == 0 {
			mask = int32(1) << 2
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6404) == 0 {
			mask = 0
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+6926 /* "bad event name \"" */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+6943, uintptr(0)))
			return TCL_ERROR
		}

		esPtr = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(EventScriptRecord{})))
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
		(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = esPtr

		(*EventScriptRecord)(unsafe.Pointer(esPtr)).chanPtr = chanPtr
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).interp = interp
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).mask = mask
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), -1)
		(*Tcl_Obj)(unsafe.Pointer((*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr)).refCount++

		(*struct {
			f func(*libc.TLS, Tcl_Channel, int32, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateChannelHandler})).f(tls, chanPtr, mask,
			(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)

		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmd))) == 'd' && libc.Xstrncmp(tls, cmd, ts+1291, uint64(len)) == 0 {
		if argc != 4 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+96, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+6982, uintptr(0)))
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+416) == TCL_ERROR {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 416)) < 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+7009 /* "bad event index:..." */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+7027, uintptr(0)))
			return TCL_ERROR
		}
		i = 0
		esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
	__1:
		if !(i < *(*int32)(unsafe.Pointer(bp + 416)) && esPtr != uintptr(0)) {
			goto __3
		}
		{
			// Empty loop body.

		}
		goto __2
	__2:
		i++
		esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		goto __1
		goto __3
	__3:
		;
		if esPtr == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+160, ts+7049 /* "bad event index " */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+7066, uintptr(0)))
			return TCL_ERROR
		}
		if esPtr == (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr {
			(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		} else {
			for prevEsPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; prevEsPtr != uintptr(0) && (*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr != esPtr; prevEsPtr = (*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr {
				// Empty loop body.
			}
			if prevEsPtr == uintptr(0) {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+7081 /* "TestChannelEvent..." */, 0)
			}
			(*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		}
		(*struct {
			f func(*libc.TLS, Tcl_Channel, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteChannelHandler})).f(tls, chanPtr,
			(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, esPtr)

		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmd))) == 'l' && libc.Xstrncmp(tls, cmd, ts+7128, uint64(len)) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+7133, uintptr(0)))
			return TCL_ERROR
		}
		resultListPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)
		for esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; esPtr != uintptr(0); esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr {
			if (*EventScriptRecord)(unsafe.Pointer(esPtr)).mask != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, interp, resultListPtr, (*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls,
					func() uintptr {
						if (*EventScriptRecord)(unsafe.Pointer(esPtr)).mask == int32(1)<<1 {
							return ts + 6589 /* "readable" */
						}
						return ts + 6612 /* "writable" */
					}(), -1))
			} else {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, interp, resultListPtr,
					(*struct {
						f func(*libc.TLS, uintptr, int32) uintptr
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+6404 /* "none" */, -1))
			}
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, interp, resultListPtr, (*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, resultListPtr)
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmd))) == 'r' && libc.Xstrncmp(tls, cmd, ts+7152, uint64(len)) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+7162, uintptr(0)))
			return TCL_ERROR
		}
		for esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; esPtr != uintptr(0); esPtr = nextEsPtr {
			nextEsPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
			(*struct {
				f func(*libc.TLS, Tcl_Channel, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteChannelHandler})).f(tls, chanPtr,
				(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, esPtr)
		}
		(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = uintptr(0)
		return TCL_OK
	}

	if int32(*(*int8)(unsafe.Pointer(cmd))) == 's' && libc.Xstrncmp(tls, cmd, ts+4040, uint64(len)) == 0 {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+256, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
				ts+7186, uintptr(0)))
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+416) == TCL_ERROR {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 416)) < 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+7009 /* "bad event index:..." */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+7027, uintptr(0)))
			return TCL_ERROR
		}
		i = 0
		esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
	__4:
		if !(i < *(*int32)(unsafe.Pointer(bp + 416)) && esPtr != uintptr(0)) {
			goto __6
		}
		{
			// Empty loop body.

		}
		goto __5
	__5:
		i++
		esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		goto __4
		goto __6
	__6:
		;
		if esPtr == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+7049 /* "bad event index " */, *(*uintptr)(unsafe.Pointer(argv + 3*8)),
				ts+7066, uintptr(0)))
			return TCL_ERROR
		}

		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6589) == 0 {
			mask = int32(1) << 1
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6612) == 0 {
			mask = int32(1) << 2
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6404) == 0 {
			mask = 0
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+352, ts+6926 /* "bad event name \"" */, *(*uintptr)(unsafe.Pointer(argv + 4*8)),
				ts+6943, uintptr(0)))
			return TCL_ERROR
		}
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).mask = mask
		(*struct {
			f func(*libc.TLS, Tcl_Channel, int32, uintptr, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateChannelHandler})).f(tls, chanPtr, mask,
			(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclChannelEventScriptInvoker, esPtr)
		return TCL_OK
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, ts+7219 /* "bad command " */, cmd,
		ts+7232, uintptr(0)))
	return TCL_ERROR
}

//----------------------------------------------------------------------
//
// TestServiceModeCmd --
//
//	This procedure implements the "testservicemode" command which gets or
//      sets the current Tcl ServiceMode.  There are several tests which open
//      a file and assign various handlers to it.  For these tests to be
//      deterministic it is important that file events not be processed until
//      all of the handlers are in place.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	May change the ServiceMode setting.
//
//----------------------------------------------------------------------

func TestServiceModeCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:6072:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var newmode int32 at bp+32, 4

	var oldmode int32
	if argc > 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+7286, uintptr(0)))
		return TCL_ERROR
	}
	oldmode = libc.Bool32((*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetServiceMode})).f(tls) != TCL_SERVICE_NONE)
	if argc == 2 {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) == TCL_ERROR {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 32)) == 0 {
			(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetServiceMode})).f(tls, TCL_SERVICE_NONE)
		} else {
			(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetServiceMode})).f(tls, TCL_SERVICE_ALL)
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, oldmode))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestWrongNumArgsObjCmd --
//
//	Test the Tcl_WrongNumArgs function.
//
// Results:
//	Standard Tcl result.
//
// Side effects:
//	Sets interpreter result.
//
//----------------------------------------------------------------------

func TestWrongNumArgsObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6116:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var i int32 at bp, 4

	// var length int32 at bp+4, 4

	var msg uintptr

	if objc < 3 {
		// Don't use Tcl_WrongNumArgs here, as that is the function
		// we want to test!
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+7298 /* "insufficient arg..." */, uintptr(0))
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != TCL_OK {
		return TCL_ERROR
	}

	msg = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &length */)
	if *(*int32)(unsafe.Pointer(bp + 4)) == 0 {
		msg = uintptr(0)
	}

	if *(*int32)(unsafe.Pointer(bp)) > objc-3 {
		// Asked for more arguments than were given.
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+7298 /* "insufficient arg..." */, uintptr(0))
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, *(*int32)(unsafe.Pointer(bp /* i */)), objv+3*8, msg)
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestGetIndexFromObjStructObjCmd --
//
//	Test the Tcl_GetIndexFromObjStruct function.
//
// Results:
//	Standard Tcl result.
//
// Side effects:
//	Sets interpreter result.
//
//----------------------------------------------------------------------

func TestGetIndexFromObjStructObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6172:1: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	*(*[8]uintptr)(unsafe.Pointer(bp + 72 /* ary */)) = [8]uintptr{
		ts + 5775, ts + 7321, ts + 7323, ts + 7325, ts + 2389, ts + 2391, uintptr(0), uintptr(0),
	}
	// var idx int32 at bp+136, 4

	// var target int32 at bp+140, 4

	if objc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7327 /* "argument targetv..." */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+72, int32(uint64(2)*uint64(unsafe.Sizeof(uintptr(0)))),
		ts+7348, 0, bp+136) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+140) != TCL_OK {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 136)) != *(*int32)(unsafe.Pointer(bp + 140)) {
		// var buffer [64]int8 at bp+144, 64

		libc.Xsprintf(tls, bp+144, ts+5607, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 136 /* idx */))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+8, ts+7354, /* "index value comp..." */
			bp+144, uintptr(0)))
		libc.Xsprintf(tls, bp+144, ts+5607, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 140 /* target */))))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+40, ts+7390 /* " when " */, bp+144 /* &buffer[0] */, ts+7397 /* " expected" */, uintptr(0)))
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 3, objv, uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestFilesystemObjCmd --
//
//	This procedure implements the "testfilesystem" command. It is used to
//	test Tcl_FSRegister, Tcl_FSUnregister, and can be used to test that
//	the pluggable filesystem works.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Inserts or removes a filesystem from Tcl's stack.
//
//----------------------------------------------------------------------

func TestFilesystemObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6226:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var res int32
	// var boolVal int32 at bp, 4

	var msg uintptr

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7407 /* "boolean" */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != TCL_OK {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp)) != 0 {
		res = (*struct {
			f func(*libc.TLS, ClientData, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRegister})).f(tls, interp, uintptr(unsafe.Pointer(&testReportingFilesystem)))
		if res == TCL_OK {
			msg = ts + 7415 /* "registered" */
		} else {
			msg = ts + 7426 /* "failed" */
		}
	} else {
		res = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSUnregister})).f(tls, uintptr(unsafe.Pointer(&testReportingFilesystem)))
		if res == TCL_OK {
			msg = ts + 7433 /* "unregistered" */
		} else {
			msg = ts + 7426 /* "failed" */
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, msg, -1))
	return res
}

func TestReportInFilesystem(tls *libc.TLS, pathPtr uintptr, clientDataPtr uintptr) int32 { /* tclTest.c:6254:1: */
	var newPathPtr uintptr

	if pathPtr == lastPathPtr {
		// Reject all files second time around
		return -1
	}

	// Try to claim all files first time around

	newPathPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, pathPtr)
	lastPathPtr = newPathPtr
	(*Tcl_Obj)(unsafe.Pointer(newPathPtr)).refCount++
	if (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSGetFileSystemForPath})).f(tls, newPathPtr) == uintptr(0) {
		// Nothing claimed it. Therefore we don't either
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = newPathPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		lastPathPtr = uintptr(0)
		return -1
	}
	lastPathPtr = uintptr(0)
	*(*ClientData)(unsafe.Pointer(clientDataPtr)) = newPathPtr
	return TCL_OK
}

var lastPathPtr uintptr = uintptr(0) /* tclTest.c:6258:20 */

// Simple helper function to extract the native vfs representation of a path
// object, or NULL if no such representation exists.

func TestReportGetNativePath(tls *libc.TLS, pathPtr uintptr) uintptr { /* tclTest.c:6287:16: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSGetInternalRep})).f(tls, pathPtr, uintptr(unsafe.Pointer(&testReportingFilesystem)))
}

func TestReportFreeInternalRep(tls *libc.TLS, clientData ClientData) { /* tclTest.c:6295:1: */
	var nativeRep uintptr = clientData

	if nativeRep != uintptr(0) {
		// Free the path
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = nativeRep
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
}

func TestReportDupInternalRep(tls *libc.TLS, clientData ClientData) ClientData { /* tclTest.c:6307:1: */
	var original uintptr = clientData

	(*Tcl_Obj)(unsafe.Pointer(original)).refCount++
	return clientData
}

func TestReport(tls *libc.TLS, cmd uintptr, path uintptr, arg2 uintptr) { /* tclTest.c:6317:1: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var interp uintptr = (*struct {
		f func(*libc.TLS, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSData})).f(tls, uintptr(unsafe.Pointer(&testReportingFilesystem)))

	if interp == uintptr(0) {
		// This is bad, but not much we can do about it
	} else {
		var savedResult uintptr
		// var ds Tcl_DString at bp, 216

		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringInit})).f(tls, bp /* &ds */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppend})).f(tls, bp /* &ds */, ts+7446 /* "lappend filesyst..." */, -1)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringStartSublist})).f(tls, bp /* &ds */)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bp /* &ds */, cmd)
		if path != uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bp /* &ds */, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, path))
		}
		if arg2 != uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringAppendElement})).f(tls, bp /* &ds */, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, arg2))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringEndSublist})).f(tls, bp /* &ds */)
		savedResult = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)
		(*Tcl_Obj)(unsafe.Pointer(savedResult)).refCount++
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Eval})).f(tls, interp, (*Tcl_DString)(unsafe.Pointer(bp /* &ds */)).string)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp /* &ds */)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, savedResult)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = savedResult
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
}

func TestReportStat(tls *libc.TLS, path uintptr, buf uintptr) int32 { /* tclTest.c:6353:1: */
	TestReport(tls, ts+7472, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSStat})).f(tls, TestReportGetNativePath(tls, path), buf)
}

func TestReportLstat(tls *libc.TLS, path uintptr, buf uintptr) int32 { /* tclTest.c:6362:1: */
	TestReport(tls, ts+7477, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLstat})).f(tls, TestReportGetNativePath(tls, path), buf)
}

func TestReportAccess(tls *libc.TLS, path uintptr, mode int32) int32 { /* tclTest.c:6371:1: */
	TestReport(tls, ts+7483, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSAccess})).f(tls, TestReportGetNativePath(tls, path), mode)
}

func TestReportOpenFileChannel(tls *libc.TLS, interp uintptr, fileName uintptr, mode int32, permissions int32) Tcl_Channel { /* tclTest.c:6380:1: */
	TestReport(tls, ts+6550, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpOpenFileChannel})).f(tls, interp, TestReportGetNativePath(tls, fileName),
		mode, permissions)
}

func TestReportMatchInDirectory(tls *libc.TLS, interp uintptr, resultPtr uintptr, dirPtr uintptr, pattern uintptr, types1 uintptr) int32 { /* tclTest.c:6394:1: */
	if types1 != uintptr(0) && (*Tcl_GlobTypeData)(unsafe.Pointer(types1)).__type&(int32(1)<<7) != 0 {
		TestReport(tls, ts+7490, dirPtr, uintptr(0))
		return TCL_OK
	} else {
		TestReport(tls, ts+7502, dirPtr, uintptr(0))
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSMatchInDirectory})).f(tls, interp, resultPtr,
			TestReportGetNativePath(tls, dirPtr), pattern, types1)
	}
	return int32(0)
}

func TestReportChdir(tls *libc.TLS, dirName uintptr) int32 { /* tclTest.c:6413:1: */
	TestReport(tls, ts+7519, dirName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSChdir})).f(tls, TestReportGetNativePath(tls, dirName))
}

func TestReportLoadFile(tls *libc.TLS, interp uintptr, fileName uintptr, handlePtr uintptr, unloadProcPtr uintptr) int32 { /* tclTest.c:6421:1: */
	TestReport(tls, ts+7525, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLoadFile})).f(tls, interp, TestReportGetNativePath(tls, fileName), uintptr(0),
		uintptr(0), uintptr(0), uintptr(0), handlePtr, unloadProcPtr)
}

func TestReportLink(tls *libc.TLS, path uintptr, to uintptr, linkType int32) uintptr { /* tclTest.c:6438:16: */
	TestReport(tls, ts+7534, path, to)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSLink})).f(tls, TestReportGetNativePath(tls, path), to, linkType)
}

func TestReportRenameFile(tls *libc.TLS, src uintptr, dst uintptr) int32 { /* tclTest.c:6449:1: */
	TestReport(tls, ts+7539, src, dst)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRenameFile})).f(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst))
}

func TestReportCopyFile(tls *libc.TLS, src uintptr, dst uintptr) int32 { /* tclTest.c:6461:1: */
	TestReport(tls, ts+7550, src, dst)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSCopyFile})).f(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst))
}

func TestReportDeleteFile(tls *libc.TLS, path uintptr) int32 { /* tclTest.c:6471:1: */
	TestReport(tls, ts+7559, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSDeleteFile})).f(tls, TestReportGetNativePath(tls, path))
}

func TestReportCreateDirectory(tls *libc.TLS, path uintptr) int32 { /* tclTest.c:6479:1: */
	TestReport(tls, ts+7570, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSCreateDirectory})).f(tls, TestReportGetNativePath(tls, path))
}

func TestReportCopyDirectory(tls *libc.TLS, src uintptr, dst uintptr, errorPtr uintptr) int32 { /* tclTest.c:6487:1: */
	TestReport(tls, ts+7586, src, dst)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSCopyDirectory})).f(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst), errorPtr)
}

func TestReportRemoveDirectory(tls *libc.TLS, path uintptr, recursive int32, errorPtr uintptr) int32 { /* tclTest.c:6500:1: */
	TestReport(tls, ts+7600, path, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRemoveDirectory})).f(tls, TestReportGetNativePath(tls, path), recursive,
		errorPtr)
}

func TestReportFileAttrStrings(tls *libc.TLS, fileName uintptr, objPtrRef uintptr) uintptr { /* tclTest.c:6514:19: */
	TestReport(tls, ts+7616, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSFileAttrStrings})).f(tls, TestReportGetNativePath(tls, fileName), objPtrRef)
}

func TestReportFileAttrsGet(tls *libc.TLS, interp uintptr, index int32, fileName uintptr, objPtrRef uintptr) int32 { /* tclTest.c:6524:1: */
	TestReport(tls, ts+7637, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSFileAttrsGet})).f(tls, interp, index,
		TestReportGetNativePath(tls, fileName), objPtrRef)
}

func TestReportFileAttrsSet(tls *libc.TLS, interp uintptr, index int32, fileName uintptr, objPtr uintptr) int32 { /* tclTest.c:6536:1: */
	TestReport(tls, ts+7655, fileName, objPtr)
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSFileAttrsSet})).f(tls, interp, index,
		TestReportGetNativePath(tls, fileName), objPtr)
}

func TestReportUtime(tls *libc.TLS, fileName uintptr, tval uintptr) int32 { /* tclTest.c:6548:1: */
	TestReport(tls, ts+7673, fileName, uintptr(0))
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSUtime})).f(tls, TestReportGetNativePath(tls, fileName), tval)
}

func TestReportNormalizePath(tls *libc.TLS, interp uintptr, pathPtr uintptr, nextCheckpoint int32) int32 { /* tclTest.c:6557:1: */
	TestReport(tls, ts+7679, pathPtr, uintptr(0))
	return nextCheckpoint
}

func SimplePathInFilesystem(tls *libc.TLS, pathPtr uintptr, clientDataPtr uintptr) int32 { /* tclTest.c:6567:1: */
	var str uintptr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, pathPtr)

	if libc.Xstrncmp(tls, str, ts+7693, uint64(10)) != 0 {
		return -1
	}
	return TCL_OK
}

// This is a slightly 'hacky' filesystem which is used just to test a few
// important features of the vfs code: (1) that you can load a shared library
// from a vfs, (2) that when copying files from one fs to another, the 'mtime'
// is preserved. (3) that recursive cross-filesystem directory copies have the
// correct behaviour with/without -force.
//
// It treats any file in 'simplefs:/' as a file, which it routes to the
// current directory. The real file it uses is whatever follows the trailing
// '/' (e.g. 'foo' in 'simplefs:/foo'), and that file exists or not according
// to what is in the native pwd.
//
// Please do not consider this filesystem a model of how things are to be
// done. It is quite the opposite!  But, it does allow us to test some
// important features.

func TestSimpleFilesystemObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6597:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var res int32
	// var boolVal int32 at bp, 4

	var msg uintptr

	if objc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7407 /* "boolean" */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != TCL_OK {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp)) != 0 {
		res = (*struct {
			f func(*libc.TLS, ClientData, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSRegister})).f(tls, interp, uintptr(unsafe.Pointer(&simpleFilesystem)))
		if res == TCL_OK {
			msg = ts + 7415 /* "registered" */
		} else {
			msg = ts + 7426 /* "failed" */
		}
	} else {
		res = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSUnregister})).f(tls, uintptr(unsafe.Pointer(&simpleFilesystem)))
		if res == TCL_OK {
			msg = ts + 7433 /* "unregistered" */
		} else {
			msg = ts + 7426 /* "failed" */
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, msg, -1))
	return res
}

// Treats a file name 'simplefs:/foo' by using the file 'foo' in the current
// (native) directory.

func SimpleRedirect(tls *libc.TLS, pathPtr uintptr) uintptr { /* tclTest.c:6629:16: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var len int32 at bp, 4

	var str uintptr
	var origPtr uintptr

	// We assume the same name in the current directory is ok.

	str = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, pathPtr, bp /* &len */)
	if *(*int32)(unsafe.Pointer(bp)) < 10 || libc.Xstrncmp(tls, str, ts+7693, uint64(10)) != 0 {
		// Probably shouldn't ever reach here
		(*Tcl_Obj)(unsafe.Pointer(pathPtr)).refCount++
		return pathPtr
	}
	origPtr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, str+uintptr(10), -1)
	(*Tcl_Obj)(unsafe.Pointer(origPtr)).refCount++
	return origPtr
}

func SimpleMatchInDirectory(tls *libc.TLS, interp uintptr, resultPtr uintptr, dirPtr uintptr, pattern uintptr, types1 uintptr) int32 { /* tclTest.c:6653:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var res int32
	var origPtr uintptr
	var resPtr uintptr

	// We only provide a new volume, therefore no mounts at all
	if types1 != uintptr(0) && (*Tcl_GlobTypeData)(unsafe.Pointer(types1)).__type&(int32(1)<<7) != 0 {
		return TCL_OK
	}

	// We assume the same name in the current directory is ok.
	resPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)
	(*Tcl_Obj)(unsafe.Pointer(resPtr)).refCount++
	origPtr = SimpleRedirect(tls, dirPtr)
	res = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSMatchInDirectory})).f(tls, interp, resPtr, origPtr, pattern, types1)
	if res == TCL_OK {
		// var gLength int32 at bp, 4

		var j int32
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), resPtr, bp /* &gLength */)
		for j = 0; j < *(*int32)(unsafe.Pointer(bp /* gLength */)); j++ {
			// var gElt uintptr at bp+8, 8

			var nElt uintptr
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjIndex})).f(tls, uintptr(0), resPtr, j, bp+8 /* &gElt */)
			nElt = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+7693 /* "simplefs:/" */, 10)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendObjToObj})).f(tls, nElt, *(*uintptr)(unsafe.Pointer(bp + 8 /* gElt */)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjAppendElement})).f(tls, uintptr(0), resultPtr, nElt)
		}
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = origPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = resPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return res
}

func SimpleOpenFileChannel(tls *libc.TLS, interp uintptr, pathPtr uintptr, mode int32, permissions int32) Tcl_Channel { /* tclTest.c:6695:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var tempPtr uintptr
	var chan1 Tcl_Channel

	if mode != 0 && !(mode&O_RDONLY != 0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+7704 /* "read-only" */, uintptr(0)))
		return uintptr(0)
	}

	tempPtr = SimpleRedirect(tls, pathPtr)
	chan1 = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSOpenFileChannel})).f(tls, interp, tempPtr, ts+7714 /* "r" */, permissions)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = tempPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return chan1
}

func SimpleAccess(tls *libc.TLS, pathPtr uintptr, mode int32) int32 { /* tclTest.c:6718:1: */
	var tempPtr uintptr = SimpleRedirect(tls, pathPtr)
	var res int32 = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSAccess})).f(tls, tempPtr, mode)

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = tempPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return res
}

func SimpleStat(tls *libc.TLS, pathPtr uintptr, bufPtr uintptr) int32 { /* tclTest.c:6730:1: */
	var tempPtr uintptr = SimpleRedirect(tls, pathPtr)
	var res int32 = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_FSStat})).f(tls, tempPtr, bufPtr)

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = tempPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return res
}

func SimpleListVolumes(tls *libc.TLS) uintptr { /* tclTest.c:6741:16: */
	// Add one new volume
	var retVal uintptr

	retVal = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+7693 /* "simplefs:/" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(retVal)).refCount++
	return retVal
}

// Used to check operations of Tcl_UtfNext.
//
// Usage: testutfnext $bytes $offset

func TestUtfNextCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6759:1: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	// var numBytes int32 at bp+32, 4
	// Number of bytes supplied in the test string
	// var offset int32 at bp+36, 4
	// Number of bytes we are permitted to read
	var bytes uintptr
	var result uintptr
	var first uintptr
	// var buffer [32]int8 at bp+40, 32

	var p uintptr = uintptr(unsafe.Pointer(&tobetested))
	_ = dummy

	if objc < 2 || objc > 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7716 /* "string ?numBytes..." */)
		return TCL_ERROR
	}

	bytes = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+32 /* &numBytes */)

	*(*int32)(unsafe.Pointer(bp + 36 /* offset */)) = *(*int32)(unsafe.Pointer(bp + 32)) + TCL_UTF_MAX - 1 // If no constraint is given, allow
	// the terminating NUL to limit
	// operations.

	if objc == 3 {
		if TCL_OK != (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetIntForIndex})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), *(*int32)(unsafe.Pointer(bp + 32)), bp+36) {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 36)) < 0 {
			*(*int32)(unsafe.Pointer(bp + 36 /* offset */)) = 0
		}
		if *(*int32)(unsafe.Pointer(bp + 36)) > *(*int32)(unsafe.Pointer(bp + 32))+TCL_UTF_MAX-1 {
			*(*int32)(unsafe.Pointer(bp + 36 /* offset */)) = *(*int32)(unsafe.Pointer(bp + 32)) + TCL_UTF_MAX - 1
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 32)) > int32(unsafe.Sizeof([32]int8{}))-3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ObjPrintf})).f(tls,
			ts+7734,
			libc.VaList(bp, int32(unsafe.Sizeof([32]int8{}))-4)))
		return TCL_ERROR
	}

	libc.Xmemcpy(tls, bp+40+uintptr(1), bytes, uint64(*(*int32)(unsafe.Pointer(bp + 32 /* numBytes */))))
	*(*int8)(unsafe.Pointer(bp + 40)) = libc.AssignPtrInt8(bp+40+uintptr(*(*int32)(unsafe.Pointer(bp + 32))+1), libc.AssignPtrInt8(bp+40+uintptr(*(*int32)(unsafe.Pointer(bp + 32))+2), libc.AssignPtrInt8(bp+40+uintptr(*(*int32)(unsafe.Pointer(bp + 32))+3), int8(-96))))

	if !((*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfCharComplete})).f(tls, bp+40+uintptr(1), *(*int32)(unsafe.Pointer(bp + 36))) != 0) {

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, 0))
		return TCL_OK
	}

	first = libc.AssignUintptr(&result, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfNext})).f(tls, bp+40 /* &buffer[0] */ +uintptr(1)))
	for int32(libc.AssignPtrInt8(bp+40, *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))) != 0 {
		// Run Tcl_UtfNext with many more possible bytes at src[-1], all should give the same result
		result = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfNext})).f(tls, bp+40 /* &buffer[0] */ +uintptr(1))
		if first != result {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+8, ts+7773 /* "Tcl_UtfNext is n..." */, uintptr(0)))
			return TCL_ERROR
		}
	}
	p = uintptr(unsafe.Pointer(&tobetested))
	for int32(libc.AssignPtrInt8(bp+40+uintptr(*(*int32)(unsafe.Pointer(bp + 32))+1), *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))) != 0 {
		// Run Tcl_UtfNext with many more possible bytes at src[end], all should give the same result
		result = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfNext})).f(tls, bp+40 /* &buffer[0] */ +uintptr(1))
		if first != result {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ObjPrintf})).f(tls,

				ts+7817, libc.VaList(bp+24, int32(uint8(*(*int8)(unsafe.Pointer(p + libc.UintptrFromInt32(-1))))))))
			return TCL_ERROR
		}
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32(int64((first-(bp+40)) /* &buffer[0] */ /1)-int64(1))))

	return TCL_OK
}

var tobetested = *(*[14]int8)(unsafe.Pointer(ts + 7900)) /* tclTest.c:6770:23 */

// Used to check operations of Tcl_UtfPrev.
//
// Usage: testutfprev $bytes $offset

func TestUtfPrevCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6846:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var numBytes int32 at bp, 4

	// var offset int32 at bp+4, 4

	var bytes uintptr
	var result uintptr

	if objc < 2 || objc > 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+7914 /* "bytes ?offset?" */)
		return TCL_ERROR
	}

	bytes = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &numBytes */)

	if objc == 3 {
		if TCL_OK != (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetIntForIndex})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), *(*int32)(unsafe.Pointer(bp)), bp+4) {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 4)) < 0 {
			*(*int32)(unsafe.Pointer(bp + 4 /* offset */)) = 0
		}
		if *(*int32)(unsafe.Pointer(bp + 4)) > *(*int32)(unsafe.Pointer(bp)) {
			*(*int32)(unsafe.Pointer(bp + 4 /* offset */)) = *(*int32)(unsafe.Pointer(bp /* numBytes */))
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 4 /* offset */)) = *(*int32)(unsafe.Pointer(bp /* numBytes */))
	}
	result = func() uintptr {
		if bytes+uintptr(*(*int32)(unsafe.Pointer(bp + 4))) < bytes+uintptr(2) {
			return bytes
		}
		return func() uintptr {
			if int32(uint8(*(*int8)(unsafe.Pointer(bytes + uintptr(*(*int32)(unsafe.Pointer(bp + 4))) - uintptr(1))))) < 0x80 {
				return bytes + uintptr(*(*int32)(unsafe.Pointer(bp + 4))) - uintptr(1)
			}
			return (*struct {
				f func(*libc.TLS, uintptr, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfPrev})).f(tls, bytes+uintptr(*(*int32)(unsafe.Pointer(bp + 4))), bytes)
		}()
	}()
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32((int64(result)-int64(bytes))/1)))
	return TCL_OK
}

// Used to check correct string-length determining in Tcl_NumUtfChars

func TestNumUtfCharsCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6886:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if objc > 1 {
		// var numBytes int32 at bp, 4

		var len int32
		*(*int32)(unsafe.Pointer(bp + 4 /* limit */)) = -1
		var bytes uintptr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &numBytes */)

		if objc > 2 {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetIntForIndex})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), *(*int32)(unsafe.Pointer(bp)), bp+4) != TCL_OK {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 4)) > *(*int32)(unsafe.Pointer(bp))+1 {
				*(*int32)(unsafe.Pointer(bp + 4 /* limit */)) = *(*int32)(unsafe.Pointer(bp)) + 1
			}
		}
		len = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NumUtfChars})).f(tls, bytes, *(*int32)(unsafe.Pointer(bp + 4 /* limit */)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, len))
	}
	return TCL_OK
}

// Used to check correct operation of Tcl_UtfFindFirst

func TestFindFirstCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6915:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp /* &len */)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfFindFirst})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*int32)(unsafe.Pointer(bp /* len */))), -1))
	}
	return TCL_OK
}

// Used to check correct operation of Tcl_UtfFindLast

func TestFindLastCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6937:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp /* &len */)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_UtfFindLast})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*int32)(unsafe.Pointer(bp /* len */))), -1))
	}
	return TCL_OK
}

// Used to do basic checks of the TCL_HASH_KEY_SYSTEM_HASH flag

func TestHashSystemHashCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7015:1: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	// var hash Tcl_HashTable at bp+72, 88

	var hPtr uintptr
	var i int32
	// var isNew int32 at bp+160, 4

	*(*int32)(unsafe.Pointer(bp + 64 /* limit */)) = 100
	_ = dummy

	if objc > 1 && (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+64) != TCL_OK {
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InitCustomHashTable})).f(tls, bp+72 /* &hash */, -2, uintptr(unsafe.Pointer(&hkType)))

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72)).numEntries != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+7929 /* "non-zero initial..." */, uintptr(0)))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
		return TCL_ERROR
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* limit */)); i++ {
		hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer(bp + 72 /* &hash */)).createProc})).f(tls, bp+72 /* &hash */, uintptr(intptr_t(i)), bp+160 /* &isNew */)
		if !(*(*int32)(unsafe.Pointer(bp + 160)) != 0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+7951 /* " creation proble..." */, -1)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
			return TCL_ERROR
		}
		(*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData = uintptr(intptr_t(i + 42))
	}

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72)).numEntries != *(*int32)(unsafe.Pointer(bp + 64)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+7969 /* "unexpected maxim..." */, uintptr(0)))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
		return TCL_ERROR
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* limit */)); i++ {
		hPtr = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer(bp + 72 /* &hash */)).findProc})).f(tls, bp+72 /* &hash */, uintptr(intptr_t(i)))
		if hPtr == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+7993 /* " lookup problem" */, -1)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
			return TCL_ERROR
		}
		if int32((*Tcl_HashEntry)(unsafe.Pointer(hPtr)).clientData) != i+42 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+8009 /* " value problem" */, -1)
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashEntry})).f(tls, hPtr)
	}

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72)).numEntries != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+8024 /* "non-zero final s..." */, uintptr(0)))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
		return TCL_ERROR
	}

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteHashTable})).f(tls, bp+72 /* &hash */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, ts+8044 /* "OK" */, uintptr(0)))
	return TCL_OK
}

var hkType = Tcl_HashKeyType{
	version: TCL_HASH_KEY_TYPE_VERSION, flags: TCL_HASH_KEY_SYSTEM_HASH,
} /* tclTest.c:7021:34 */

// Used for testing Tcl_GetInt which is no longer used directly by the
// core very much.
func TestgetintCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:7092:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	_ = dummy

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetResult})).f(tls, interp, ts+1271 /* "wrong # args" */, uintptr(0))
		return TCL_ERROR
	} else {
		// var val int32 at bp, 4

		var i int32
		var total int32 = 0

		for i = 1; i < argc; i++ {
			if (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp) != TCL_OK {
				return TCL_ERROR
			}
			total = total + *(*int32)(unsafe.Pointer(bp))
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, total))
		return TCL_OK
	}
	return int32(0)
}

func NREUnwind_callback(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclTest.c:7118:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var none int32 at bp, 4

	_ = result

	if *(*ClientData)(unsafe.Pointer(data)) == libc.UintptrFromInt64(int64(-1)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), bp /* &none */, libc.UintptrFromInt64(int64(-1)),
			libc.UintptrFromInt64(int64(-1)), uintptr(0))
	} else if *(*ClientData)(unsafe.Pointer(data + 1*8)) == libc.UintptrFromInt64(int64(-1)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), *(*ClientData)(unsafe.Pointer(data)), bp, /* &none */
			libc.UintptrFromInt64(int64(-1)), uintptr(0))
	} else if *(*ClientData)(unsafe.Pointer(data + 2*8)) == libc.UintptrFromInt64(int64(-1)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), *(*ClientData)(unsafe.Pointer(data)), *(*ClientData)(unsafe.Pointer(data + 1*8)),
			bp, uintptr(0))
	} else {
		// var idata [3]uintptr at bp+8, 24

		*(*uintptr)(unsafe.Pointer(bp + 8)) = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32((int64(*(*ClientData)(unsafe.Pointer(data + 1*8)))-int64(*(*ClientData)(unsafe.Pointer(data))))/1))
		*(*uintptr)(unsafe.Pointer(bp + 8 + 1*8)) = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32((int64(*(*ClientData)(unsafe.Pointer(data + 2*8)))-int64(*(*ClientData)(unsafe.Pointer(data))))/1))
		*(*uintptr)(unsafe.Pointer(bp + 8 + 2*8)) = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32((int64(bp /* &none */)-int64(*(*ClientData)(unsafe.Pointer(data))))/1))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
			f func(*libc.TLS, int32, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 3, bp+8 /* &idata[0] */))
	}
	return TCL_OK
}

func TestNREUnwind(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7146:1: */
	_ = dummy
	_ = objc
	_ = objv

	// Insure that callbacks effectively run at the proper level during the
	// unwinding of the NRE stack.

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NRAddCallback})).f(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{NREUnwind_callback})), libc.UintptrFromInt64(int64(-1)), libc.UintptrFromInt64(int64(-1)),
		libc.UintptrFromInt64(int64(-1)), uintptr(0))
	return TCL_OK
}

func TestNRELevels(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7168:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var iPtr uintptr = interp
	// var depth ptrdiff_t at bp, 8

	// var levels [6]uintptr at bp+8, 48

	var i int32 = 0
	var cbPtr uintptr = (*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).callbackPtr
	_ = dummy
	_ = objc
	_ = objv

	if refDepth == uintptr(0) {
		refDepth = bp /* &depth */
	}

	*(*ptrdiff_t)(unsafe.Pointer(bp /* depth */)) = (int64(refDepth) - int64(bp)) / 8

	*(*uintptr)(unsafe.Pointer(bp + 8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32(*(*ptrdiff_t)(unsafe.Pointer(bp /* depth */))))
	*(*uintptr)(unsafe.Pointer(bp + 8 + 1*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Interp)(unsafe.Pointer(iPtr)).numLevels)
	*(*uintptr)(unsafe.Pointer(bp + 8 + 2*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*CmdFrame)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).cmdFramePtr)).level)
	*(*uintptr)(unsafe.Pointer(bp + 8 + 3*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*CallFrame)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).varFramePtr)).level)
	*(*uintptr)(unsafe.Pointer(bp + 8 + 4*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, int32(int64(((*ExecStack)(unsafe.Pointer((*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).execStackPtr)).tosPtr-
		((*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).execStackPtr+40))/8)))

	for cbPtr != 0 {
		i++
		cbPtr = (*NRE_callback)(unsafe.Pointer(cbPtr)).nextPtr
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 + 5*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, i)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 6, bp+8 /* &levels[0] */))
	return TCL_OK
}

var refDepth uintptr = uintptr(0) /* tclTest.c:7175:22 */

//----------------------------------------------------------------------
//
// TestconcatobjCmd --
//
//	This procedure implements the "testconcatobj" command. It is used
//	to test that Tcl_ConcatObj does indeed return a fresh Tcl_Obj in all
//	cases and thet it never corrupts its arguments. In other words, that
//	[Bug 1447328] was fixed properly.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestconcatobjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:7227:1: */
	bp := tls.Alloc(576)
	defer tls.Free(576)

	var list1Ptr uintptr
	var list2Ptr uintptr
	var emptyPtr uintptr
	var concatPtr uintptr
	var tmpPtr uintptr
	var result int32 = TCL_OK
	// var len int32 at bp+544, 4

	// var objv [3]uintptr at bp+552, 24

	// Set the start of the error message as obj result; it will be cleared at
	// the end if no errors were found.

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
		(*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+8047 /* "Tcl_ConcatObj is..." */, -1))

	emptyPtr = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls)

	list1Ptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+8072 /* "foo bar sum" */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), list1Ptr, bp+544 /* &len */)
	if (*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes != uintptr(0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes)
		(*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes = uintptr(0)
	}

	list2Ptr = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+8084 /* "eeny meeny" */, -1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), list2Ptr, bp+544 /* &len */)
	if (*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes != uintptr(0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, (*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes)
		(*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes = uintptr(0)
	}

	// Verify that concat'ing a list obj with one or more empty strings does
	// return a fresh Tcl_Obj (see also [Bug 2055782]).

	tmpPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)

	*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 + 1*8)) = emptyPtr
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp, ts+8095, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+8138, /* "\n\t* (a) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+8174 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+48, ts+8192 /* "(refCount added)" */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+8209 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+8241 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+80, ts+8287, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+96, ts+8330, /* "\n\t* (b) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+112, ts+8366 /* "(refCount remove..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+8241 /* "extremely unsafe..." */, 0)
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+128, ts+8174 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 2:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+144, ts+8192 /* "(refCount added)" */, uintptr(0)))
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+160, ts+8209 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+8241 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	}
	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552)) = emptyPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 + 1*8)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 + 2*8)) = emptyPtr
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 3, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+176, ts+8386, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+192, ts+8429, /* "\n\t* (c) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+208, ts+8174 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+8192 /* "(refCount added)" */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+240, ts+8209 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+8241 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 + 1*8)) = tmpPtr
	}
	for ok3 := true; ok3; ok3 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 3, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+256, ts+8465, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+272, ts+8508, /* "\n\t* (d) concatOb..." */
			uintptr(0)))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+8366 /* "(refCount remove..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+8241 /* "extremely unsafe..." */, 0)
			break
			fallthrough
		case 1:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+304, ts+8174 /* "(no new refCount..." */, uintptr(0)))
			break
			fallthrough
		case 2:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+8192 /* "(refCount added)" */, uintptr(0)))
			for ok4 := true; ok4; ok4 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+336, ts+8209 /* "(more than one r..." */, uintptr(0)))
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Panic})).f(tls, ts+8241 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 + 1*8)) = tmpPtr
	}
	for ok5 := true; ok5; ok5 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	// Verify that an unshared list is not corrupted when concat'ing things to
	// it.

	*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 + 1*8)) = list2Ptr
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+352, ts+8544, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+368, ts+8587, /* "\n\t* (e) concatOb..." */
			uintptr(0)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), concatPtr, bp+544 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, ts+8623 /* "(failed to conca..." */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+400, ts+8642 /* "(corrupted input..." */, uintptr(0)))
		}
		if (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount > 1 {
			for ok6 := true; ok6; ok6 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	}
	for ok7 := true; ok7; ok7 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 + 1*8)) = list2Ptr
	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+416, ts+8661, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+432, ts+8704, /* "\n\t* (f) concatOb..." */
			uintptr(0)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), concatPtr, bp+544 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+448, ts+8623 /* "(failed to conca..." */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+464, ts+8642 /* "(corrupted input..." */, uintptr(0)))
		}
		if (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount > 1 {
			for ok8 := true; ok8; ok8 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	}
	for ok9 := true; ok9; ok9 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 + 1*8)) = list2Ptr
	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	(*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount++
	concatPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConcatObj})).f(tls, 2, bp+552 /* &objv[0] */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+480, ts+8740, uintptr(0)))
	}
	if concatPtr == tmpPtr {
		result = TCL_ERROR
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+496, ts+8783, /* "\n\t* (g) concatOb..." */
			uintptr(0)))

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjLength})).f(tls, uintptr(0), concatPtr, bp+544 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+512, ts+8623 /* "(failed to conca..." */, uintptr(0)))
			break
			fallthrough
		default:
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+528, ts+8642 /* "(corrupted input..." */, uintptr(0)))
		}
		for ok10 := true; ok10; ok10 = 0 != 0 {
			var _objPtr uintptr = tmpPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
		if (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount > 1 {
			for ok11 := true; ok11; ok11 = 0 != 0 {
				var _objPtr uintptr = tmpPtr
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552)) = tmpPtr
	}
	for ok12 := true; ok12; ok12 = 0 != 0 {
		var _objPtr uintptr = concatPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	// Clean everything up. Note that we don't actually know how many
	// references there are to tmpPtr here; in the no-error case, it should be
	// five... [Bug 2895367]

	for ok13 := true; ok13; ok13 = 0 != 0 {
		var _objPtr uintptr = list1Ptr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for ok14 := true; ok14; ok14 = 0 != 0 {
		var _objPtr uintptr = list2Ptr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for ok15 := true; ok15; ok15 = 0 != 0 {
		var _objPtr uintptr = emptyPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	for (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount > 1 {
		for ok16 := true; ok16; ok16 = 0 != 0 {
			var _objPtr uintptr = tmpPtr
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	for ok17 := true; ok17; ok17 = 0 != 0 {
		var _objPtr uintptr = tmpPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	if result == TCL_OK {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	}
	return result
}

//----------------------------------------------------------------------
//
// TestparseargsCmd --
//
//	This procedure implements the "testparseargs" command. It is used to
//	test that Tcl_ParseArgsObjv does indeed return the right number of
//	arguments. In other words, that [Bug 3413857] was fixed properly.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparseargsCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7524:1: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	*(*int32)(unsafe.Pointer(bp + 192 /* count */)) = objc
	// var remObjv uintptr at bp+200, 8

	// var result [3]uintptr at bp+208, 24

	*(*[4]Tcl_ArgvInfo)(unsafe.Pointer(bp /* argTable */)) = [4]Tcl_ArgvInfo{
		{__type: TCL_ARGV_CONSTANT, keyStr: ts + 8819, srcPtr: uintptr(int64(1)), dstPtr: uintptr(unsafe.Pointer(&foo)), helpStr: ts + 8825},
		{__type: TCL_ARGV_REST, keyStr: ts + 4698, helpStr: ts + 8834}, {__type: TCL_ARGV_HELP, keyStr: ts + 8863, helpStr: ts + 8869}, {__type: TCL_ARGV_END},
	}

	foo = 0
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ParseArgsObjv})).f(tls, interp, bp, bp+192, objv, bp+200) != TCL_OK {
		return TCL_ERROR
	}
	*(*uintptr)(unsafe.Pointer(bp + 208)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, foo)
	*(*uintptr)(unsafe.Pointer(bp + 208 + 1*8)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 192 /* count */)))
	*(*uintptr)(unsafe.Pointer(bp + 208 + 2*8)) = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 192 /* count */)), *(*uintptr)(unsafe.Pointer(bp + 200 /* remObjv */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 3, bp+208 /* &result[0] */))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* remObjv */)))
	return TCL_OK
}

var foo int32 = 0 /* tclTest.c:7530:16 */

// *
// Test harness for command and variable resolvers.

func InterpCmdResolver(tls *libc.TLS, interp uintptr, name uintptr, dummy uintptr, flags int32, rPtr uintptr) int32 { /* tclTest.c:7555:1: */
	var iPtr uintptr = interp
	var varFramePtr uintptr = (*Interp)(unsafe.Pointer(iPtr)).varFramePtr
	var procPtr uintptr
	if (*CallFrame)(unsafe.Pointer(varFramePtr)).isProcCallFrame&FRAME_IS_PROC != 0 {
		procPtr = (*CallFrame)(unsafe.Pointer(varFramePtr)).procPtr
	} else {
		procPtr = uintptr(0)
	}
	var callerNsPtr uintptr = (*CallFrame)(unsafe.Pointer(varFramePtr)).nsPtr
	var resolvedCmdPtr Tcl_Command = uintptr(0)
	_ = dummy

	// Just do something special on a cmd literal "z" in two cases:
	//  A)  when the caller is a proc "x", and the proc is either in "::" or in "::ns2".
	//  B) the caller's namespace is "ctx1" or "ctx2"
	if int32(*(*int8)(unsafe.Pointer(name))) == 'z' && int32(*(*int8)(unsafe.Pointer(name + 1))) == 0 {
		var ns2NsPtr uintptr = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindNamespace})).f(tls, interp, ts+8917 /* "::ns2" */, uintptr(0), 0)

		if procPtr != uintptr(0) &&
			((*Command1)(unsafe.Pointer((*Proc)(unsafe.Pointer(procPtr)).cmdPtr)).nsPtr == (*Interp)(unsafe.Pointer(iPtr)).globalNsPtr ||
				ns2NsPtr != uintptr(0) && (*Command1)(unsafe.Pointer((*Proc)(unsafe.Pointer(procPtr)).cmdPtr)).nsPtr == ns2NsPtr) {
			// Case A)
			//
			//    - The context, in which this resolver becomes active, is
			//      determined by the name of the caller proc, which has to be
			//      named "x".
			//
			//    - To determine the name of the caller proc, the proc is taken
			//      from the topmost stack frame.
			//
			//    - Note that the context is NOT provided during byte-code
			//      compilation (e.g. in TclProcCompileProc)
			//
			//   When these conditions hold, this function resolves the
			//   passed-in cmd literal into a cmd "y", which is taken from the
			//   the global namespace (for simplicity).

			var callingCmdName uintptr = (*struct {
				f func(*libc.TLS, uintptr, Tcl_Command) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetCommandName})).f(tls, interp, (*Proc)(unsafe.Pointer(procPtr)).cmdPtr)

			if int32(*(*int8)(unsafe.Pointer(callingCmdName))) == 'x' && int32(*(*int8)(unsafe.Pointer(callingCmdName + 1))) == 0 {
				resolvedCmdPtr = (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, ts+8923 /* "y" */, uintptr(0), TCL_GLOBAL_ONLY)
			}
		} else if callerNsPtr != uintptr(0) {
			// Case B)
			//
			//    - The context, in which this resolver becomes active, is
			//      determined by the name of the parent namespace, which has
			//      to be named "ctx1" or "ctx2".
			//
			//    - To determine the name of the parent namesace, it is taken
			//      from the 2nd highest stack frame.
			//
			//    - Note that the context can be provided during byte-code
			//      compilation (e.g. in TclProcCompileProc)
			//
			//   When these conditions hold, this function resolves the
			//   passed-in cmd literal into a cmd "y" or "Y" depending on the
			//   context. The resolved procs are taken from the the global
			//   namespace (for simplicity).

			var parentFramePtr uintptr = (*CallFrame)(unsafe.Pointer(varFramePtr)).callerPtr
			var context uintptr
			if parentFramePtr != uintptr(0) {
				context = (*Namespace)(unsafe.Pointer((*CallFrame)(unsafe.Pointer(parentFramePtr)).nsPtr)).name
			} else {
				context = ts + 8925 /* "(NULL)" */
			}

			if libc.Xstrcmp(tls, context, ts+8932) == 0 && int32(*(*int8)(unsafe.Pointer(name))) == 'z' && int32(*(*int8)(unsafe.Pointer(name + 1))) == 0 {
				resolvedCmdPtr = (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, ts+8923 /* "y" */, uintptr(0), TCL_GLOBAL_ONLY)
				// fprintf(stderr, "... y ==> %p\n", resolvedCmdPtr);

			} else if libc.Xstrcmp(tls, context, ts+8937) == 0 && int32(*(*int8)(unsafe.Pointer(name))) == 'z' && int32(*(*int8)(unsafe.Pointer(name + 1))) == 0 {
				resolvedCmdPtr = (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, ts+8942 /* "Y" */, uintptr(0), TCL_GLOBAL_ONLY)
				//fprintf(stderr, "... Y ==> %p\n", resolvedCmdPtr);
			}
		}

		if resolvedCmdPtr != uintptr(0) {
			*(*Tcl_Command)(unsafe.Pointer(rPtr)) = resolvedCmdPtr
			return TCL_OK
		}
	}
	return TCL_CONTINUE
}

func InterpVarResolver(tls *libc.TLS, interp uintptr, name uintptr, context uintptr, flags int32, rPtr uintptr) int32 { /* tclTest.c:7649:1: */
	// Don't resolve the variable; use standard rules.

	return TCL_CONTINUE
}

type MyResolvedVarInfo1 = struct {
	vInfo   Tcl_ResolvedVarInfo
	__var   Tcl_Var
	nameObj uintptr
} /* tclTest.c:7663:9 */

type MyResolvedVarInfo = MyResolvedVarInfo1 /* tclTest.c:7667:3 */

func HashVarFree(tls *libc.TLS, var1 Tcl_Var) { /* tclTest.c:7670:1: */
	if (*VarInHash)(unsafe.Pointer(var1)).refCount < 2 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, var1)
	} else {
		(*VarInHash)(unsafe.Pointer(var1)).refCount--
	}
}

func MyCompiledVarFree(tls *libc.TLS, vInfoPtr uintptr) { /* tclTest.c:7681:1: */
	var resVarInfo uintptr = vInfoPtr

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	if (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var != 0 {
		HashVarFree(tls, (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var)
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, vInfoPtr)
}

func MyCompiledVarFetch(tls *libc.TLS, interp uintptr, vinfoPtr uintptr) Tcl_Var { /* tclTest.c:7697:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var resVarInfo uintptr = vinfoPtr
	var var1 Tcl_Var = (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var
	// var isNewVar int32 at bp, 4

	var iPtr uintptr = interp
	var hPtr uintptr

	if var1 != uintptr(0) {
		if !((*Var)(unsafe.Pointer(var1)).flags&VAR_DEAD_HASH != 0) {
			// The cached variable is valid, return it.

			return var1
		}

		// The variable is not valid anymore. Clean it up.

		HashVarFree(tls, var1)
	}

	hPtr = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_HashTable)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 248 /* &.varTable */)).createProc})).f(tls, (*Interp)(unsafe.Pointer(iPtr)).globalNsPtr+248 /* &.varTable */, (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj, bp /* &isNewVar */)
	if hPtr != 0 {
		var1 = hPtr - uintptr(int32(uintptr(0)+24))
	} else {
		var1 = uintptr(0)
	}
	(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var = var1

	// Increment the reference counter to avoid ckfree() of the variable in
	// Tcl's FreeVarEntry(); for cleanup, we provide our own HashVarFree();

	(*VarInHash)(unsafe.Pointer(var1)).refCount++
	return var1
}

func InterpCompiledVarResolver(tls *libc.TLS, interp uintptr, name uintptr, length int32, context uintptr, rPtr uintptr) int32 { /* tclTest.c:7742:1: */
	if int32(*(*int8)(unsafe.Pointer(name))) == 'T' {
		var resVarInfo uintptr = (*struct {
			f func(*libc.TLS, uint32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(unsafe.Sizeof(MyResolvedVarInfo{})))

		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).vInfo.fetchProc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) Tcl_Var
		}{MyCompiledVarFetch}))
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).vInfo.deleteProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{MyCompiledVarFree}))
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var = uintptr(0)
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, name, -1)
		(*Tcl_Obj)(unsafe.Pointer((*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj)).refCount++
		*(*uintptr)(unsafe.Pointer(rPtr)) = resVarInfo
		return TCL_OK
	}
	return TCL_CONTINUE
}

func TestInterpResolverCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7764:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var idx int32 at bp+32, 4

	if objc < 2 || objc > 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+8944 /* "up|down ?interp?" */)
		return TCL_ERROR
	}
	if objc == 3 {
		interp = (*struct {
			f func(*libc.TLS, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetSlave})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
		if interp == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+8961 /* "provided interpr..." */, uintptr(0)))
			return TCL_ERROR
		}
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&table)), int32(unsafe.Sizeof(uintptr(0))), ts+8992, TCL_EXACT, bp+32) != TCL_OK {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp + 32 /* idx */)) {
	case 1: // up
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_AddInterpResolvers})).f(tls, interp, ts+9002 /* "testInterpResolv..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		}{InterpCmdResolver})),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
			}{InterpVarResolver})), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr) int32
			}{InterpCompiledVarResolver})))
		break
	case 0: //down
		if !((*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_RemoveInterpResolvers})).f(tls, interp, ts+9002) != 0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+16, ts+9021, /* "could not remove..." */
				uintptr(0)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

var table = [3]uintptr{
	ts + 9058, ts + 9063, uintptr(0),
} /* tclTest.c:7770:23 */

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// tab-width: 8
// indent-tabs-mode: nil
// End:
// Epoch of the tcl environment
// (if changed with tcl-env).

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// tclStringRep.h --
//
//	This file contains the definition of the Unicode string internal
//	representation and macros to access it.
//
//	A Unicode string is an internationalized string. Conceptually, a
//	Unicode string is an array of 16-bit quantities organized as a
//	sequence of properly formed UTF-8 characters. There is a one-to-one
//	map between Unicode and UTF characters. Because Unicode characters
//	have a fixed width, operations such as indexing operate on Unicode
//	data. The String object is optimized for the case where each UTF char
//	in a string is only one byte. In this case, we store the value of
//	numChars, but we don't store the Unicode data (unless Tcl_GetUnicode
//	is explicitly called).
//
//	The String object type stores one or both formats. The default
//	behavior is to store UTF. Once Unicode is calculated by a function, it
//	is stored in the internal rep for future access (without an additional
//	O(n) cost).
//
//	To allow many appends to be done to an object without constantly
//	reallocating the space for the string or Unicode representation, we
//	allocate double the space for the string or Unicode and use the
//	internal representation to keep track of how much space is used vs.
//	allocated.
//
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
// Copyright (c) 1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// The following structure is the internal rep for a String object. It keeps
// track of how much memory has been used and how much has been allocated for
// the Unicode and UTF string to enable growing and shrinking of the UTF and
// Unicode reps of the String object with fewer mallocs. To optimize string
// length and indexing operations, this structure also stores the number of
// characters (same of UTF and Unicode!) once that value has been computed.
//
// Under normal configurations, what Tcl calls "Unicode" is actually UTF-16
// restricted to the Basic Multilingual Plane (i.e. U+00000 to U+0FFFF). This
// can be officially modified by altering the definition of Tcl_UniChar in
// tcl.h, but do not do that unless you are sure what you're doing!

type String1 = struct {
	_          [0]uint32
	numChars   int32
	allocated  int32
	maxChars   int32
	hasUnicode int32
} /* tclStringRep.h:49:9 */

// Epoch of the tcl environment
// (if changed with tcl-env).

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//    LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// tclStringRep.h --
//
//	This file contains the definition of the Unicode string internal
//	representation and macros to access it.
//
//	A Unicode string is an internationalized string. Conceptually, a
//	Unicode string is an array of 16-bit quantities organized as a
//	sequence of properly formed UTF-8 characters. There is a one-to-one
//	map between Unicode and UTF characters. Because Unicode characters
//	have a fixed width, operations such as indexing operate on Unicode
//	data. The String object is optimized for the case where each UTF char
//	in a string is only one byte. In this case, we store the value of
//	numChars, but we don't store the Unicode data (unless Tcl_GetUnicode
//	is explicitly called).
//
//	The String object type stores one or both formats. The default
//	behavior is to store UTF. Once Unicode is calculated by a function, it
//	is stored in the internal rep for future access (without an additional
//	O(n) cost).
//
//	To allow many appends to be done to an object without constantly
//	reallocating the space for the string or Unicode representation, we
//	allocate double the space for the string or Unicode and use the
//	internal representation to keep track of how much space is used vs.
//	allocated.
//
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
// Copyright (c) 1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// The following structure is the internal rep for a String object. It keeps
// track of how much memory has been used and how much has been allocated for
// the Unicode and UTF string to enable growing and shrinking of the UTF and
// Unicode reps of the String object with fewer mallocs. To optimize string
// length and indexing operations, this structure also stores the number of
// characters (same of UTF and Unicode!) once that value has been computed.
//
// Under normal configurations, what Tcl calls "Unicode" is actually UTF-16
// restricted to the Basic Multilingual Plane (i.e. U+00000 to U+0FFFF). This
// can be officially modified by altering the definition of Tcl_UniChar in
// tcl.h, but do not do that unless you are sure what you're doing!

type String = String1 /* tclStringRep.h:65:3 */

func VarPtrDeleteProc(tls *libc.TLS, clientData ClientData, interp uintptr) { /* tclTestObj.c:54:13: */
	var i int32
	var varPtr uintptr = clientData
	for i = 0; i < NUMBER_OF_OBJECT_VARS; i++ {
		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) != 0 {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
				}
			}
		}
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteAssocData})).f(tls, interp, ts+9066 /* "TCLOBJTEST_VARPT..." */)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, varPtr)
}

func GetVarPtr(tls *libc.TLS, interp uintptr) uintptr { /* tclTestObj.c:65:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var proc uintptr at bp, 8

	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) ClientData
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetAssocData})).f(tls, interp, ts+9066 /* "TCLOBJTEST_VARPT..." */, bp /* &proc */)
}

//----------------------------------------------------------------------
//
// TclObjTest_Init --
//
//	This function creates additional commands that are used to test the
//	Tcl object support.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error
//	message in the interp's result if an error occurs.
//
// Side effects:
//	Creates and registers several new testing commands.
//
//----------------------------------------------------------------------

func TclObjTest_Init(tls *libc.TLS, interp uintptr) int32 { /* tclTestObj.c:91:1: */
	var i int32
	// An array of Tcl_Obj pointers used in the commands that operate on or get
	// the values of Tcl object-valued variables. varPtr[i] is the i-th variable's
	// Tcl_Obj *.
	var varPtr uintptr

	varPtr = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(uint64(NUMBER_OF_OBJECT_VARS)*uint64(unsafe.Sizeof(uintptr(0)))))
	if !(varPtr != 0) {
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetAssocData})).f(tls, interp, ts+9066 /* "TCLOBJTEST_VARPT..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr)
	}{VarPtrDeleteProc})), varPtr)
	for i = 0; i < NUMBER_OF_OBJECT_VARS; i++ {
		*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) = uintptr(0)
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9084 /* "testbignumobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbignumobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9098 /* "testbooleanobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbooleanobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9113 /* "testdoubleobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdoubleobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9127 /* "testintobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestintobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9138 /* "testindexobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestindexobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9151 /* "testlistobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlistobjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9163 /* "testobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestobjCmd})), uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+9171 /* "teststringobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TeststringobjCmd})),
		uintptr(0), uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestbignumobjCmd --
//
//	This function implements the "testbignumobj" command.  It is used
//	to exercise the bignum Tcl object type implementation.
//
// Results:
//	Returns a standard Tcl object result.
//
// Side effects:
//	Creates and frees bignum objects; converts objects to have bignum
//	type.
//
//----------------------------------------------------------------------

func TestbignumobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:148:1: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	*(*[7]uintptr)(unsafe.Pointer(bp /* subcmds */)) = [7]uintptr{
		ts + 4040, ts + 1409, ts + 9185, ts + 9192, ts + 9198, ts + 9205, uintptr(0),
	}
	// var index int32 at bp+56, 4

	// var varIndex int32 at bp+60, 4

	var string uintptr
	// var bignumValue mp_int at bp+64, 24

	var varPtr uintptr

	if objc < 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9215 /* "option ?arg ...?" */)
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp, int32(unsafe.Sizeof(uintptr(0))), ts+3235, 0, bp+56) != TCL_OK {
		return TCL_ERROR
	}
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if GetVariableIndex(tls, interp, string, bp+60) != TCL_OK {
		return TCL_ERROR
	}
	varPtr = GetVarPtr(tls, interp)

	switch *(*int32)(unsafe.Pointer(bp + 56 /* index */)) {
	case 0 /* BIGNUM_SET */ :
		if objc != 4 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9232 /* "var value" */)
			return TCL_ERROR
		}
		string = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
		if (*struct {
			f func(*libc.TLS, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_init})).f(tls, bp+64) != MP_OKAY {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+9242 /* "error in mp_init" */, -1))
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_read_radix})).f(tls, bp+64, string, 10) != MP_OKAY {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+9259 /* "error in mp_read..." */, -1))
			return TCL_ERROR
		}

		// If the object currently bound to the variable with index varIndex
		// has ref count 1 (i.e. the object is unshared) we can modify that
		// object directly.  Otherwise, if RC>1 (i.e. the object is shared),
		// we must create a new object to modify/set and decrement the old
		// formerly-shared object's ref count. This is "copy on write".

		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetBignumObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+64 /* &bignumValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewBignumObj})).f(tls, bp+64 /* &bignumValue */))
		}
		break

	case 1 /* BIGNUM_GET */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9282 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60))) != 0 {
			return TCL_ERROR
		}
		break

	case 2 /* BIGNUM_MULT10 */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9282 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)),
			bp+64) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, mp_digit, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_mul_d})).f(tls, bp+64, uint32(10), bp+64) != MP_OKAY {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+9291 /* "error in mp_mul_..." */, -1))
			return TCL_ERROR
		}
		if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetBignumObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+64 /* &bignumValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewBignumObj})).f(tls, bp+64 /* &bignumValue */))
		}
		break

	case 3 /* BIGNUM_DIV10 */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9282 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)),
			bp+64) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, mp_digit, uintptr, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_div_d})).f(tls, bp+64, uint32(10), bp+64, uintptr(0)) != MP_OKAY {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+9309 /* "error in mp_div_..." */, -1))
			return TCL_ERROR
		}
		if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetBignumObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+64 /* &bignumValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewBignumObj})).f(tls, bp+64 /* &bignumValue */))
		}
		break

	case 4 /* BIGNUM_ISEVEN */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9282 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)),
			bp+64) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_mod_2d})).f(tls, bp+64, 1, bp+64) != MP_OKAY {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp,
				(*struct {
					f func(*libc.TLS, uintptr, int32) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+9327 /* "error in mp_mod_..." */, -1))
			return TCL_ERROR
		}
		if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), func() int32 {
				if (*mp_int)(unsafe.Pointer(bp+64 /* &bignumValue */)).used == 0 {
					return MP_YES
				}
				return MP_NO
			}())
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, func() int32 {
				if (*mp_int)(unsafe.Pointer(bp+64)).used == 0 {
					return MP_YES
				}
				return MP_NO
			}()))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
		break

	case 5 /* BIGNUM_RADIXSIZE */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9282 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60))) != 0 {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBignumFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)),
			bp+64) != TCL_OK {
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr) mp_err
		})(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_radix_size})).f(tls, bp+64, 10, bp+56) != MP_OKAY {
			return TCL_ERROR
		}
		if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*8)))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 56 /* index */)))
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*struct {
				f func(*libc.TLS, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 56 /* index */))))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclTomMathStubs)(unsafe.Pointer(tcl.XtclTomMathStubsPtr)).tclBN_mp_clear})).f(tls, bp+64 /* &bignumValue */)
		break
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestbooleanobjCmd --
//
//	This function implements the "testbooleanobj" command.  It is used to
//	test the boolean Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees boolean objects, and also converts objects to
//	have boolean type.
//
//----------------------------------------------------------------------

func TestbooleanobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:347:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var varIndex int32 at bp+32, 4

	// var boolValue int32 at bp+36, 4

	var index uintptr
	var subCmd uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9346 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	varPtr = GetVarPtr(tls, interp)

	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+4040) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+36) != TCL_OK) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared),
	// we must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1)) {
		goto __7
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), libc.Bool32(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0)))
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(libc.Xstrcmp(tls, subCmd, ts+1409) == 0) {
		goto __9
	}
	if !(objc != 3) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __12
	}
	return TCL_ERROR
__12:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __10
__9:
	if !(libc.Xstrcmp(tls, subCmd, ts+9367) == 0) {
		goto __13
	}
	if !(objc != 3) {
		goto __15
	}
	goto wrongNumArgs
__15:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __16
	}
	return TCL_ERROR
__16:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)),
		bp+36) != TCL_OK) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	if !!((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1) {
		goto __18
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), libc.Bool32(libc.BoolInt32(!(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0)) != 0))
	goto __19
__18:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, libc.Bool32(libc.BoolInt32(!(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0)) != 0)))
__19:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __14
__13:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+1303, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
			ts+9371, uintptr(0)))
	return TCL_ERROR
__14:
	;
__10:
	;
__4:
	;
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestdoubleobjCmd --
//
//	This function implements the "testdoubleobj" command.  It is used to
//	test the double-precision floating point Tcl object type
//	implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees double objects, and also converts objects to
//	have double type.
//
//----------------------------------------------------------------------

func TestdoubleobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:447:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var varIndex int32 at bp+32, 4

	// var doubleValue float64 at bp+40, 8

	var index uintptr
	var subCmd uintptr
	var string uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9346 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)

	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+4040) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDouble})).f(tls, interp, string, bp+40) != TCL_OK) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared), we
	// must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1)) {
		goto __7
	}
	(*struct {
		f func(*libc.TLS, uintptr, float64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDoubleObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, float64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewDoubleObj})).f(tls, *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))))
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(libc.Xstrcmp(tls, subCmd, ts+1409) == 0) {
		goto __9
	}
	if !(objc != 3) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __12
	}
	return TCL_ERROR
__12:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __10
__9:
	if !(libc.Xstrcmp(tls, subCmd, ts+9185) == 0) {
		goto __13
	}
	if !(objc != 3) {
		goto __15
	}
	goto wrongNumArgs
__15:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __16
	}
	return TCL_ERROR
__16:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDoubleFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)),
		bp+40) != TCL_OK) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	if !!((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1) {
		goto __18
	}
	(*struct {
		f func(*libc.TLS, uintptr, float64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDoubleObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))*10.0)
	goto __19
__18:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, float64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewDoubleObj})).f(tls, *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))*10.0))
__19:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __14
__13:
	if !(libc.Xstrcmp(tls, subCmd, ts+9192) == 0) {
		goto __20
	}
	if !(objc != 3) {
		goto __22
	}
	goto wrongNumArgs
__22:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __23
	}
	return TCL_ERROR
__23:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDoubleFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)),
		bp+40) != TCL_OK) {
		goto __24
	}
	return TCL_ERROR
__24:
	;
	if !!((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1) {
		goto __25
	}
	(*struct {
		f func(*libc.TLS, uintptr, float64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDoubleObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))/10.0)
	goto __26
__25:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, float64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewDoubleObj})).f(tls, *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))/10.0))
__26:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __21
__20:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+1303, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
			ts+9399, uintptr(0)))
	return TCL_ERROR
__21:
	;
__14:
	;
__10:
	;
__4:
	;
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestindexobjCmd --
//
//	This function implements the "testindexobj" command. It is used to
//	test the index Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees int objects, and also converts objects to
//	have int type.
//
//----------------------------------------------------------------------

func TestindexobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:565:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var allowAbbrev int32 at bp+12, 4

	// var index int32 at bp+4, 4

	// var index2 int32 at bp, 4

	// var setError int32 at bp+8, 4

	var i int32
	var result int32
	var argv uintptr
	var indexRep uintptr

	if objc == 3 && libc.Xstrcmp(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
		ts+9437) == 0 {
		// This code checks to be sure that the results of Tcl_GetIndexFromObj
		// are properly cached in the object and returned on subsequent
		// lookups.

		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != TCL_OK {
			return TCL_ERROR
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&tablePtr)), int32(unsafe.Sizeof(uintptr(0))), ts+9443 /* "token" */, 0, bp+4 /* &index */)
		indexRep = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 1*8)) + 32))
		(*IndexRep)(unsafe.Pointer(indexRep)).index = *(*int32)(unsafe.Pointer(bp /* index2 */))
		result = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&tablePtr)), int32(unsafe.Sizeof(uintptr(0))), ts+9443 /* "token" */, 0, bp+4 /* &index */)
		if result == TCL_OK {
			(*struct {
				f func(*libc.TLS, uintptr, int32)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 4 /* index */)))
		}
		return result
	}

	if objc < 5 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+1271 /* "wrong # args" */, -1)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetBooleanFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+12) != TCL_OK {
		return TCL_ERROR
	}

	argv = (*struct {
		f func(*libc.TLS, uint32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Alloc})).f(tls, uint32(uint64(objc-3)*uint64(unsafe.Sizeof(uintptr(0)))))
	for i = 4; i < objc; i++ {
		*(*uintptr)(unsafe.Pointer(argv + uintptr(i-4)*8)) = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	}
	*(*uintptr)(unsafe.Pointer(argv + uintptr(objc-4)*8)) = uintptr(0)

	// Tcl_GetIndexFromObj assumes that the table is statically-allocated so
	// that its address is different for each index object. If we accidently
	// allocate a table at the same address as that cached in the index
	// object, clear out the object's cached state.

	if (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr != uintptr(0) &&
		!(libc.Xstrcmp(tls, ts+9449, (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr)).name) != 0) {
		indexRep = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)) + 32))
		if (*IndexRep)(unsafe.Pointer(indexRep)).tablePtr == argv {
			if (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr != uintptr(0) {
				if (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr)).freeIntRepProc != uintptr(0) {
					(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr)).freeIntRepProc})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
				}
				(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 3*8)))).typePtr = uintptr(0)
			}

		}
	}

	result = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 8)) != 0 {
			return interp
		}
		return uintptr(0)
	}(), *(*uintptr)(unsafe.Pointer(objv + 3*8)), argv, int32(unsafe.Sizeof(uintptr(0))), ts+9443, func() int32 {
		if *(*int32)(unsafe.Pointer(bp + 12)) != 0 {
			return 0
		}
		return TCL_EXACT
	}(), bp+4)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_Free})).f(tls, argv)
	if result == TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 4 /* index */)))
	}
	return result
}

// Keep this structure declaration in sync with tclIndexObj.c
type IndexRep = struct {
	tablePtr uintptr
	offset   int32
	index    int32
} /* tclTestObj.c:577:5 */

var tablePtr = [4]uintptr{ts + 5775, ts + 7321, ts + 9437, uintptr(0)} /* tclTestObj.c:573:23 */

//----------------------------------------------------------------------
//
// TestintobjCmd --
//
//	This function implements the "testintobj" command. It is used to
//	test the int Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees int objects, and also converts objects to
//	have int type.
//
//----------------------------------------------------------------------

func TestintobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:668:1: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var intValue int32 at bp+48, 4

	// var varIndex int32 at bp+32, 4

	// var i int32 at bp+36, 4

	// var longValue int64 at bp+40, 8

	var index uintptr
	var subCmd uintptr
	var string uintptr
	var varPtr uintptr
	var maxLong int64

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9346 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+4040) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp+36) != TCL_OK) {
		goto __6
	}
	return TCL_ERROR
__6:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared), we
	// must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1)) {
		goto __7
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
__8:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(libc.Xstrcmp(tls, subCmd, ts+9455) == 0) {
		goto __9
	} // doesn't set result
	if !(objc != 4) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp+36) != TCL_OK) {
		goto __12
	}
	return TCL_ERROR
__12:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1)) {
		goto __13
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))
	goto __14
__13:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
__14:
	;
	goto __10
__9:
	if !(libc.Xstrcmp(tls, subCmd, ts+9460) == 0) {
		goto __15
	}
	if !(objc != 4) {
		goto __17
	}
	goto wrongNumArgs
__17:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp+36) != TCL_OK) {
		goto __18
	}
	return TCL_ERROR
__18:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1)) {
		goto __19
	}
	(*struct {
		f func(*libc.TLS, uintptr, int64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetLongObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), int64(*(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
	goto __20
__19:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, int64(*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))))
__20:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __16
__15:
	if !(libc.Xstrcmp(tls, subCmd, ts+9468) == 0) {
		goto __21
	}
	maxLong = 0x7fffffffffffffff
	if !(objc != 3) {
		goto __23
	}
	goto wrongNumArgs
__23:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1)) {
		goto __24
	}
	(*struct {
		f func(*libc.TLS, uintptr, int64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetLongObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), maxLong)
	goto __25
__24:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, maxLong))
__25:
	;
	goto __22
__21:
	if !(libc.Xstrcmp(tls, subCmd, ts+9479) == 0) {
		goto __26
	}
	if !(objc != 3) {
		goto __28
	}
	goto wrongNumArgs
__28:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __29
	}
	return TCL_ERROR
__29:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetLongFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)), bp+40) != TCL_OK) {
		goto __30
	}
	return TCL_ERROR
__30:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		func() uintptr {
			if *(*int64)(unsafe.Pointer(bp + 40)) == 0x7fffffffffffffff {
				return ts + 6585 /* "1" */
			}
			return ts + 6587 /* "0" */
		}(), -1)
	goto __27
__26:
	if !(libc.Xstrcmp(tls, subCmd, ts+1409) == 0) {
		goto __31
	}
	if !(objc != 3) {
		goto __33
	}
	goto wrongNumArgs
__33:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __34
	}
	return TCL_ERROR
__34:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __32
__31:
	if !(libc.Xstrcmp(tls, subCmd, ts+9489) == 0) {
		goto __35
	}
	if !(objc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __38
	}
	return TCL_ERROR
__38:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), string, -1)
	goto __36
__35:
	if !(libc.Xstrcmp(tls, subCmd, ts+9494) == 0) {
		goto __39
	}
	// If long ints have more bits than ints on this platform, verify that
	// Tcl_GetIntFromObj returns an error if the long int held in an
	// integer object's internal representation is too large to fit in an
	// int.

	if !(objc != 3) {
		goto __41
	}
	goto wrongNumArgs
__41:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1)) {
		goto __42
	}
	(*struct {
		f func(*libc.TLS, uintptr, int64)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetLongObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), 0x7fffffffffffffff)
	goto __43
__42:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int64) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewLongObj})).f(tls, 0x7fffffffffffffff))
__43:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)), bp+36) != TCL_OK) {
		goto __44
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+6585 /* "1" */, -1)
	return TCL_OK
__44:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+6587 /* "0" */, -1)
	goto __40
__39:
	if !(libc.Xstrcmp(tls, subCmd, ts+9185) == 0) {
		goto __45
	}
	if !(objc != 3) {
		goto __47
	}
	goto wrongNumArgs
__47:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __48
	}
	return TCL_ERROR
__48:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)),
		bp+48) != TCL_OK) {
		goto __49
	}
	return TCL_ERROR
__49:
	;
	if !!((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1) {
		goto __50
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))*10)
	goto __51
__50:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))*10))
__51:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __46
__45:
	if !(libc.Xstrcmp(tls, subCmd, ts+9192) == 0) {
		goto __52
	}
	if !(objc != 3) {
		goto __54
	}
	goto wrongNumArgs
__54:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32))) != 0) {
		goto __55
	}
	return TCL_ERROR
__55:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)),
		bp+48) != TCL_OK) {
		goto __56
	}
	return TCL_ERROR
__56:
	;
	if !!((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)))).refCount > 1) {
		goto __57
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))/10)
	goto __58
__57:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))/10))
__58:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __53
__52:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+1303, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),
			ts+9508, uintptr(0)))
	return TCL_ERROR
__53:
	;
__46:
	;
__40:
	;
__36:
	;
__32:
	;
__27:
	;
__22:
	;
__16:
	;
__10:
	;
__4:
	;
	return TCL_OK
}

//-----------------------------------------------------------------------------
//
// TestlistobjCmd --
//
//	This function implements the 'testlistobj' command. It is used to
//	test a few possible corner cases in list object manipulation from
//	C code that cannot occur at the Tcl level.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates, manipulates and frees list objects.
//
//-----------------------------------------------------------------------------

func TestlistobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:872:1: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// Subcommands supported by this command
	*(*[3]uintptr)(unsafe.Pointer(bp + 8 /* subcommands */)) = [3]uintptr{
		ts + 4040,
		ts + 1409,
		ts + 9552,
	}
	var index uintptr // Argument giving the variable number
	// var varIndex int32 at bp, 4
	// Variable number converted to binary
	// var cmdIndex int32 at bp+32, 4
	// Ordinal number of the subcommand
	// var first int32 at bp+36, 4
	// First index in the list
	// var count int32 at bp+40, 4
	// Count of elements in a list
	var varPtr uintptr

	if objc < 3 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9560 /* "option arg ?arg...." */)
		return TCL_ERROR
	}
	varPtr = GetVarPtr(tls, interp)
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if GetVariableIndex(tls, interp, index, bp) != TCL_OK {
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8, int32(unsafe.Sizeof(uintptr(0))), ts+4470, 0, bp+32) != TCL_OK {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp + 32 /* cmdIndex */)) {
	case 0 /* LISTOBJ_SET */ :
		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp)))*8)) != uintptr(0) && !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp)))*8)))).refCount > 1) {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetListObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)), objc-3, objv+uintptr(3)*8)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */)), (*struct {
				f func(*libc.TLS, int32, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, objc-3, objv+uintptr(3)*8))
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)))
		break

	case 1 /* LISTOBJ_GET */ :
		if objc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv, ts+9282 /* "varIndex" */)
			return TCL_ERROR
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp))) != 0 {
			return TCL_ERROR
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)))
		break

	case 2 /* LISTOBJ_REPLACE */ :
		if objc < 5 {
			(*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 2, objv,
				ts+9580)
			return TCL_ERROR
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+36) != TCL_OK ||
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+40) != TCL_OK {
			return TCL_ERROR
		}
		if (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp)))*8)))).refCount > 1 {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */)), (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8))))
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjReplace})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 36 /* first */)), *(*int32)(unsafe.Pointer(bp + 40 /* count */)),
			objc-5, objv+uintptr(5)*8)
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestobjCmd --
//
//	This function implements the "testobj" command. It is used to test
//	the type-independent portions of the Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees objects.
//
//----------------------------------------------------------------------

func TestobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:969:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var varIndex int32 at bp+64, 4

	// var destIndex int32 at bp+68, 4

	var i int32
	var index uintptr
	var subCmd uintptr
	var string uintptr
	var targetType uintptr
	var varPtr uintptr
	var listObjPtr uintptr
	// var elemObjPtr uintptr at bp+72, 8

	var typeName uintptr
	var _objPtr uintptr
	var typeName1 uintptr

	if !(objc < 2) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9346 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	subCmd = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(libc.Xstrcmp(tls, subCmd, ts+9614) == 0) {
		goto __2
	}
	if !(objc != 4) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64) != TCL_OK) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64))) != 0) {
		goto __6
	}
	return TCL_ERROR
__6:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !(GetVariableIndex(tls, interp, string, bp+68) != TCL_OK) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)))*8)))
	goto __3
__2:
	if !(libc.Xstrcmp(tls, subCmd, ts+9621) == 0) {
		goto __8
	}
	if !(objc != 2) {
		goto __10
	}
	goto wrongNumArgs
__10:
	;
	*(*uintptr)(unsafe.Pointer(bp + 72 /* elemObjPtr */)) = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, 123)
	listObjPtr = (*struct {
		f func(*libc.TLS, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewListObj})).f(tls, 1, bp+72 /* &elemObjPtr */)
	// Replace the single list element through itself, nonsense but legal.
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ListObjReplace})).f(tls, interp, listObjPtr, 0, 1, 1, bp+72 /* &elemObjPtr */)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, listObjPtr)
	return TCL_OK
	goto __9
__8:
	if !(libc.Xstrcmp(tls, subCmd, ts+9632) == 0) {
		goto __11
	}

	if !(objc != 4) {
		goto __13
	}
	goto wrongNumArgs
__13:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64) != TCL_OK) {
		goto __14
	}
	return TCL_ERROR
__14:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64))) != 0) {
		goto __15
	}
	return TCL_ERROR
__15:
	;
	typeName = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !(libc.AssignUintptr(&targetType, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, typeName)) == uintptr(0)) {
		goto __16
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp, ts+9640, typeName, ts+9649, uintptr(0)))
	return TCL_ERROR
__16:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConvertToType})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64)))*8)), targetType) !=
		TCL_OK) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __12
__11:
	if !(libc.Xstrcmp(tls, subCmd, ts+9656) == 0) {
		goto __18
	}
	if !(objc != 4) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64) != TCL_OK) {
		goto __21
	}
	return TCL_ERROR
__21:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64))) != 0) {
		goto __22
	}
	return TCL_ERROR
__22:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !(GetVariableIndex(tls, interp, string, bp+68) != TCL_OK) {
		goto __23
	}
	return TCL_ERROR
__23:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)))*8)))
	goto __19
__18:
	if !(libc.Xstrcmp(tls, subCmd, ts+9666) == 0) {
		goto __24
	}
	if !(objc != 2) {
		goto __26
	}
	goto wrongNumArgs
__26:
	;
	i = 0
__27:
	if !(i < NUMBER_OF_OBJECT_VARS) {
		goto __29
	}
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) != uintptr(0)) {
		goto __30
	}
__31:
	_objPtr = *(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8))
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1) {
		goto __34
	}
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
__34:
	;
	goto __32
__32:
	if 0 != 0 {
		goto __31
	}
	goto __33
__33:
	;
	*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) = uintptr(0)
__30:
	;
	goto __28
__28:
	i++
	goto __27
	goto __29
__29:
	;
	goto __25
__24:
	if !(libc.Xstrcmp(tls, subCmd, ts+9678) == 0) {
		goto __35
	}
	if !(objc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64) != TCL_OK) {
		goto __38
	}
	return TCL_ERROR
__38:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64))) != 0) {
		goto __39
	}
	return TCL_ERROR
__39:
	;
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InvalidateStringRep})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __36
__35:
	if !(libc.Xstrcmp(tls, subCmd, ts+9698) == 0) {
		goto __40
	}
	if !(objc != 3) {
		goto __42
	}
	goto wrongNumArgs
__42:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64) != TCL_OK) {
		goto __43
	}
	return TCL_ERROR
__43:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __41
__40:
	if !(libc.Xstrcmp(tls, subCmd, ts+9705) == 0) {
		goto __44
	}

	// Return an object containing the name of the argument's type of
	// internal rep. If none exists, return "none".

	if !(objc != 3) {
		goto __46
	}
	goto wrongNumArgs
__46:
	;
	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 2*8)))).typePtr == uintptr(0)) {
		goto __47
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, ts+6404 /* "none" */, -1))
	goto __48
__47:
	typeName1 = (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + 2*8)))).typePtr)).name
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, typeName1, -1))
__48:
	;
	goto __45
__44:
	if !(libc.Xstrcmp(tls, subCmd, ts+6598) == 0) {
		goto __49
	}
	if !(objc != 3) {
		goto __51
	}
	goto wrongNumArgs
__51:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64) != TCL_OK) {
		goto __52
	}
	return TCL_ERROR
__52:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64))) != 0) {
		goto __53
	}
	return TCL_ERROR
__53:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).refCount))
	goto __50
__49:
	if !(libc.Xstrcmp(tls, subCmd, ts+6607) == 0) {
		goto __54
	}
	if !(objc != 3) {
		goto __56
	}
	goto wrongNumArgs
__56:
	;
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64) != TCL_OK) {
		goto __57
	}
	return TCL_ERROR
__57:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64))) != 0) {
		goto __58
	}
	return TCL_ERROR
__58:
	;
	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64)))*8)))).typePtr == uintptr(0)) {
		goto __59
	} // a string!
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+3982 /* "string" */, -1)
	goto __60
__59:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		(*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).typePtr)).name, -1)
__60:
	;
	goto __55
__54:
	if !(libc.Xstrcmp(tls, subCmd, ts+9713) == 0) {
		goto __61
	}
	if !(objc != 2) {
		goto __63
	}
	goto wrongNumArgs
__63:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendAllObjTypes})).f(tls, interp,
		(*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp)) != TCL_OK) {
		goto __64
	}
	return TCL_ERROR
__64:
	;
	goto __62
__61:
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
		libc.VaList(bp+32, ts+1303, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))),

			ts+9719, uintptr(0)))
	return TCL_ERROR
__62:
	;
__55:
	;
__50:
	;
__45:
	;
__41:
	;
__36:
	;
__25:
	;
__19:
	;
__12:
	;
__9:
	;
__3:
	;
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TeststringobjCmd --
//
//	This function implements the "teststringobj" command. It is used to
//	test the string Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees string objects, and also converts objects to
//	have string type.
//
//----------------------------------------------------------------------

func TeststringobjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:1173:1: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var unicode uintptr
	// var varIndex int32 at bp+96, 4

	// var option int32 at bp+100, 4

	// var i int32 at bp+208, 4

	// var length int32 at bp+104, 4

	var index uintptr
	var string uintptr
	// var strings [12]uintptr at bp+112, 96

	var strPtr uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+9346 /* "option arg ?arg ..." */)
	return TCL_ERROR
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	index = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(GetVariableIndex(tls, interp, index, bp+96) != TCL_OK) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIndexFromObjStruct})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&options2)), int32(unsafe.Sizeof(uintptr(0))), ts+3235, 0, bp+100) !=
		TCL_OK) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	switch *(*int32)(unsafe.Pointer(bp + 100 /* option */)) {
	case 0:
		goto __5
	case 1:
		goto __6
	case 2:
		goto __7
	case 3:
		goto __8
	case 4:
		goto __9
	case 5:
		goto __10
	case 6:
		goto __11
	case 7:
		goto __12
	case 8:
		goto __13
	case 9:
		goto __14
	case 10:
		goto __15
	case 11:
		goto __16
	case 12:
		goto __17
	}
	goto __4
__5: // append
	if !(objc != 5) {
		goto __18
	}
	goto wrongNumArgs
__18:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+104) != TCL_OK) {
		goto __19
	}
	return TCL_ERROR
__19:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) == uintptr(0)) {
		goto __20
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__20:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)))).refCount > 1) {
		goto __21
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__21:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), string, *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__6: // appendstrings
	if !(objc > MAX_STRINGS+3) {
		goto __22
	}
	goto wrongNumArgs
__22:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) == uintptr(0)) {
		goto __23
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__23:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)))).refCount > 1) {
		goto __24
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__24:
	;
	*(*int32)(unsafe.Pointer(bp + 208 /* i */)) = 3
__25:
	if !(*(*int32)(unsafe.Pointer(bp + 208)) < objc) {
		goto __27
	}
	*(*uintptr)(unsafe.Pointer(bp + 112 + uintptr(*(*int32)(unsafe.Pointer(bp + 208))-3)*8)) = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))*8)))
	goto __26
__26:
	*(*int32)(unsafe.Pointer(bp + 208 /* i */))++
	goto __25
	goto __27
__27:
	;
__28:
	if !(*(*int32)(unsafe.Pointer(bp + 208)) < 12+3) {
		goto __30
	}
	*(*uintptr)(unsafe.Pointer(bp + 112 + uintptr(*(*int32)(unsafe.Pointer(bp + 208))-3)*8)) = uintptr(0)
	goto __29
__29:
	*(*int32)(unsafe.Pointer(bp + 208 /* i */))++
	goto __28
	goto __30
__30:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), libc.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings[0] */ + 1*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 + 2*8)), *(*uintptr)(unsafe.Pointer(bp + 112 + 3*8)), *(*uintptr)(unsafe.Pointer(bp + 112 + 4*8)), *(*uintptr)(unsafe.Pointer(bp + 112 + 5*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 + 6*8)), *(*uintptr)(unsafe.Pointer(bp + 112 + 7*8)), *(*uintptr)(unsafe.Pointer(bp + 112 + 8*8)), *(*uintptr)(unsafe.Pointer(bp + 112 + 9*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 + 10*8)), *(*uintptr)(unsafe.Pointer(bp + 112 + 11*8))))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__7: // get
	if !(objc != 3) {
		goto __31
	}
	goto wrongNumArgs
__31:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 96))) != 0) {
		goto __32
	}
	return TCL_ERROR
__32:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__8: // get2
	if !(objc != 3) {
		goto __33
	}
	goto wrongNumArgs
__33:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 96))) != 0) {
		goto __34
	}
	return TCL_ERROR
__34:
	;
	string = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), string, -1)
	goto __4
__9: // length
	if !(objc != 3) {
		goto __35
	}
	goto wrongNumArgs
__35:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), func() int32 {
		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) != uintptr(0) {
			return (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))).length
		}
		return -1
	}())
	goto __4
__10: // length2
	if !(objc != 3) {
		goto __36
	}
	goto wrongNumArgs
__36:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) != uintptr(0)) {
		goto __37
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConvertToType})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)),
		(*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, ts+3982 /* "string" */))
	strPtr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) + 32))
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = (*String)(unsafe.Pointer(strPtr)).allocated
	goto __38
__37:
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = -1
__38:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __4
__11: // set
	if !(objc != 4) {
		goto __39
	}
	goto wrongNumArgs
__39:
	;

	// If the object currently bound to the variable with index
	// varIndex has ref count 1 (i.e. the object is unshared) we can
	// modify that object directly. Otherwise, if RC>1 (i.e. the
	// object is shared), we must create a new object to modify/set
	// and decrement the old formerly-shared object's ref count. This
	// is "copy on write".

	string = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+104 /* &length */)
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) != uintptr(0) &&
		!((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)))).refCount > 1)) {
		goto __40
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetStringObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), string, *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __41
__40:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls, string, *(*int32)(unsafe.Pointer(bp + 104 /* length */))))
__41:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__12: // set2
	if !(objc != 4) {
		goto __42
	}
	goto wrongNumArgs
__42:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	goto __4
__13: // setlength
	if !(objc != 4) {
		goto __43
	}
	goto wrongNumArgs
__43:
	;
	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+104) != TCL_OK) {
		goto __44
	}
	return TCL_ERROR
__44:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) != uintptr(0)) {
		goto __45
	}
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjLength})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
__45:
	;
	goto __4
__14: // maxchars
	if !(objc != 3) {
		goto __46
	}
	goto wrongNumArgs
__46:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) != uintptr(0)) {
		goto __47
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ConvertToType})).f(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)),
		(*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjType})).f(tls, ts+3982 /* "string" */))
	strPtr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) + 32))
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = (*String)(unsafe.Pointer(strPtr)).maxChars
	goto __48
__47:
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = -1
__48:
	;
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetIntObj})).f(tls, (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __4
__15: // getunicode
	if !(objc != 3) {
		goto __49
	}
	goto wrongNumArgs
__49:
	;
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetUnicodeFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), uintptr(0))
	goto __4
__16: // appendself
	if !(objc != 4) {
		goto __50
	}
	goto wrongNumArgs
__50:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) == uintptr(0)) {
		goto __51
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__51:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)))).refCount > 1) {
		goto __52
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__52:
	;

	string = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetStringFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), bp+104 /* &length */)

	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+208) != TCL_OK) {
		goto __53
	}
	return TCL_ERROR
__53:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 208)) < 0 || *(*int32)(unsafe.Pointer(bp + 208)) > *(*int32)(unsafe.Pointer(bp + 104))) {
		goto __54
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls,
		ts+9823, -1))
	return TCL_ERROR
__54:
	;

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), string+uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */))), *(*int32)(unsafe.Pointer(bp + 104 /* length */))-*(*int32)(unsafe.Pointer(bp + 208 /* i */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__17: // appendself2
	if !(objc != 4) {
		goto __55
	}
	goto wrongNumArgs
__55:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)) == uintptr(0)) {
		goto __56
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewObj})).f(tls))
__56:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)))).refCount > 1) {
		goto __57
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DuplicateObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__57:
	;

	unicode = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetUnicodeFromObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), bp+104 /* &length */)

	if !((*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+208) != TCL_OK) {
		goto __58
	}
	return TCL_ERROR
__58:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 208)) < 0 || *(*int32)(unsafe.Pointer(bp + 208)) > *(*int32)(unsafe.Pointer(bp + 104))) {
		goto __59
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewStringObj})).f(tls,
		ts+9823, -1))
	return TCL_ERROR
__59:
	;

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendUnicodeToObj})).f(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), unicode+uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))*2, *(*int32)(unsafe.Pointer(bp + 104 /* length */))-*(*int32)(unsafe.Pointer(bp + 208 /* i */)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__4:
	;

	return TCL_OK
}

var options2 = [14]uintptr{
	ts + 2393, ts + 9848, ts + 1409, ts + 9489, ts + 3133, ts + 9862,
	ts + 4040, ts + 9455, ts + 9870, ts + 9880, ts + 9889,
	ts + 9900, ts + 9911, uintptr(0),
} /* tclTestObj.c:1185:23 */

//----------------------------------------------------------------------
//
// SetVarToObj --
//
//	Utility routine to assign a Tcl_Obj* to a test variable. The
//	Tcl_Obj* can be NULL.
//
// Results:
//	None.
//
// Side effects:
//	This routine handles ref counting details for assignment: i.e. the old
//	value's ref count must be decremented (if not NULL) and the new one
//	incremented (also if not NULL).
//
//----------------------------------------------------------------------

func SetVarToObj(tls *libc.TLS, varPtr uintptr, varIndex int32, objPtr uintptr) { /* tclTestObj.c:1446:1: */
	if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) != uintptr(0) {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
				(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) = objPtr
	if objPtr != uintptr(0) {
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).refCount++
	}
}

//----------------------------------------------------------------------
//
// GetVariableIndex --
//
//	Utility routine to get a test variable index from the command line.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func GetVariableIndex(tls *libc.TLS, interp uintptr, string uintptr, indexPtr uintptr) int32 { /* tclTestObj.c:1477:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var index int32 at bp, 4

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, string, bp) != TCL_OK {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp)) < 0 || *(*int32)(unsafe.Pointer(bp)) >= NUMBER_OF_OBJECT_VARS {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), ts+9923 /* "bad variable ind..." */, -1)
		return TCL_ERROR
	}

	*(*int32)(unsafe.Pointer(indexPtr)) = *(*int32)(unsafe.Pointer(bp /* index */))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// CheckIfVarUnset --
//
//	Utility function that checks whether a test variable is readable:
//	i.e., that varPtr[varIndex] is non-NULL.
//
// Results:
//	1 if the test variable is unset (NULL); 0 otherwise.
//
// Side effects:
//	Sets the interpreter result to an error message if the variable is
//	unset (NULL).
//
//----------------------------------------------------------------------

func CheckIfVarUnset(tls *libc.TLS, interp uintptr, varPtr uintptr, varIndex int32) int32 { /* tclTestObj.c:1518:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) == uintptr(0) {
		// var buf [56]int8 at bp+8, 56

		libc.Xsprintf(tls, bp+8, ts+9942, libc.VaList(bp, varIndex))
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ResetResult})).f(tls, interp)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), bp+8 /* &buf[0] */, -1)
		return 1
	}
	return 0
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Epoch of the tcl environment
// (if changed with tcl-env).

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// name and version of this package

var packageName = *(*[13]int8)(unsafe.Pointer(ts + 9970))               /* tclTestProcBodyObj.c:23:19 */
var packageVersion = *(*[4]int8)(unsafe.Pointer(ts + 9983 /* "1.1" */)) /* tclTestProcBodyObj.c:24:19 */

// Name of the commands exported by this package

var procCommand = *(*[5]int8)(unsafe.Pointer(ts + 9987))                /* tclTestProcBodyObj.c:30:19 */
var checkCommand = *(*[6]int8)(unsafe.Pointer(ts + 9437 /* "check" */)) /* tclTestProcBodyObj.c:31:19 */

// this struct describes an entry in the table of command names and command
// procs

type CmdTable1 = struct {
	cmdName  uintptr
	proc     uintptr
	exportIt int32
	_        [4]byte
} /* tclTestProcBodyObj.c:38:9 */

// this struct describes an entry in the table of command names and command
// procs

type CmdTable = CmdTable1 /* tclTestProcBodyObj.c:42:3 */

// List of commands to create when the package is loaded; must go after the
// declarations of the enable command procedure.

var commands = [3]CmdTable{
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: 0, proc: 0, exportIt: 1},
	{},
} /* tclTestProcBodyObj.c:61:23 */

var safeCommands = [3]CmdTable{
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: 0, proc: 0, exportIt: 1},
	{},
} /* tclTestProcBodyObj.c:67:23 */

//----------------------------------------------------------------------
//
// Procbodytest_Init --
//
//	This function initializes the "procbodytest" package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func Procbodytest_Init(tls *libc.TLS, interp uintptr) int32 { /* tclTestProcBodyObj.c:90:1: */
	return ProcBodyTestInitInternal(tls, interp, 0)
}

//----------------------------------------------------------------------
//
// Procbodytest_SafeInit --
//
//	This function initializes the "procbodytest" package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func Procbodytest_SafeInit(tls *libc.TLS, interp uintptr) int32 { /* tclTestProcBodyObj.c:114:1: */
	return ProcBodyTestInitInternal(tls, interp, 1)
}

//----------------------------------------------------------------------
//
// RegisterCommand --
//
//	This function registers a command in the context of the given
//	namespace.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func RegisterCommand(tls *libc.TLS, interp uintptr, namespace uintptr, cmdTablePtr uintptr) int32 { /* tclTestProcBodyObj.c:139:1: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	// var buf [128]int8 at bp+32, 128

	if (*CmdTable)(unsafe.Pointer(cmdTablePtr)).exportIt != 0 {
		libc.Xsprintf(tls, bp+32, ts+9992,
			libc.VaList(bp, namespace, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName))
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_EvalEx})).f(tls, interp, bp+32, -1, 0) != TCL_OK {
			return TCL_ERROR
		}
	}

	libc.Xsprintf(tls, bp+32, ts+10034, libc.VaList(bp+16, namespace, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, bp+32 /* &buf[0] */, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).proc, uintptr(0), uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// ProcBodyTestInitInternal --
//
//  This function initializes the Loader package.
//  The isSafe flag is 1 if the interpreter is safe, 0 otherwise.
//
// Results:
//  A standard Tcl result.
//
// Side effects:
//  None.
//
//----------------------------------------------------------------------

func ProcBodyTestInitInternal(tls *libc.TLS, interp uintptr, isSafe int32) int32 { /* tclTestProcBodyObj.c:179:1: */
	var cmdTablePtr uintptr

	if isSafe != 0 {
		cmdTablePtr = uintptr(unsafe.Pointer(&safeCommands))
	} else {
		cmdTablePtr = uintptr(unsafe.Pointer(&commands))
	}
	for ; (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName != 0; cmdTablePtr += 24 {
		if RegisterCommand(tls, interp, uintptr(unsafe.Pointer(&packageName)), cmdTablePtr) != TCL_OK {
			return TCL_ERROR
		}
	}

	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PkgProvideEx})).f(tls, interp, uintptr(unsafe.Pointer(&packageName)), uintptr(unsafe.Pointer(&packageVersion)), uintptr(0))
}

//----------------------------------------------------------------------
//
// ProcBodyTestProcObjCmd --
//
//  Implements the "procbodytest::proc" command. Here is the command
//  description:
//	procbodytest::proc newName argList bodyName
//  Looks up a procedure called $bodyName and, if the procedure exists,
//  constructs a Tcl_Obj of type "procbody" and calls Tcl_ProcObjCmd.
//  Arguments:
//    newName		the name of the procedure to be created
//    argList		the argument list for the procedure
//    bodyName		the name of an existing procedure from which the
//			body is to be copied.
//  This command can be used to trigger the branches in Tcl_ProcObjCmd that
//  construct a proc from a "procbody", for example:
//	proc a {x} {return $x}
//	a 123
//	procbodytest::proc b {x} a
//  Note the call to "a 123", which is necessary so that the Proc pointer
//  for "a" is filled in by the internal compiler; this is a hack.
//
// Results:
//  Returns a standard Tcl code.
//
// Side effects:
//  A new procedure is created.
//  Leaves an error message in the interp's result on error.
//
//----------------------------------------------------------------------

func ProcBodyTestProcObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestProcBodyObj.c:230:1: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var fullName uintptr
	var procCmd Tcl_Command
	var cmdPtr uintptr
	var procPtr uintptr = uintptr(0)
	var bodyObjPtr uintptr
	// var myobjv [5]uintptr at bp+96, 40

	var result int32

	if objc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+10041 /* "newName argsList..." */)
		return TCL_ERROR
	}

	// Find the Command pointer to this procedure

	fullName = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	procCmd = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tcl_FindCommand})).f(tls, interp, fullName, uintptr(0), TCL_LEAVE_ERR_MSG)
	if procCmd == uintptr(0) {
		return TCL_ERROR
	}

	cmdPtr = procCmd

	// check that this is a procedure and not a builtin command:
	// If a procedure, cmdPtr->objClientData is TclIsProc(cmdPtr).

	if (*Command)(unsafe.Pointer(cmdPtr)).objClientData != (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclIsProc})).f(tls, cmdPtr) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
			libc.VaList(bp, ts+10067, fullName, ts+10077, uintptr(0)))
		return TCL_ERROR
	}

	// it is a Tcl procedure: the client data is the Proc structure

	procPtr = (*Command)(unsafe.Pointer(cmdPtr)).objClientData
	if procPtr == uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp), libc.VaList(bp+32, ts+10102, /* "procedure \"" */
			fullName, ts+10114, uintptr(0)))
		return TCL_ERROR
	}

	// create a new object, initialize our argument vector, call into Tcl

	bodyObjPtr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclNewProcBodyObj})).f(tls, procPtr)
	if bodyObjPtr == uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendStringsToObj})).f(tls, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetObjResult})).f(tls, interp),
			libc.VaList(bp+64, ts+10145,
				fullName, ts+1678, uintptr(0)))
		return TCL_ERROR
	}
	(*Tcl_Obj)(unsafe.Pointer(bodyObjPtr)).refCount++

	*(*uintptr)(unsafe.Pointer(bp + 96)) = *(*uintptr)(unsafe.Pointer(objv))
	*(*uintptr)(unsafe.Pointer(bp + 96 + 1*8)) = *(*uintptr)(unsafe.Pointer(objv + 1*8))
	*(*uintptr)(unsafe.Pointer(bp + 96 + 2*8)) = *(*uintptr)(unsafe.Pointer(objv + 2*8))
	*(*uintptr)(unsafe.Pointer(bp + 96 + 3*8)) = bodyObjPtr
	*(*uintptr)(unsafe.Pointer(bp + 96 + 4*8)) = uintptr(0)

	result = (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_ProcObjCmd})).f(tls, uintptr(0), interp, objc, bp+96 /* &myobjv[0] */)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = bodyObjPtr
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}

	return result
}

//----------------------------------------------------------------------
//
// ProcBodyTestCheckObjCmd --
//
//  Implements the "procbodytest::check" command. Here is the command
//  description:
//	procbodytest::check
//
//  Performs an internal check that the Tcl_PkgPresent() command returns
//  the same version number as was registered when the procbodytest package
//  was provided.  Places a boolean in the interp result indicating the
//  test outcome.
//
// Results:
//  Returns a standard Tcl code.
//
//----------------------------------------------------------------------

func ProcBodyTestCheckObjCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestProcBodyObj.c:329:1: */
	var version uintptr

	if objc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+1356 /* "" */)
		return TCL_ERROR
	}

	version = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PkgPresentEx})).f(tls, interp, uintptr(unsafe.Pointer(&packageName)), uintptr(unsafe.Pointer(&packageVersion)), 1, uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, libc.Bool32(libc.Bool32(libc.Xstrcmp(tls, version, uintptr(unsafe.Pointer(&packageVersion))) == 0) != 0)))
	return TCL_OK
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Epoch of the tcl environment
// (if changed with tcl-env).

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Resource limits

// Resource limit string identifiers

type rlimit = struct {
	rlim_cur rlim_t
	rlim_max rlim_t
} /* resource.h:151:1 */

type orlimit = struct {
	rlim_cur int32
	rlim_max int32
} /* resource.h:158:1 */

type loadavg = struct {
	ldavg  [3]uint32
	_      [4]byte
	fscale int64
} /* resource.h:163:1 */

// The following macros convert between TclFile's and fd's. The conversion
// simple involves shifting fd's up by one to ensure that no valid fd is ever
// the same as NULL. Note that this code is duplicated from tclUnixPipe.c

// The stuff below is used to keep track of file handlers created and
// exercised by the "testfilehandler" command.

type Pipe1 = struct {
	readFile   TclFile
	writeFile  TclFile
	readCount  int32
	writeCount int32
} /* tclUnixTest.c:40:9 */

// The following macros convert between TclFile's and fd's. The conversion
// simple involves shifting fd's up by one to ensure that no valid fd is ever
// the same as NULL. Note that this code is duplicated from tclUnixPipe.c

// The stuff below is used to keep track of file handlers created and
// exercised by the "testfilehandler" command.

type Pipe = Pipe1 /* tclUnixTest.c:50:3 */

var testPipes [10]Pipe /* tclUnixTest.c:53:13: */

// The stuff below is used by the testalarm and testgotsig ommands.

var gotsig uintptr = ts + 6587 /* "0" */ /* tclUnixTest.c:59:19 */

//----------------------------------------------------------------------
//
// TclplatformtestInit --
//
//	Defines commands that test platform specific functionality for Unix
//	platforms.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Defines new commands.
//
//----------------------------------------------------------------------

func TclplatformtestInit(tls *libc.TLS, interp uintptr) int32 { /* tclUnixTest.c:96:1: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+10196 /* "testchmod" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestchmodCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10206 /* "testfilehandler" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilehandlerCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10222 /* "testfilewait" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilewaitCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10235 /* "testfindexecutab..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfindexecutableCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateObjCommand})).f(tls, interp, ts+10254 /* "testfork" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestforkObjCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10263 /* "testgetopenfile" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetopenfileCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10279 /* "testgetdefenc" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetdefencdirCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10293 /* "testsetdefenc" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetdefencdirCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10307 /* "testalarm" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestalarmCmd})),
		uintptr(0), uintptr(0))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateCommand})).f(tls, interp, ts+10317 /* "testgotsig" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgotsigCmd})),
		uintptr(0), uintptr(0))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestfilehandlerCmd --
//
//	This function implements the "testfilehandler" command. It is used to
//	test Tcl_CreateFileHandler, Tcl_DeleteFileHandler, and TclWaitForFile.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfilehandlerCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:140:1: */
	bp := tls.Alloc(4576)
	defer tls.Free(4576)

	var pipePtr uintptr
	// var i int32 at bp+496, 4

	var mask int32
	// var timeout int32 at bp+4572, 4

	// var buffer [4000]int8 at bp+548, 4000

	var file TclFile

	// NOTE: When we make this code work on Windows also, the following
	// variable needs to be made Unix-only.

	if !(initialized != 0) {
		for *(*int32)(unsafe.Pointer(bp + 496 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 496 /* i */)) < MAX_PIPES; *(*int32)(unsafe.Pointer(bp + 496 /* i */))++ {
			testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile = uintptr(0)
		}
		initialized = 1
	}

	if argc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10328, uintptr(0)))
		return TCL_ERROR
	}
	pipePtr = uintptr(0)
	if argc >= 3 {
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+496) != TCL_OK {
			return TCL_ERROR
		}
		if *(*int32)(unsafe.Pointer(bp + 496)) >= MAX_PIPES {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+10342 /* "bad index " */, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0)))
			return TCL_ERROR
		}
		pipePtr = uintptr(unsafe.Pointer(&testPipes)) + uintptr(*(*int32)(unsafe.Pointer(bp + 496)))*24
	}

	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10353) == 0 {
		for *(*int32)(unsafe.Pointer(bp + 496 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 496 /* i */)) < MAX_PIPES; *(*int32)(unsafe.Pointer(bp + 496 /* i */))++ {
			if testPipes[*(*int32)(unsafe.Pointer(bp + 496))].readFile != uintptr(0) {
				(*struct {
					f func(*libc.TLS, TclFile) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclpCloseFile})).f(tls, testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile)
				testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile = uintptr(0)
				(*struct {
					f func(*libc.TLS, TclFile) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclpCloseFile})).f(tls, testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].writeFile)
				testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].writeFile = uintptr(0)
			}
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10359) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+56, ts+2243, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10365, uintptr(0)))
			return TCL_ERROR
		}
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount = libc.AssignPtrInt32(pipePtr+20, 0)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10379) == 0 {
		// var buf [48]int8 at bp+500, 48

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+88, ts+2243, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10386, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xsprintf(tls, bp+500, ts+4594, libc.VaList(bp+120, (*Pipe)(unsafe.Pointer(pipePtr)).readCount, (*Pipe)(unsafe.Pointer(pipePtr)).writeCount))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+136, bp+500 /* &buf[0] */, uintptr(0)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+1284) == 0 {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+152, ts+2243, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10401, uintptr(0)))
			return TCL_ERROR
		}
		if (*Pipe)(unsafe.Pointer(pipePtr)).readFile == uintptr(0) {
			if !((*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclpCreatePipe})).f(tls, pipePtr, pipePtr+8) != 0) {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+184, ts+10435, /* "couldn't open pi..." */
					(*struct {
						f func(*libc.TLS, uintptr) uintptr
					})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
				return TCL_ERROR
			}
			libc.Xfcntl(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)-1, F_SETFL, libc.VaList(bp+208, O_NONBLOCK))
			libc.Xfcntl(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)-1, F_SETFL, libc.VaList(bp+216, O_NONBLOCK))
		}
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount = 0
		(*Pipe)(unsafe.Pointer(pipePtr)).writeCount = 0

		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6589) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)-1, int32(1)<<1,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+10456) == 0 {
			(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteFileHandler})).f(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)-1)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+10460) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)-1, 0,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+224, ts+10469 /* "bad read mode \"" */, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+1678 /* "\"" */, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+6612) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)-1, int32(1)<<2,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+10456) == 0 {
			(*struct{ f func(*libc.TLS, int32) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DeleteFileHandler})).f(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)-1)
		} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+10460) == 0 {
			(*struct {
				f func(*libc.TLS, int32, int32, uintptr, ClientData)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_CreateFileHandler})).f(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)-1, 0,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+256, ts+10469 /* "bad read mode \"" */, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+1678 /* "\"" */, uintptr(0)))
			return TCL_ERROR
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10485) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+288, ts+2243, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10491, uintptr(0)))
			return TCL_ERROR
		}

		for libc.Xread(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).readFile)-1, bp+548, uint64(4000)) > int64(0) {
			// Empty loop body.
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10505) == 0 {
		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+320, ts+2243, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10510, uintptr(0)))
			return TCL_ERROR
		}

		libc.Xmemset(tls, bp+548, 'a', uint64(4000))
		for libc.Xwrite(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)-1, bp+548, uint64(4000)) > int64(0) {
			// Empty loop body.
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10523) == 0 {
		// var buf [24]int8 at bp+4548, 24

		if argc != 3 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+352, ts+2243, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10535, uintptr(0)))
			return TCL_ERROR
		}

		libc.Xmemset(tls, bp+548, 'b', uint64(10))
		(*struct {
			f func(*libc.TLS, uintptr, int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclFormatInt})).f(tls, bp+4548 /* &buf[0] */, libc.Xwrite(tls, int32((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)-1, bp+548 /* &buffer[0] */, uint64(10)))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+384, bp+4548 /* &buf[0] */, uintptr(0)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10555) == 0 {
		(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, int32(1)<<3|int32(1)<<1)
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10564) == 0 {
		if argc != 5 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+400, ts+2243, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv)), ts+10569, uintptr(0)))
			return TCL_ERROR
		}
		if (*Pipe)(unsafe.Pointer(pipePtr)).readFile == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+432, ts+10608 /* "pipe " */, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+10614 /* " doesn't exist" */, uintptr(0)))
			return TCL_ERROR
		}
		if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)), ts+6589) == 0 {
			mask = int32(1) << 1
			file = (*Pipe)(unsafe.Pointer(pipePtr)).readFile
		} else {
			mask = int32(1) << 2
			file = (*Pipe)(unsafe.Pointer(pipePtr)).writeFile
		}
		if (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+4572) != TCL_OK {
			return TCL_ERROR
		}
		*(*int32)(unsafe.Pointer(bp + 496 /* i */)) = (*struct {
			f func(*libc.TLS, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclUnixWaitForFile})).f(tls, int32(file)-1, mask, *(*int32)(unsafe.Pointer(bp + 4572 /* timeout */)))
		if *(*int32)(unsafe.Pointer(bp + 496))&(int32(1)<<1) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6589 /* "readable" */)
		}
		if *(*int32)(unsafe.Pointer(bp + 496))&(int32(1)<<2) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6612 /* "writable" */)
		}
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10629) == 0 {
		(*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DoOneEvent})).f(tls, int32(1)<<2|int32(1)<<1)
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+464, ts+1303 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),

			ts+10641, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

var initialized int32 = 0 /* tclUnixTest.c:148:16 */

func TestFileHandlerProc(tls *libc.TLS, clientData ClientData, mask int32) { /* tclUnixTest.c:329:1: */
	var pipePtr uintptr = clientData

	if mask&(int32(1)<<1) != 0 {
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount++
	}
	if mask&(int32(1)<<2) != 0 {
		(*Pipe)(unsafe.Pointer(pipePtr)).writeCount++
	}
}

//----------------------------------------------------------------------
//
// TestfilewaitCmd --
//
//	This function implements the "testfilewait" command. It is used to
//	test TclUnixWaitForFile.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfilewaitCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:362:1: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var mask int32
	var result int32
	// var timeout int32 at bp+88, 4

	var channel Tcl_Channel
	var fd int32
	// var data ClientData at bp+80, 8

	if argc != 4 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10739, uintptr(0)))
		return TCL_ERROR
	}
	channel = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) Tcl_Channel
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannel})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uintptr(0))
	if channel == uintptr(0) {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+6589) == 0 {
		mask = int32(1) << 1
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+6612) == 0 {
		mask = int32(1) << 2
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+10777) == 0 {
		mask = int32(1)<<2 | int32(1)<<1
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+32, ts+6675 /* "bad argument \"" */, *(*uintptr)(unsafe.Pointer(argv + 2*8)),
			ts+10782, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, Tcl_Channel, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetChannelHandle})).f(tls, channel,
		func() int32 {
			if mask&(int32(1)<<1) != 0 {
				return int32(1) << 1
			}
			return int32(1) << 2
		}(),
		bp+80) != TCL_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+64, ts+10821 /* "couldn't get cha..." */, uintptr(0)))
		return TCL_ERROR
	}
	fd = int32(*(*ClientData)(unsafe.Pointer(bp + 80)))
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+88) != TCL_OK {
		return TCL_ERROR
	}
	result = (*struct {
		f func(*libc.TLS, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntPlatStubs)(unsafe.Pointer(tcl.XtclIntPlatStubsPtr)).tclUnixWaitForFile})).f(tls, fd, mask, *(*int32)(unsafe.Pointer(bp + 88 /* timeout */)))
	if result&(int32(1)<<1) != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6589 /* "readable" */)
	}
	if result&(int32(1)<<2) != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendElement})).f(tls, interp, ts+6612 /* "writable" */)
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestfindexecutableCmd --
//
//	This function implements the "testfindexecutable" command. It is used
//	to test TclpFindExecutable.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfindexecutableCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:431:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var saveName uintptr

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+2243 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10847, uintptr(0)))
		return TCL_ERROR
	}

	saveName = (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetObjNameOfExecutable})).f(tls)
	(*Tcl_Obj)(unsafe.Pointer(saveName)).refCount++

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclpFindExecutable})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclGetObjNameOfExecutable})).f(tls))

	(*struct {
		f func(*libc.TLS, uintptr, Tcl_Encoding)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclIntStubs)(unsafe.Pointer(tcl.XtclIntStubsPtr)).tclSetObjNameOfExecutable})).f(tls, saveName, uintptr(0))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = saveName
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).refCount, 1) <= 1 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tclFreeObj})).f(tls, _objPtr)
		}
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetopenfileCmd --
//
//	This function implements the "testgetopenfile" command. It is used to
//	get a FILE * value from a registered channel.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetopenfileCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:474:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var filePtr ClientData at bp+48, 8

	if argc != 3 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10855, uintptr(0)))
		return TCL_ERROR
	}
	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetOpenFile})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))), 1, bp+48) ==
		TCL_ERROR {
		return TCL_ERROR
	}
	if *(*ClientData)(unsafe.Pointer(bp + 48)) == uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp+32, ts+10880, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestsetdefencdirCmd --
//
//	This function implements the "testsetdefenc" command. It is used to
//	test Tcl_SetDefaultEncodingDir().
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetdefencdirCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:517:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+10923, uintptr(0)))
		return TCL_ERROR
	}

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetDefaultEncodingDir})).f(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestforkObjCmd --
//
//	This function implements the "testfork" command. It is used to
//	fork the Tcl process for specific test cases.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestforkObjCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclUnixTest.c:551:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pid pid_t

	if objc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+1356 /* "" */)
		return TCL_ERROR
	}
	pid = libc.Xfork(tls)
	if pid == -1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp,
			libc.VaList(bp, ts+10936, uintptr(0)))
		return TCL_ERROR
	}
	// Only needed when pthread_atfork is not present,
	// should not hurt otherwise.
	if pid == 0 {
		(*struct{ f func(*libc.TLS) ClientData })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_InitNotifier})).f(tls)
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_SetObjResult})).f(tls, interp, (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_NewIntObj})).f(tls, pid))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestgetdefencdirCmd --
//
//	This function implements the "testgetdefenc" command. It is used to
//	test Tcl_GetDefaultEncodingDir().
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetdefencdirCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:596:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if argc != 1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+1357 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), uintptr(0)))
		return TCL_ERROR
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp+24, (*struct{ f func(*libc.TLS) uintptr })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetDefaultEncodingDir})).f(tls), uintptr(0)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// TestalarmCmd --
//
//	Test that EINTR is handled correctly by generating and handling a
//	signal. This requires using the SA_RESTART flag when registering the
//	signal handler.
//
// Results:
//	None.
//
// Side Effects:
//	Sets up an signal and async handlers.
//
//----------------------------------------------------------------------

func TestalarmCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:630:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var sec uint32 at bp+24, 4

	// var action sigaction at bp+32, 32

	if argc > 1 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetInt})).f(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+24 /* &sec */)
	} else {
		*(*uint32)(unsafe.Pointer(bp + 24 /* sec */)) = uint32(1)
	}

	// Setup the signal handling that automatically retries any interrupted
	// I/O system calls.

	*(*uintptr)(unsafe.Pointer(bp + 32)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) }{AlarmHandler}))
	libc.Xmemset(tls, bp+32+12, 0, uint64(unsafe.Sizeof(sigset_t{})))
	(*sigaction)(unsafe.Pointer(bp + 32 /* &action */)).sa_flags = SA_RESTART

	if libc.Xsigaction(tls, SIGALRM, bp+32, uintptr(0)) < 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, ts+10948 /* "sigaction: " */, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp), uintptr(0)))
		return TCL_ERROR
	}
	libc.Xalarm(tls, *(*uint32)(unsafe.Pointer(bp + 24 /* sec */)))
	return TCL_OK
}

//----------------------------------------------------------------------
//
// AlarmHandler --
//
//	Signal handler for the alarm command.
//
// Results:
//	None.
//
// Side effects:
// 	Calls the Tcl Async handler.
//
//----------------------------------------------------------------------

func AlarmHandler(tls *libc.TLS, signum int32) { /* tclUnixTest.c:686:1: */
	gotsig = ts + 6585 /* "1" */
}

//----------------------------------------------------------------------
//
// TestgotsigCmd --
//
// 	Verify the signal was handled after the testalarm command.
//
// Results:
//	None.
//
// Side Effects:
//	Resets the value of gotsig back to '0'.
//
//----------------------------------------------------------------------

func TestgotsigCmd(tls *libc.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:709:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, gotsig, uintptr(0)))
	gotsig = ts + 6587 /* "0" */
	return TCL_OK
}

//---------------------------------------------------------------------------
//
// TestchmodCmd --
//
//	Implements the "testchmod" cmd.  Used when testing "file" command.
//	The only attribute used by the Windows platform is the user write
//	flag; if this is not set, the file is made read-only.  Otehrwise, the
//	file is made read-write.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Changes permissions of specified files.
//
//---------------------------------------------------------------------------

func TestchmodCmd(tls *libc.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclUnixTest.c:740:1: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var i int32
	// var mode int32 at bp+32, 4

	if objc < 2 {
		(*struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_WrongNumArgs})).f(tls, interp, 1, objv, ts+10960 /* "mode file ?file ..." */)
		return TCL_ERROR
	}

	if (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetIntFromObj})).f(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+32) != TCL_OK {
		return TCL_ERROR
	}

	for i = 2; i < objc; i++ {
		// var buffer Tcl_DString at bp+40, 216

		var translated uintptr

		translated = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_TranslateFileName})).f(tls, interp, (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_GetString})).f(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))), bp+40 /* &buffer */)
		if translated == uintptr(0) {
			return TCL_ERROR
		}
		if libc.Xchmod(tls, translated, uint16(uint32(*(*int32)(unsafe.Pointer(bp + 32))))) != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_AppendResult})).f(tls, interp, libc.VaList(bp, translated, ts+3688 /* ": " */, (*struct {
				f func(*libc.TLS, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_PosixError})).f(tls, interp),
				uintptr(0)))
			return TCL_ERROR
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*TclStubs)(unsafe.Pointer(tcl.XtclStubsPtr)).tcl_DStringFree})).f(tls, bp+40 /* &buffer */)
	}
	return TCL_OK
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// tab-width: 8
// End:

func init() {
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 0 /* .cmdName */)) = uintptr(unsafe.Pointer(&procCommand))                                                   // tclTestProcBodyObj.c:62:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 8)) = ProcBodyTestProcObjCmd                              // tclTestProcBodyObj.c:62:20:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 24 /* .cmdName */)) = uintptr(unsafe.Pointer(&checkCommand))                                                 // tclTestProcBodyObj.c:63:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 32)) = ProcBodyTestCheckObjCmd                            // tclTestProcBodyObj.c:63:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 0 /* .cmdName */)) = uintptr(unsafe.Pointer(&procCommand))                                               // tclTestProcBodyObj.c:68:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 8)) = ProcBodyTestProcObjCmd                          // tclTestProcBodyObj.c:68:20:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 24 /* .cmdName */)) = uintptr(unsafe.Pointer(&checkCommand))                                             // tclTestProcBodyObj.c:69:7:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 32)) = ProcBodyTestCheckObjCmd                        // tclTestProcBodyObj.c:69:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 24)) = SimplePathInFilesystem                                        // tclTest.c:371:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 88)) = SimpleStat                                                    // tclTest.c:385:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 96)) = SimpleAccess                                                    // tclTest.c:386:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, int32) Tcl_Channel)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 104)) = SimpleOpenFileChannel                    // tclTest.c:387:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 112)) = SimpleMatchInDirectory            // tclTest.c:388:5:
	*(*func(*libc.TLS) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 136)) = SimpleListVolumes                                                            // tclTest.c:392:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 24)) = TestReportInFilesystem                                 // tclTest.c:337:5:
	*(*func(*libc.TLS, ClientData) ClientData)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 32)) = TestReportDupInternalRep                                // tclTest.c:338:5:
	*(*func(*libc.TLS, ClientData))(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 40)) = TestReportFreeInternalRep                                          // tclTest.c:339:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 64)) = TestReportNormalizePath                         // tclTest.c:342:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 88)) = TestReportStat                                         // tclTest.c:345:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 96)) = TestReportAccess                                         // tclTest.c:346:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, int32) Tcl_Channel)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 104)) = TestReportOpenFileChannel         // tclTest.c:347:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 112)) = TestReportMatchInDirectory // tclTest.c:348:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 120)) = TestReportUtime                                       // tclTest.c:349:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 128)) = TestReportLink                               // tclTest.c:350:5:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 144)) = TestReportFileAttrStrings                           // tclTest.c:352:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 152)) = TestReportFileAttrsGet                // tclTest.c:353:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 160)) = TestReportFileAttrsSet                // tclTest.c:354:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 168)) = TestReportCreateDirectory                                      // tclTest.c:355:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 176)) = TestReportRemoveDirectory                      // tclTest.c:356:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 184)) = TestReportDeleteFile                                           // tclTest.c:357:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 192)) = TestReportCopyFile                                    // tclTest.c:358:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 200)) = TestReportRenameFile                                  // tclTest.c:359:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 208)) = TestReportCopyDirectory                      // tclTest.c:360:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 216)) = TestReportLstat                                       // tclTest.c:361:5:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 224 /* .loadFileProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	}{TestReportLoadFile})) // tclTest.c:362:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 240)) = TestReportChdir // tclTest.c:364:5:
}

var ts1 = "Tcltest\x00tcl_rcFileName\x00~/.tclshrc\x00reporting\x00simple\x008.5\x001.1.0\x008.6.12\x00gettimes\x00noop\x00testpurebytesobj\x00testsetbytearraylength\x00testbytestring\x00teststringbytes\x00testwrongnumargs\x00testfilesystem\x00testsimplefilesystem\x00testgetindexfromobjstruct\x00testasync\x00testbumpinterpepoch\x00testchannel\x00testchannelevent\x00testcmdtoken\x00testcmdinfo\x00testcmdtrace\x00testconcatobj\x00testcreatecommand\x00testdcall\x00testdel\x00testdelassocdata\x00testdoubledigits\x00testdstring\x00testencoding\x00testevalex\x00testevalobjv\x00testevent\x00testexithandler\x00testexprlong\x00testexprlongobj\x00testexprdouble\x00testexprdoubleobj\x00testexprparser\x00testexprstring\x00testfevent\x00testfilelink\x00testfile\x00testhashsystemhash\x00testgetassocdata\x00testgetint\x00testgetplatform\x00testgetvarfullname\x00testinterpdelete\x00testlink\x00testlocale\x00testpanic\x00testparseargs\x00testparser\x00testparsevar\x00testparsevarname\x00testregexp\x00testreturn\x00testsaveresult\x00testservicemode\x00testsetassocdata\x00testsetnoerr\x00testseterr\x00testset2\x00testseterrorcode\x00testsetobjerrorcode\x00testutfnext\x00testutfprev\x00testnumutfchars\x00testfindfirst\x00testfindlast\x00testsetplatform\x00teststaticpkg\x00testtranslatefilename\x00testupvar\x00T1\x00T2\x00testmainthread\x00testsetmainloop\x00testexitmainloop\x00T3\x00testnreunwind\x00testnrelevels\x00testinterpresolver\x00argv\x00stderr\x00-appinitprocerror\x00-appinitprocdeleteinterp\x00-appinitprocclosestderr\x00-appinitprocsetrcfile\x00wrong # args\x00create\x00delete\x00mark\x00bad option \"\x00\": must be create, delete, int, or mark\x00\x00wrong # args: should be \"\x00 option cmdName\"\x00original\x00get\x00??\x00CmdProc1\x00 \x00CmdProc2\x00unknown\x00 CmdDelProc1\x00 CmdDelProc2\x00 unknown\x00 nativeObjectProc\x00 stringProc\x00modify\x00new_command_data\x00new_delete_data\x00\": must be create, delete, get, or modify\x00CmdProc1 \x00CmdProc2 \x00CmdDelProc1 \x00CmdDelProc2 \x00 option arg\"\x00%p\x00name\x00bad command token \"\x00\"\x00\": must be create or name\x00 option script\"\x00tracetest\x00deletetest\x00leveltest\x00resulttest\x00Delete wasn't called\x00doubletest\x00\": must be tracetest, deletetest, doubletest or resulttest\x00Error\x00Break\x00Continue\x00Return\x00OtherStatus\x00 option\"\x00test_ns_basic::createdcommand\x00create2\x00value:at:\x00delete2\x00\": must be create, delete, create2, or delete2\x00CreatedCommandProc could not get command info for test_ns_basic::createdcommand\x00CreatedCommandProc in \x00CreatedCommandProc2 could not get command info for test_ns_basic::createdcommand\x00CreatedCommandProc2 in \x00bogus interpreter argument!\x00wrong # arguments: should be \"\x00 data_key\"\x00fpval ndigits type ?shorten?\x00double\x00conversion type\x00bad value? %g\n\x00shorten\x00bad flag\x00-\x00+\x00shortest\x00Steele\x00e\x00f\x00append\x00element\x00end\x00free\x00gresult\x00staticsmall\x00short\x00staticlarge\x00first0 first1 first2 first3 first4 first5 first6 first7 first8 first9\nsecond0 second1 second2 second3 second4 second5 second6 second7 second8 second9\nthird0 third1 third2 third3 third4 third5 third6 third7 third8 third9\nfourth0 fourth1 fourth2 fourth3 fourth4 fourth5 fourth6 fourth7 fourth8 fourth9\nfifth0 fifth1 fifth2 fifth3 fifth4 fifth5 fifth6 fifth7 fifth8 fifth9\nsixth0 sixth1 sixth2 sixth3 sixth4 sixth5 sixth6 sixth7 sixth8 sixth9\nseventh0 seventh1 seventh2 seventh3 seventh4 seventh5 seventh6 seventh7 seventh8 seventh9\n\x00This is a malloc-ed string\x00special\x00This is a specially-allocated string\x00bad gresult option \"\x00\": must be staticsmall, staticlarge, free, or special\x00length\x00result\x00trunc\x00start\x00\": must be append, element, end, free, get, length, result, trunc, or start\x00option\x00global\x00bad value \"\x00\": must be global\x00script ?global?\x00global word ?word ...?\x00subcommand ?arg ...?\x00subcommand\x00name position script\x00position specifier\x00queue\x00head\x00tail\x00    (command bound to \"testevent\" callback)\x00    (return value from \"testevent\" callback)\x00 create|delete value\"\x00\": must be create or delete\x00odd %d\n\x00ExitProcOdd: unable to write to stdout\x00even %d\n\x00ExitProcEven: unable to write to stdout\x00 expression\"\x00This is a result\x00: %ld\x00expression\x00: \x00source ?target?\x00could not create link from \"\x00\" to \"\x00\": \x00could not read link \"\x00unix\x00mac\x00windows\x00 path\"\x00 option ?arg arg arg arg arg arg arg arg arg arg arg arg arg arg?\"\x00 intRO realRO boolRO stringRO wideRO charRO ucharRO shortRO ushortRO uintRO longRO ulongRO floatRO uwideRO\"\x00int\x00real\x00bool\x00string\x00wide\x00char\x00uchar\x00ushort\x00uint\x00long\x00ulong\x00float\x00uwide\x00set\x00 intValue realValue boolValue stringValue wideValue charValue ucharValue shortValue ushortValue uintValue longValue ulongValue floatValue uwideValue\"\x00update\x00\": should be create, delete, get, set, or update\x00category ?locale?\x00ctype\x00numeric\x00time\x00collate\x00monetary\x00all\x00T3: wrong type for arg 2\x00T3: wrong type for arg 1\x00script length\x00\n    (remainder of script: \"\x00\")\x00expr length\x00\n    (remainder of expr: \"\x00expand\x00word\x00text\x00backslash\x00command\x00variable\x00subexpr\x00operator\x00varName\x00script length append\x00switch\x00?-switch ...? exp string ?matchVar? ?subMatchVar ...?\x00%d %d\x00couldn't set variable \"\x00%ld\x00-indices\x00-nocase\x00-about\x00-expanded\x00-line\x00-linestop\x00-lineanchor\x00-xflags\x00--\x00 data_key data_item\"\x00 platform\"\x00unsupported platform: should be one of unix, or windows\x00 prefix safe loaded\"\x00x\x00loaded\x00 level name ?name2? dest global\"\x00namespace\x00too many args\x00NONE\x00 option ?arg ...?\x00cmd\x00 cmd script\x00called \"testfevent code\" before \"testfevent create\"\x00share\x00%s\x00-force\x00mv\x00cp\x00rm\x00mkdir\x00cpdir\x00rmdir\x00name scope\x00::test_ns_var\x00alloc & free 100000 6 word items\n\x00   %.3f usec per alloc+free\n\x00alloc 5000 6 word items\n\x00   %.3f usec per alloc\n\x00free 5000 6 word items\n\x00   %.3f usec per free\n\x00Tcl_NewObj 5000 times\n\x00   %.3f usec per Tcl_NewObj\n\x00Tcl_DecrRefCount 5000 times\n\x00   %.3f usec per Tcl_DecrRefCount\n\x00TclGetStringFromObj of \"12345\" 100000 times\n\x0012345\x00   %.3f usec per TclGetStringFromObj of \"12345\"\n\x00Tcl_GetIntFromObj of \"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetIntFromObj of \"12345\"\n\x00Tcl_GetInt of \"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetInt of \"12345\"\n\x00sprintf of 12345 100000 times\n\x00%d\x00   %.3f usec per sprintf of 12345\n\x00hashtable lookup of \"gettimes\" 100000 times\n\x00   %.3f usec per hashtable lookup of \"gettimes\"\n\x00Tcl_SetVar of \"12345\" 100000 times\n\x00a\x00   %.3f usec per Tcl_SetVar of a to \"12345\"\n\x00Tcl_GetVar of a==\"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetVar of a==\"12345\"\n\x00value\x00?string?\x00value length\x00bytearray\x00before get\x00before set\x00 varName ?newValue?\"\x00 varName elemName ?newValue?\"\x00type script discard\x00small result\x00append result\x00free result\x00dynamic result\x00object result\x00called\x00notCalled\x00present\x00missing\x00same\x00different\x00dynamic\x00object\x00small\x00Exit MainLoop\n\x00 subcommand ?additional args..?\"\x00splice\x00setchannelerror\x00setchannelerrorinterp\x00cut\x00 cut channelName\"\x00clearchannelhandlers\x00 clearchannelhandlers channelName\"\x00info\x00 info channelName\"\x00read\x00write\x00nonblocking\x00blocking\x00line\x00none\x00full\x00async_flush\x00eof\x00blocked\x00unblocked\x00auto\x00saw_cr\x00lf\x00cr\x00crlf\x00queued_cr\x00inputbuffered\x00channel name required\x00isshared\x00isstandard\x00mode\x00mthread\x00open\x00tclIO\x00outputbuffered\x00queuedcr\x001\x000\x00readable\x00refcount\x00type\x00writable\x00transform\x00 transform channelId -command cmd\"\x00-command\x00bad argument \"\x00\": should be \"-command\"\x00unstack\x00 unstack channel\"\x00\": should be cut, clearchannelhandlers, info, isshared, mode, open, readable, splice, writable, transform, unstack\x00 channelName cmd ?arg1? ?arg2?\"\x00add\x00 channelName add eventSpec script\"\x00bad event name \"\x00\": must be readable, writable, or none\x00 channelName delete index\"\x00bad event index: \x00: must be nonnegative\x00bad event index \x00: out of range\x00TestChannelEventCmd: damaged event script list\x00list\x00 channelName list\"\x00removeall\x00 channelName removeall\"\x00 channelName delete index event\"\x00bad command \x00, must be one of add, delete, list, set, or removeall\x00 ?newmode?\"\x00insufficient arguments\x00b\x00c\x00d\x00argument targetvalue\x00dummy\x00index value comparison failed: got \x00 when \x00 expected\x00boolean\x00registered\x00failed\x00unregistered\x00lappend filesystemReport \x00stat\x00lstat\x00access\x00matchmounts\x00matchindirectory\x00chdir\x00loadfile\x00link\x00renamefile\x00copyfile\x00deletefile\x00createdirectory\x00copydirectory\x00removedirectory\x00fileattributestrings\x00fileattributesget\x00fileattributesset\x00utime\x00normalizepath\x00simplefs:/\x00read-only\x00r\x00string ?numBytes?\x00\"testutfnext\" can only handle %d bytes\x00Tcl_UtfNext is not supposed to read src[-1]\x00Tcl_UtfNext is not supposed to read src[end]\nDifferent result when src[end] is %#x\x00A\xa0\xc0\xc1\xc2\xd0\xe0\xe8\xf2\xf7\xf8\xfe\xff\x00bytes ?offset?\x00non-zero initial size\x00 creation problem\x00unexpected maximal size\x00 lookup problem\x00 value problem\x00non-zero final size\x00OK\x00Tcl_ConcatObj is unsafe:\x00foo bar sum\x00eeny meeny\x00\n\t* (a) concatObj does not have refCount 0\x00\n\t* (a) concatObj is not a new obj \x00(no new refCount)\x00(refCount added)\x00(more than one refCount added!)\x00extremely unsafe behaviour by Tcl_ConcatObj()\x00\n\t* (b) concatObj does not have refCount 0\x00\n\t* (b) concatObj is not a new obj \x00(refCount removed?)\x00\n\t* (c) concatObj does not have refCount 0\x00\n\t* (c) concatObj is not a new obj \x00\n\t* (d) concatObj does not have refCount 0\x00\n\t* (d) concatObj is not a new obj \x00\n\t* (e) concatObj does not have refCount 0\x00\n\t* (e) concatObj is not a new obj \x00(failed to concat)\x00(corrupted input!)\x00\n\t* (f) concatObj does not have refCount 0\x00\n\t* (f) concatObj is not a new obj \x00\n\t* (g) concatObj does not have refCount 0\x00\n\t* (g) concatObj is not a new obj \x00-bool\x00booltest\x00Marks the end of the options\x00-help\x00Print summary of command-line options and abort\x00::ns2\x00y\x00(NULL)\x00ctx1\x00ctx2\x00Y\x00up|down ?interp?\x00provided interpreter not found\x00operation\x00testInterpResolver\x00could not remove the resolver scheme\x00down\x00up\x00TCLOBJTEST_VARPTR\x00testbignumobj\x00testbooleanobj\x00testdoubleobj\x00testintobj\x00testindexobj\x00testlistobj\x00testobj\x00teststringobj\x00mult10\x00div10\x00iseven\x00radixsize\x00option ?arg ...?\x00var value\x00error in mp_init\x00error in mp_read_radix\x00varIndex\x00error in mp_mul_d\x00error in mp_div_d\x00error in mp_mod_2d\x00option arg ?arg ...?\x00not\x00\": must be set, get, or not\x00\": must be set, get, mult10, or div10\x00check\x00token\x00index\x00set2\x00setlong\x00setmaxlong\x00ismaxlong\x00get2\x00inttoobigtest\x00\": must be set, get, get2, mult10, or div10\x00replace\x00option arg ?arg...?\x00varIndex start count ?element...?\x00assign\x00bug3598580\x00convert\x00no type \x00 found\x00duplicate\x00freeallvars\x00invalidateStringRep\x00newobj\x00objtype\x00types\x00\": must be assign, convert, duplicate, freeallvars, newobj, objcount, objtype, refcount, type, or types\x00index value out of range\x00appendstrings\x00length2\x00setlength\x00maxchars\x00getunicode\x00appendself\x00appendself2\x00bad variable index\x00variable %d is unset (NULL)\x00procbodytest\x001.1\x00proc\x00namespace eval %s { namespace export %s }\x00%s::%s\x00newName argsList bodyName\x00command \"\x00\" is not a Tcl procedure\x00procedure \"\x00\" does not have a Proc struct!\x00failed to create a procbody object for procedure \"\x00testchmod\x00testfilehandler\x00testfilewait\x00testfindexecutable\x00testfork\x00testgetopenfile\x00testgetdefenc\x00testsetdefenc\x00testalarm\x00testgotsig\x00 option ... \"\x00bad index \x00close\x00clear\x00 clear index\"\x00counts\x00 counts index\"\x00 create index readMode writeMode\"\x00couldn't open pipe: \x00off\x00disabled\x00bad read mode \"\x00empty\x00 empty index\"\x00fill\x00 fill index\"\x00fillpartial\x00 fillpartial index\"\x00oneevent\x00wait\x00 wait index readable|writable timeout\"\x00pipe \x00 doesn't exist\x00windowevent\x00\": must be close, clear, counts, create, empty, fill, fillpartial, oneevent, wait, or windowevent\x00 file readable|writable|both timeout\"\x00both\x00\": must be readable, writable, or both\x00couldn't get channel file\x00 argv0\"\x00 channelName forWriting\"\x00Tcl_GetOpenFile succeeded but FILE * NULL!\x00 defaultDir\"\x00Cannot fork\x00sigaction: \x00mode file ?file ...?\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
